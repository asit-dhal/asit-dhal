{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Me Hi ! I am Asit Dhal. I am a software engineer by profession, I work in C++14, OpenGL and Qt. I try to write simple and elegant code. I also know a little bit about Golang and Rust, have worked in Python and PyQt. Contact Me Github Mail me","title":"Home"},{"location":"#about-me","text":"Hi ! I am Asit Dhal. I am a software engineer by profession, I work in C++14, OpenGL and Qt. I try to write simple and elegant code. I also know a little bit about Golang and Rust, have worked in Python and PyQt.","title":"About Me"},{"location":"#contact-me","text":"Github Mail me","title":"Contact Me"},{"location":"cpp/string-conversion-benchmark/","text":"string conversion benchmark in C++ There are three ways to convert any fundamental data to string. std::to_string std::ostringstream boost::lexical_cast template <typename T> std::string stringify_ostringstream(T val) { std::ostringstream ss; ss << val; return ss.str(); } std::ostringstream g_buffer; template <typename T> std::string stringify_ostringstream_reuse(T val) { g_buffer.str(\"\"); g_buffer.clear(); g_buffer << val; return g_buffer.str(); } template <typename T> std::string stringify_tostring(T val) { return std::to_string(val); } In this post, I will analyze which one is the fastest to convert any fundamental(int, double, boolean) data to string. I am using google benchmark to measure the time difference. In all charts, y-axis is time in nano seconds. type=int input_count = 1 For only, one conversion, both std::stringstream and std::ostringstream take nearly same time. boost::lexical_cast in the fastest. And std::to_string is faster than stringstream and slower than boost::lexical_cast. boost::lexical_cast is not the best way for string conversion, because it throws an exception in case of failure. type=int input_count > 30 Here both std::stringstream and std::ostringstream outperform std::to_string and boost::lexical_cast. You can get better result by reusing std::stringstream and std::ostringstream buffer. std::ostringstream oss; oss.str(\u201c\u201d); oss.clear(); Creating stream objects are very expensive. So, reuse of buffer gives better result. type=double input_count=1 Performance is very similar to integer. Boost lexical_cast outperforms std::to_string and stringstream. type=double input_count=30 For multiple inputs, boost::lexical_cast outperforms everyone else. So, my observations are Always use std::to_string to convert any single value to std::string. In case of double, use std::string. If you need, precision, use std::ostringstream. In all other cases, use std::ostringstream. Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"string conversion benchmark in C++"},{"location":"cpp/string-conversion-benchmark/#string-conversion-benchmark-in-c","text":"There are three ways to convert any fundamental data to string. std::to_string std::ostringstream boost::lexical_cast template <typename T> std::string stringify_ostringstream(T val) { std::ostringstream ss; ss << val; return ss.str(); } std::ostringstream g_buffer; template <typename T> std::string stringify_ostringstream_reuse(T val) { g_buffer.str(\"\"); g_buffer.clear(); g_buffer << val; return g_buffer.str(); } template <typename T> std::string stringify_tostring(T val) { return std::to_string(val); } In this post, I will analyze which one is the fastest to convert any fundamental(int, double, boolean) data to string. I am using google benchmark to measure the time difference. In all charts, y-axis is time in nano seconds.","title":"string conversion benchmark in C++"},{"location":"cpp/string-conversion-benchmark/#typeint-input_count-1","text":"For only, one conversion, both std::stringstream and std::ostringstream take nearly same time. boost::lexical_cast in the fastest. And std::to_string is faster than stringstream and slower than boost::lexical_cast. boost::lexical_cast is not the best way for string conversion, because it throws an exception in case of failure.","title":"type=int input_count = 1"},{"location":"cpp/string-conversion-benchmark/#typeint-input_count-30","text":"Here both std::stringstream and std::ostringstream outperform std::to_string and boost::lexical_cast. You can get better result by reusing std::stringstream and std::ostringstream buffer. std::ostringstream oss; oss.str(\u201c\u201d); oss.clear(); Creating stream objects are very expensive. So, reuse of buffer gives better result.","title":"type=int input_count &gt; 30"},{"location":"cpp/string-conversion-benchmark/#typedouble-input_count1","text":"Performance is very similar to integer. Boost lexical_cast outperforms std::to_string and stringstream.","title":"type=double input_count=1"},{"location":"cpp/string-conversion-benchmark/#typedouble-input_count30","text":"For multiple inputs, boost::lexical_cast outperforms everyone else. So, my observations are Always use std::to_string to convert any single value to std::string. In case of double, use std::string. If you need, precision, use std::ostringstream. In all other cases, use std::ostringstream. Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"type=double input_count=30"},{"location":"git/delete-old-branches-in-git/","text":"Sometimes there are many branches, accumulated over the years in a git repository. And you need to delete it to save some space or make management of your repository easy. To get the list of all local branches \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git branch ci-build-script dev * master remotes/origin/add-license-1 remotes/origin/benchmark After that, you can iterate over all local branches and get some technical details like branch creation date(age of the branch), last commit date, last commit message etc. I will try to delete ci-build-script. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git merge-base ci-build-script master e3b47d97284b911baa266853b208f5ea25115e67 git merge-base tries to find out a good common ancestor. This can be assumed to return the earliest commit id where branch deviates from master branch. You can use the commit id of the common ancestor to get creation date and the age of the branch. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%ad\u201d \u2014 date=short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 2017\u201309\u201325 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%cr\u201d \u2014 date=short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 6 months ago Similarly, you can use the branch name to get the latest commit date, age of last commit and the subject line of last commit message. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%ad\u201d \u2014 date=short -n 1 ci-build-script 2017\u201309\u201326 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%cr\u201d \u2014 date=short -n 1 ci-build-script 5 months ago \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log --pretty=format:\"%s\" -n 1 ci-build-script gcc tnd clang config for travis From that you can make an intelligent guess, should you delete the branch or not. The branch ci-build-script was created 5 months ago and last committed 5 months ago. The commit message was \u201cgcc and clang config for travis\u201d. You can delete it git branch -d ci-build-script -d option won\u2019t allow you delete unless it is merged. In some cases branch were never merged. So, you can use -D option You can wrap all the above and make a script. #!/bin/bash # # Copyright(c) 2018 Asit Dhal. # Distributed under the MIT License (http://opensource.org/licenses/MIT) # LIGHT_BLUE='\\033[1;34m' RED='\\033[0;31m' NC='\\033[0m' # No Color INTERACTIVE=\"\" FORCE_DELETE=\"\" MASTER=\"master\" while [[ $# -gt 0 ]] do key=\"$1\" case $key in -f) FORCE_DELETE=\"y\" shift ;; -i) INTERACTIVE=\"i\" shift ;; -fi|-if) INTERACTIVE=\"i\" FORCE_DELETE=\"y\" shift ;; -h) echo \"$(basename $0) -i Intecative deletion of local branches\" echo \"$(basename $0) -f Force delete the branch(es)\" echo \"$(basename $0) List local branches with creation and last update date\" exit ;; *) shift esac done current_branch=$(git branch | grep \"*\") current_branch=${current_branch/* /} if [ \"${current_branch}\" != \"${MASTER}\" ]; then printf \"Please change the current branch to ${LIGHT_BLUE}${MASTER}${NC}\\n\" exit fi if ! git diff-files --quiet; then printf \"you have unstaged changes. $(basename $0) needs a clean working index\\n\" git diff-files --name-status printf \"Please commit or stash them.\\n\" exit fi if ! git diff-index --cached --quiet HEAD; then printf \"your index contains uncommitted changes. $(basename $0) needs a clean working index\\n\" git diff-index --cached --name-status HEAD printf \"Please commit or stash them.\\n\" exit fi for brnch in $(git branch | sed /\\*/d); do created_commit_id=$(git merge-base ${brnch} ${MASTER}) created_date=$(git log --pretty=format:\"%ad\" --date=short -n 1 ${created_commit_id}) created_ago=$(git log --pretty=format:\"%cr\" --date=short -n 1 ${created_commit_id}) last_updated_date=$(git log --pretty=format:\"%ad\" --date=short -n 1 ${brnch}) updated_before=$(git log --pretty=format:\"%cr\" --date=short -n 1 ${brnch}) commit_message_subject=$(git log --pretty=format:'%s' -n 1 ${brnch}) printf \"Branch name : ${brnch} \\n\" printf \"Created on : ${created_date}${RED}(${created_ago})${NC}\\n\" printf \"Last updated on : ${last_updated_date}${RED}(${updated_before}${NC})\\n\" printf \"Last commit message : ${commit_message_subject}\\n\" if [ \"${INTERACTIVE}\" == \"i\" ]; then printf \"${LIGHT_BLUE}Delete the branch, followed by [y/n]?${NC} \" read ip if [ \"$ip\" == \"y\" ]; then if [ \"${FORCE_DELETE}\" == \"y\" ]; then git branch -D ${brnch} else git branch -d ${brnch} if [ $? -ne 0 ]; then printf \"${LIGHT_BLUE}Run with -fi command to delete ${brnch}${NC}\\n\" fi fi fi fi done The script has 2 options: -i and -f-. If the run the script without any options, it will give you list of all local branches and the above information. \u2570\u2500$ git-clean-local-branches Branch name : ci-build-script Created on : 2017\u201309\u201325(6 months ago) Last updated on : 2017\u201309\u201326(5 months ago) Last commit message : gcc tnd clang config for travis Branch name : dev Created on : 2017\u201310\u201314(5 months ago) Last updated on : 2017\u201311\u201325(4 months ago) Last commit message : stringify improvement, size and type name removal Branch name : remotes/origin/add-license-1 Created on : 2017\u201310\u201314(5 months ago) Last updated on : 2017\u201310\u201314(5 months ago) Last commit message : Create LICENSE Branch name : remotes/origin/benchmark Created on : 2017\u201310\u201306(5 months ago) Last updated on : 2017\u201310\u201316(5 months ago) Last commit message : cxx-pretty print integration -i option allows you interactive deletion. -f option uses git delete -D(force delete). \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git-clean-local-branches -fi Branch name : ci-build-script Created on : 2017\u201309\u201325(6 months ago) Last updated on : 2017\u201309\u201326(5 months ago) Last commit message : gcc tnd clang config for travis Delete the branch, followed by [y/n]? y Deleted branch ci-build-script (was 2cb728c). Branch name : dev Created on : 2017\u201310\u201314(5 months ago) Last updated on : 2017\u201311\u201325(4 months ago) Last commit message : stringify improvement, size and type name removal Delete the branch, followed by [y/n]? y Deleted branch dev (was f8698b4). Thanks for reading.","title":"Delete old branches in Git"},{"location":"juce/broadcasters-and-listeners-in-juce/","text":"Broadcasters and listeners in JUCE Juce uses broadcasters and listeners pattern to propagate state changes. This is like classical observer pattern. Broadcasters are subjects and listeners are observers. Juce Framework provides predefined library to automate this process. Let\u2019s say we have a Window with a slider and a label. When the user changes the slider position, the label will show the value. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } At this moment both the slider and the label don\u2019t interact with each other. We are going to show the value of slider in the label. Listeners Most Juce components have an inner class called Listener. This class is an abstract class with at least one pure virtual function. An observer has to inherit from this abstract class and implement the pure virtual function(s). This pure virtual function is the callback. one member function called void addListener(Listener* listener). Using this function, an observer can register it self. another member function called void removeListener(Listener* listener). This one removes the previously registered listener. Whenever a listener is registered, the address is stored in a ListenerList container. Whenever the state changes, the broadcaster iterates over all the registered listeners and calls the appropriate callback. Slider::Listener provides Slider::Listener::sliderValueChanged( Slider *slide) . We can override that function in the MainComponent. Then register the main component as a listener. In the implementation of sliderValueChanged, we can set the value of the slider in the label. //MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, public Slider::Listener // step 1: inherit the listener abstract class { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; // step 2: implementation of pure virtual function void sliderValueChanged(Slider *slider) override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; //MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); // step 3: register the listener m_valueSlider.addListener(this); } MainComponent::~MainComponent() { // step 5: unregister the listener m_valueSlider.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } void MainComponent::sliderValueChanged(Slider *slider) { // step 4: when the value changes, do whatever you want to do. if (&m_valueSlider == slider) { auto value = slider->getValue(); m_sliderLabel.setText(String(std::to_string(static_cast<int>(value))), dontSendNotification); } } The broadcaster and listener can have a many to many relationship. One callback can be invoked by many broadcaster. So, you need to know which instanced invoked it. So we do the address comparison in line 44(In this case, it\u2019s not necessary, because we have only one broadcaster.). User provided Listener You can also provide your own Listener interface. Let\u2019s say you have a login form. It has two input boxes, one submit button and one clear button. Clear button is activated when at least one input box has some text and Submit button is activated if both are filled with some data. We separate the username and password input control to a separate component, called InputForm. In the main component, we have the InputForm and bothe the buttons. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: InputForm(); ~InputForm(); void paint (Graphics&) override; void resized() override; void submit(); void clear(); private: Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); } InputForm::~InputForm() { } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } We can add a listener interface to the InputForm. It will have to callbacks clearActivated() submitActivated() InputForm must maintain a list of interested listeners and should provide api call for registration and de-registration. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: // other code class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); // ... private: void clearActivate(bool isActive); void submitActivate(bool isActive); // ... bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; // .... }; // InputForm.cpp InputForm::InputForm() { // ... m_clearActive = false; m_submitActive = false; } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } Juce ListenerList class should be used to store the list of listeners. It has many advantages than the std lists, like add or remove listeners from the list during one of the callbacks\u200a\u2014\u200ai.e. while it\u2019s in the middle of iterating the listeners, then it\u2019s guaranteed that no listeners will be mistakenly called after they\u2019ve been removed, but it may mean that some of the listeners could be called more than once, or not at all, depending on the list\u2019s order. It has a bailout checker(Component::BailOutChecker class) which checks if the component has already been deleted. This provides safety guarantee that no callback will be called on a deleted component. ListenerList checks if the listener is already in the list or not. So, double addition won\u2019t have any effect. Now, after implementing input and clear logic, the InputForm control looks like this. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component, public Label::Listener { public: InputForm(); ~InputForm(); class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); void paint (Graphics&) override; void resized() override; void labelTextChanged(Label *labelThatHasChanged) override; void submit(); void clear(); private: void clearActivate(bool isActive); void submitActivate(bool isActive); Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); m_clearActive = false; m_submitActive = false; m_usernameInput.addListener(this); m_passwordInput.addListener(this); } InputForm::~InputForm() { m_usernameInput.removeListener(this); m_passwordInput.removeListener(this); } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } void InputForm::labelTextChanged(Label *labelThatHasChanged) { bool atLeastOneTextFilled = false; if (labelThatHasChanged == &m_usernameInput) { atLeastOneTextFilled = !m_usernameInput.getText(false).isEmpty(); } else if (labelThatHasChanged == &m_passwordInput) { atLeastOneTextFilled = !m_passwordInput.getText(false).isEmpty(); } if (!m_clearActive && atLeastOneTextFilled) { m_clearActive = true; clearActivate(true); } else if (m_clearActive && !atLeastOneTextFilled) { m_clearActive = false; clearActivate(false); } bool allTextFilled = !m_usernameInput.getText(true).isEmpty() && !m_passwordInput.getText(true).isEmpty(); if (!m_submitActive && allTextFilled) { m_submitActive = true; submitActivate(true); } else if (m_submitActive && !allTextFilled) { m_submitActive = false; submitActivate(false); } } void InputForm::submit() { // do nothing } void InputForm::clear() { m_usernameInput.setText(\"\", NotificationType::sendNotification); m_passwordInput.setText(\"\", NotificationType::sendNotification); } When you clear the label programmatically, you need to set the NotificationType. In this case, once the input texts are cleared, we need the callbacks to be called to set the submit and active status. So, we use NotificationType as sendNotification. In the main component, we implement the InputForm::Listener interface and accordingly set the enabled/disabled status of the buttons. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component, public InputForm::Listener { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; void clearActivated(InputForm*, bool isActive) override; void submitActivated(InputForm*, bool isActive) override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; {% endhighlight %} {% highlight cpp %} // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); m_clearButton.setEnabled(false); m_submitButton.setEnabled(false); m_inputForm.addListener(this); m_clearButton.onClick = [this] {m_inputForm.clear(); }; m_submitButton.onClick = [this] {m_inputForm.submit(); }; setSize (600, 400); } MainComponent::~MainComponent() { m_inputForm.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } void MainComponent::clearActivated(InputForm*, bool isActive) { m_clearButton.setEnabled(isActive); } void MainComponent::submitActivated(InputForm*, bool isActive) { m_submitButton.setEnabled(isActive); } The application finally looks like this Comparison with Qt Signal/Slots Callbacks are like Slots in Qt. Qt MOC does all the major work of adding code for callback handling. There is no MOC here, so developer has to write everything. In Qt, signal emitters are completely decoupled from signal receivers. So, if you want to add a new signal, it needs minimum amount of code change. In Juce, you will need at least one pure virtual function, code for listener registration and removal. Both Qt and Juce provide asynchronous call by using Qt Event loop and Juce AsyncUpdater respectively. But Juce needs some protection from race condition. I wrote this blog to clarify my doubts. Feel free to correct if I am wrong or write a comment if you want to suggest something. The source code is shared here https://github.com/asit-dhal/Broadcaster-Listener-Demo","title":"Broadcasters and listeners in JUCE"},{"location":"juce/broadcasters-and-listeners-in-juce/#broadcasters-and-listeners-in-juce","text":"Juce uses broadcasters and listeners pattern to propagate state changes. This is like classical observer pattern. Broadcasters are subjects and listeners are observers. Juce Framework provides predefined library to automate this process. Let\u2019s say we have a Window with a slider and a label. When the user changes the slider position, the label will show the value. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } At this moment both the slider and the label don\u2019t interact with each other. We are going to show the value of slider in the label.","title":"Broadcasters and listeners in JUCE"},{"location":"juce/broadcasters-and-listeners-in-juce/#listeners","text":"Most Juce components have an inner class called Listener. This class is an abstract class with at least one pure virtual function. An observer has to inherit from this abstract class and implement the pure virtual function(s). This pure virtual function is the callback. one member function called void addListener(Listener* listener). Using this function, an observer can register it self. another member function called void removeListener(Listener* listener). This one removes the previously registered listener. Whenever a listener is registered, the address is stored in a ListenerList container. Whenever the state changes, the broadcaster iterates over all the registered listeners and calls the appropriate callback. Slider::Listener provides Slider::Listener::sliderValueChanged( Slider *slide) . We can override that function in the MainComponent. Then register the main component as a listener. In the implementation of sliderValueChanged, we can set the value of the slider in the label. //MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, public Slider::Listener // step 1: inherit the listener abstract class { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; // step 2: implementation of pure virtual function void sliderValueChanged(Slider *slider) override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; //MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); // step 3: register the listener m_valueSlider.addListener(this); } MainComponent::~MainComponent() { // step 5: unregister the listener m_valueSlider.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } void MainComponent::sliderValueChanged(Slider *slider) { // step 4: when the value changes, do whatever you want to do. if (&m_valueSlider == slider) { auto value = slider->getValue(); m_sliderLabel.setText(String(std::to_string(static_cast<int>(value))), dontSendNotification); } } The broadcaster and listener can have a many to many relationship. One callback can be invoked by many broadcaster. So, you need to know which instanced invoked it. So we do the address comparison in line 44(In this case, it\u2019s not necessary, because we have only one broadcaster.).","title":"Listeners"},{"location":"juce/broadcasters-and-listeners-in-juce/#user-provided-listener","text":"You can also provide your own Listener interface. Let\u2019s say you have a login form. It has two input boxes, one submit button and one clear button. Clear button is activated when at least one input box has some text and Submit button is activated if both are filled with some data. We separate the username and password input control to a separate component, called InputForm. In the main component, we have the InputForm and bothe the buttons. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: InputForm(); ~InputForm(); void paint (Graphics&) override; void resized() override; void submit(); void clear(); private: Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); } InputForm::~InputForm() { } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } We can add a listener interface to the InputForm. It will have to callbacks clearActivated() submitActivated() InputForm must maintain a list of interested listeners and should provide api call for registration and de-registration. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: // other code class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); // ... private: void clearActivate(bool isActive); void submitActivate(bool isActive); // ... bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; // .... }; // InputForm.cpp InputForm::InputForm() { // ... m_clearActive = false; m_submitActive = false; } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } Juce ListenerList class should be used to store the list of listeners. It has many advantages than the std lists, like add or remove listeners from the list during one of the callbacks\u200a\u2014\u200ai.e. while it\u2019s in the middle of iterating the listeners, then it\u2019s guaranteed that no listeners will be mistakenly called after they\u2019ve been removed, but it may mean that some of the listeners could be called more than once, or not at all, depending on the list\u2019s order. It has a bailout checker(Component::BailOutChecker class) which checks if the component has already been deleted. This provides safety guarantee that no callback will be called on a deleted component. ListenerList checks if the listener is already in the list or not. So, double addition won\u2019t have any effect. Now, after implementing input and clear logic, the InputForm control looks like this. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component, public Label::Listener { public: InputForm(); ~InputForm(); class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); void paint (Graphics&) override; void resized() override; void labelTextChanged(Label *labelThatHasChanged) override; void submit(); void clear(); private: void clearActivate(bool isActive); void submitActivate(bool isActive); Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); m_clearActive = false; m_submitActive = false; m_usernameInput.addListener(this); m_passwordInput.addListener(this); } InputForm::~InputForm() { m_usernameInput.removeListener(this); m_passwordInput.removeListener(this); } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } void InputForm::labelTextChanged(Label *labelThatHasChanged) { bool atLeastOneTextFilled = false; if (labelThatHasChanged == &m_usernameInput) { atLeastOneTextFilled = !m_usernameInput.getText(false).isEmpty(); } else if (labelThatHasChanged == &m_passwordInput) { atLeastOneTextFilled = !m_passwordInput.getText(false).isEmpty(); } if (!m_clearActive && atLeastOneTextFilled) { m_clearActive = true; clearActivate(true); } else if (m_clearActive && !atLeastOneTextFilled) { m_clearActive = false; clearActivate(false); } bool allTextFilled = !m_usernameInput.getText(true).isEmpty() && !m_passwordInput.getText(true).isEmpty(); if (!m_submitActive && allTextFilled) { m_submitActive = true; submitActivate(true); } else if (m_submitActive && !allTextFilled) { m_submitActive = false; submitActivate(false); } } void InputForm::submit() { // do nothing } void InputForm::clear() { m_usernameInput.setText(\"\", NotificationType::sendNotification); m_passwordInput.setText(\"\", NotificationType::sendNotification); } When you clear the label programmatically, you need to set the NotificationType. In this case, once the input texts are cleared, we need the callbacks to be called to set the submit and active status. So, we use NotificationType as sendNotification. In the main component, we implement the InputForm::Listener interface and accordingly set the enabled/disabled status of the buttons. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component, public InputForm::Listener { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; void clearActivated(InputForm*, bool isActive) override; void submitActivated(InputForm*, bool isActive) override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; {% endhighlight %} {% highlight cpp %} // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); m_clearButton.setEnabled(false); m_submitButton.setEnabled(false); m_inputForm.addListener(this); m_clearButton.onClick = [this] {m_inputForm.clear(); }; m_submitButton.onClick = [this] {m_inputForm.submit(); }; setSize (600, 400); } MainComponent::~MainComponent() { m_inputForm.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } void MainComponent::clearActivated(InputForm*, bool isActive) { m_clearButton.setEnabled(isActive); } void MainComponent::submitActivated(InputForm*, bool isActive) { m_submitButton.setEnabled(isActive); } The application finally looks like this Comparison with Qt Signal/Slots Callbacks are like Slots in Qt. Qt MOC does all the major work of adding code for callback handling. There is no MOC here, so developer has to write everything. In Qt, signal emitters are completely decoupled from signal receivers. So, if you want to add a new signal, it needs minimum amount of code change. In Juce, you will need at least one pure virtual function, code for listener registration and removal. Both Qt and Juce provide asynchronous call by using Qt Event loop and Juce AsyncUpdater respectively. But Juce needs some protection from race condition. I wrote this blog to clarify my doubts. Feel free to correct if I am wrong or write a comment if you want to suggest something. The source code is shared here https://github.com/asit-dhal/Broadcaster-Listener-Demo","title":"User provided Listener"},{"location":"juce/side-panel-in-juce/","text":"Side Panel in JUCE This tutorial explains the side panel in JUCE GUI framework. Side Panel can be used for navigation if the application doesn\u2019t have a tool bar or menu bar. Usually, it stays on the left or right side of the application and triggered by the user. Juce has built-in support for side panel. Let\u2019s first make a skeleton app. The app will have a button to trigger side panel and a label to show the status. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: TextButton m_invokeSidePanel; Label m_sidePanelStatus; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\") { addAndMakeVisible(m_invokeSidePanel); addAndMakeVisible(m_sidePanelStatus); m_sidePanelStatus.setText(\"status\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); } void MainComponent::resized() { auto localBounds = getLocalBounds(); if (localBounds.getHeight() / 2 - 50 > 5) localBounds.removeFromTop(localBounds.getHeight() / 2 - 50); if (localBounds.getWidth() / 2 - 50 > 5) localBounds.removeFromLeft(localBounds.getWidth() / 2 - 50); auto buttonBound = localBounds.removeFromTop(30).removeFromRight(100); auto statusLabelBound = localBounds.removeFromTop(30).removeFromRight(100).reduced(5); m_invokeSidePanel.setBounds(buttonBound); m_sidePanelStatus.setBounds(statusLabelBound); } When user clicks the button, the side panel should appear. There is already a closed button on the side panel, the user can click on this to close the side panel. The side panel will have a list of entries. When the user selects any of those entries, the status label should show the text. Juce provides a built in component called Side Panel, https://docs.juce.com/master/classSidePanel.html Sidepanel Components SidePanel has two parts. header which can contain a label, a few buttons and a close button a list box which shows a list of entries Let\u2019s add a SidePanel component to the main component. The SidePanel should be shown when the user clicks on the sidePanel button in the main component. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, // step 2: override Button::Listener to get broadcast events from the button public Button::Listener { public: // ... // step 3: implement the button clicked callback void buttonClicked(Button*) override; private: // ... // step 1: add sidepanel SidePanel m_sidePanel; }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"Side Panel Demo\", 250, true, nullptr, false) { // .... addAndMakeVisible(m_sidePanel); // ... m_invokeSidePanel.addListener(this); } MainComponent::~MainComponent() { m_invokeSidePanel.removeListener(this); } void MainComponent::buttonClicked(Button* btn) { if (btn == &m_invokeSidePanel) { // step 4: show the side panel when the button is clicked m_sidePanel.showOrHide(true); } } Now, if you run this, you will a side Panel without any contents on this(there will be only title and a close button). Header Component Let\u2019s add the header component The header has two shape buttons(one for home and another for settings), a title and a close button. // SidePanelHeader.h #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelHeader : public Component { public: SidePanelHeader(const String& titleText); ~SidePanelHeader(); void paint (Graphics&) override; void resized() override; private: Label m_titleLabel; ShapeButton m_homeButton{ \"Home\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }, m_settingsButton{ \"Settings\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelHeader) }; ShapeButton has only one constructor, which takes three color ids, normal color(the colour to fill the shape with when the mouse isn\u2019t over), overColor(the colour to use when the mouse is over the shape) and downColour(the colour to use when the button is in the pressed-down state). In the beginning we will make everything transparent black and repaint with proper color in the paint() method. // SidePanelHeader.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelHeader.h\" SidePanelHeader::SidePanelHeader(const String& titleText) { setOpaque(true); static const unsigned char homeIconPathData[] = { 110,109,0,0,64,65,0,0,64,64,98,0,0,64,65,0,0,64,64,74,12,186,64,164,112,5,65,24,217,22,64,70,182, 51,65,98,35,219,9,64,240,167,54,65,0,0,0,64,170,241,58,65,0,0,0,64,0,0,64,65,98,0,0,0,64,22,217, 72,65,166,155,28,64,0,0,80,65,0,0,64,64,0,0,80,65,108,0,0,160,64,0,0,80,65,108,0,0,160,64,0,0, 160,65,98,0,0,160,64,139,108,164,65,211,77,174,64,0,0,168,65,0,0,192,64,0,0,168,65,108,0,0,16,65, 0,0,168,65,98,22,217,24,65,0,0,168,65,0,0,32,65,127,106,164,65,0,0,32,65,0,0,160,65,108,0,0,32,65,0,0,128, 65,108,0,0,96,65,0,0,128,65,108,0,0,96,65,0,0,160,65,98,0,0,96,65,127,106,164,65,233,38,103,65,0,0,168, 65,0,0,112,65,0,0,168,65,108,0,0,144,65,0,0,168,65,98,139,108,148,65,0,0,168,65,0,0,152,65,139,108,164, 65,0,0,152,65,0,0,160,65,108,0,0,152,65,0,0,80,65,108,0,0,168,65,0,0,80,65,98,139,108,172,65,0,0,80,65,0, 0,176,65,23,217,72,65,0,0,176,65,0,0,64,65,98,0,0,176,65,170,241,58,65,156,196,174,65,240,167,54,65,158,239, 172,65,70,182,51,65,98,213,120,145,65,164,112,5,65,0,0,64,65,0,0,64,64,0,0,64,65,0,0,64,64,99, 101,0,0 }; static const unsigned char settingsIconPathData[] = { 110,109,202,111,210,64,243,226,61,64,108,0,0,224,64,0,0,0,0,108,0,0,48,65,0,0,0,0,108,27,200,54,65,243, 226,61,64,98,91,248,63,65,174,170,76,64,95,130,72,65,231,138,96,64,46,46,80,65,180,163,120,64,108,42, 181,124,65,20,38,49,64,108,149,90,142,65,246,108,199,64,108,68,249,118,65,2,85,1,65,98,112,166,119,65, 201,31,6,65,0,0,120,65,111,5,11,65,0,0,120,65,0,0,16,65,98,0,0,120,65,145,250,20,65,108,166,119,65,55, 224,25,65,72,249,118,65,254,170,30,65,108,151,90,142,65,133,73,60,65,108,46,181,124,65,123,182,115,65, 108,50,46,80,65,18,215,97,65,98,99,130,72,65,70,221,103,65,96,248,63,65,83,213,108,65,32,200,54,65,66, 135,112,65,108,0,0,48,65,0,0,144,65,108,0,0,224,64,0,0,144,65,108,202,111,210,64,67,135,112,65,98,74, 15,192,64,84,213,108,65,65,251,174,64,70,221,103,65,164,163,159,64,19,215,97,65,108,92,43,13,64,123,182, 115,65,108,187,181,82,62,133,73,60,65,108,244,26,36,64,254,170,30,65,98,64,102,33,64,55,224,25,5,0,0,32, 64,145,250,20,65,0,0,32,64,0,0,16,65,98,0,0,32,64,111,5,11,65,64,102,33,64,201,31,6,65,244,26,36,64,2,85, 1,65,108,187,181,82,62,246,108,199,64,108,92,43,13,64,20,38,49,64,108,164,163,159,64,180,163,120,64,98,65, 251,174,64,231,138,96,64,74,15,192,64,175,170,76,64,202,111,210,64,243,226,61,64,99,109,0,0,16,65,0,0,64, 65,98,121,130,42,65,0,0,64,65,0,0,64,65,121,130,42,65,0,0,64,65,0,0,16,65,98,0,0,64,65,13,251,234,64,121, 130,42,65,0,0,192,64,0,0,16,65,0,0,192,64,98,13,251,234,64,0,0,192,64,0,0,192,64,13,251,234,64,0,0,192,64, 0,0,16,65,98,0,0,192,64,121,130,42,65,13,251,234,64,0,0,64,65,0,0,16,65,0,0,64,65,99,101,0,0 }; Path p; p.loadPathFromData(homeIconPathData, sizeof(homeIconPathData)); m_homeButton.setShape(p, true, true, false); p.clear(); p.loadPathFromData(settingsIconPathData, sizeof(settingsIconPathData)); m_settingsButton.setShape(p, true, true, false); m_titleLabel.setText(titleText, NotificationType::dontSendNotification); addAndMakeVisible(m_titleLabel); addAndMakeVisible(m_homeButton); addAndMakeVisible(m_settingsButton); } SidePanelHeader::~SidePanelHeader() { } void SidePanelHeader::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background auto normal = getLookAndFeel().findColour(SidePanel::dismissButtonNormalColour); auto over = getLookAndFeel().findColour(SidePanel::dismissButtonOverColour); auto down = getLookAndFeel().findColour(SidePanel::dismissButtonDownColour); m_homeButton.setColours(normal, over, down); m_settingsButton.setColours(normal, over, down); } void SidePanelHeader::resized() { auto bounds = getLocalBounds(); bounds.removeFromLeft(10); m_homeButton.setBounds(bounds.removeFromLeft(m_homeButton.getWidth()+20).reduced(7)); m_settingsButton.setBounds(bounds.removeFromLeft(m_settingsButton.getWidth()+20).reduced(7)); bounds.removeFromLeft(10); bounds.removeFromRight(10); m_titleLabel.setBounds(bounds); } I copied the path data for home button and settings button from DemoRunner. This comes with Juce Framework. Everything else is straight forward. In the MainComponent, we set this header as the title bar component of side panel. // MainComponent.cpp #include \"MainComponent.h\" #include \"SidePanelHeader.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"\", 250, true, nullptr, false) // we don't need the title here anymore { //... auto sidePanelHeader = new SidePanelHeader(\"Side Panel\"); m_sidePanel.setTitleBarComponent(sidePanelHeader, true); } Notice that the object is dynamically created. After we set, the parent component takes the ownership. void setTitleBarComponent (Component* titleBarComponentToUse, bool keepDismissButton, bool deleteComponentWhenNoLongerNeeded = true); The last parameter decides whether the parent component needs to take care of the ownership or not. Now, let\u2019s add the side panel list. This is just a list box which contains a list and responds to row selection. // SidePanelList.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelList : public Component, public ListBoxModel { public: SidePanelList(); ~SidePanelList(); void paint (Graphics&) override; void resized() override; void paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) override; int getNumRows() override; void addEntry(const String& entry); void selectedRowsChanged(int row) override; private: ListBox m_entries; StringArray m_sidePanelEntries; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelList) }; // SidePanelList #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelList.h\" SidePanelList::SidePanelList() { setOpaque(true); addAndMakeVisible(m_entries); m_entries.setModel(this); m_entries.setRowHeight(40); } SidePanelList::~SidePanelList() { } void SidePanelList::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background } void SidePanelList::resized() { m_entries.setBounds(getLocalBounds()); } void SidePanelList::paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) { if (rowNumber < 0 || rowNumber >= getNumRows()) return; Rectangle<int> bounds(0, 0, width, height); auto textColour = findColour(Label::textColourId); g.setColour(textColour.withAlpha(0.4f)); if (rowNumber == 0) g.fillRect(bounds.removeFromTop(2).reduced(10, 0)); g.fillRect(bounds.removeFromBottom(2).reduced(10, 0)); if (rowIsSelected) { g.setColour(findColour(TextEditor::highlightColourId).withAlpha(0.4f)); g.fillRect(bounds); textColour = findColour(TextEditor::highlightedTextColourId); } g.setColour(textColour); g.drawFittedText(m_sidePanelEntries[rowNumber], bounds, Justification::centred, 1); } void SidePanelList::addEntry(const String& entry) { m_entries.deselectAllRows(); m_sidePanelEntries.add(entry); m_entries.updateContent(); } int SidePanelList::getNumRows() { return m_sidePanelEntries.size(); } void SidePanelList::selectedRowsChanged(int row) { if (row < 0) return; } We can integrate this list component with the side panel. // MainComponent.cpp MainComponent::MainComponent() { //..... auto sidePanelList = new SidePanelList; sidePanelList->addEntry(\"Entry 1\"); sidePanelList->addEntry(\"Entry 2\"); sidePanelList->addEntry(\"Entry 3\"); m_sidePanel.setContent(sidePanelList); } The setContent is like setTitleBarComponent , it takes the ownership. After attaching all click listeners, we can update the status. The source code is shared in the github. https://github.com/asit-dhal/Juce-SidePanel-Example","title":"Side Panel in JUCE"},{"location":"juce/side-panel-in-juce/#side-panel-in-juce","text":"This tutorial explains the side panel in JUCE GUI framework. Side Panel can be used for navigation if the application doesn\u2019t have a tool bar or menu bar. Usually, it stays on the left or right side of the application and triggered by the user. Juce has built-in support for side panel. Let\u2019s first make a skeleton app. The app will have a button to trigger side panel and a label to show the status. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: TextButton m_invokeSidePanel; Label m_sidePanelStatus; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\") { addAndMakeVisible(m_invokeSidePanel); addAndMakeVisible(m_sidePanelStatus); m_sidePanelStatus.setText(\"status\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); } void MainComponent::resized() { auto localBounds = getLocalBounds(); if (localBounds.getHeight() / 2 - 50 > 5) localBounds.removeFromTop(localBounds.getHeight() / 2 - 50); if (localBounds.getWidth() / 2 - 50 > 5) localBounds.removeFromLeft(localBounds.getWidth() / 2 - 50); auto buttonBound = localBounds.removeFromTop(30).removeFromRight(100); auto statusLabelBound = localBounds.removeFromTop(30).removeFromRight(100).reduced(5); m_invokeSidePanel.setBounds(buttonBound); m_sidePanelStatus.setBounds(statusLabelBound); } When user clicks the button, the side panel should appear. There is already a closed button on the side panel, the user can click on this to close the side panel. The side panel will have a list of entries. When the user selects any of those entries, the status label should show the text. Juce provides a built in component called Side Panel, https://docs.juce.com/master/classSidePanel.html","title":"Side Panel in JUCE"},{"location":"juce/side-panel-in-juce/#sidepanel-components","text":"SidePanel has two parts. header which can contain a label, a few buttons and a close button a list box which shows a list of entries Let\u2019s add a SidePanel component to the main component. The SidePanel should be shown when the user clicks on the sidePanel button in the main component. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, // step 2: override Button::Listener to get broadcast events from the button public Button::Listener { public: // ... // step 3: implement the button clicked callback void buttonClicked(Button*) override; private: // ... // step 1: add sidepanel SidePanel m_sidePanel; }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"Side Panel Demo\", 250, true, nullptr, false) { // .... addAndMakeVisible(m_sidePanel); // ... m_invokeSidePanel.addListener(this); } MainComponent::~MainComponent() { m_invokeSidePanel.removeListener(this); } void MainComponent::buttonClicked(Button* btn) { if (btn == &m_invokeSidePanel) { // step 4: show the side panel when the button is clicked m_sidePanel.showOrHide(true); } } Now, if you run this, you will a side Panel without any contents on this(there will be only title and a close button).","title":"Sidepanel Components"},{"location":"juce/side-panel-in-juce/#header-component","text":"Let\u2019s add the header component The header has two shape buttons(one for home and another for settings), a title and a close button. // SidePanelHeader.h #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelHeader : public Component { public: SidePanelHeader(const String& titleText); ~SidePanelHeader(); void paint (Graphics&) override; void resized() override; private: Label m_titleLabel; ShapeButton m_homeButton{ \"Home\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }, m_settingsButton{ \"Settings\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelHeader) }; ShapeButton has only one constructor, which takes three color ids, normal color(the colour to fill the shape with when the mouse isn\u2019t over), overColor(the colour to use when the mouse is over the shape) and downColour(the colour to use when the button is in the pressed-down state). In the beginning we will make everything transparent black and repaint with proper color in the paint() method. // SidePanelHeader.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelHeader.h\" SidePanelHeader::SidePanelHeader(const String& titleText) { setOpaque(true); static const unsigned char homeIconPathData[] = { 110,109,0,0,64,65,0,0,64,64,98,0,0,64,65,0,0,64,64,74,12,186,64,164,112,5,65,24,217,22,64,70,182, 51,65,98,35,219,9,64,240,167,54,65,0,0,0,64,170,241,58,65,0,0,0,64,0,0,64,65,98,0,0,0,64,22,217, 72,65,166,155,28,64,0,0,80,65,0,0,64,64,0,0,80,65,108,0,0,160,64,0,0,80,65,108,0,0,160,64,0,0, 160,65,98,0,0,160,64,139,108,164,65,211,77,174,64,0,0,168,65,0,0,192,64,0,0,168,65,108,0,0,16,65, 0,0,168,65,98,22,217,24,65,0,0,168,65,0,0,32,65,127,106,164,65,0,0,32,65,0,0,160,65,108,0,0,32,65,0,0,128, 65,108,0,0,96,65,0,0,128,65,108,0,0,96,65,0,0,160,65,98,0,0,96,65,127,106,164,65,233,38,103,65,0,0,168, 65,0,0,112,65,0,0,168,65,108,0,0,144,65,0,0,168,65,98,139,108,148,65,0,0,168,65,0,0,152,65,139,108,164, 65,0,0,152,65,0,0,160,65,108,0,0,152,65,0,0,80,65,108,0,0,168,65,0,0,80,65,98,139,108,172,65,0,0,80,65,0, 0,176,65,23,217,72,65,0,0,176,65,0,0,64,65,98,0,0,176,65,170,241,58,65,156,196,174,65,240,167,54,65,158,239, 172,65,70,182,51,65,98,213,120,145,65,164,112,5,65,0,0,64,65,0,0,64,64,0,0,64,65,0,0,64,64,99, 101,0,0 }; static const unsigned char settingsIconPathData[] = { 110,109,202,111,210,64,243,226,61,64,108,0,0,224,64,0,0,0,0,108,0,0,48,65,0,0,0,0,108,27,200,54,65,243, 226,61,64,98,91,248,63,65,174,170,76,64,95,130,72,65,231,138,96,64,46,46,80,65,180,163,120,64,108,42, 181,124,65,20,38,49,64,108,149,90,142,65,246,108,199,64,108,68,249,118,65,2,85,1,65,98,112,166,119,65, 201,31,6,65,0,0,120,65,111,5,11,65,0,0,120,65,0,0,16,65,98,0,0,120,65,145,250,20,65,108,166,119,65,55, 224,25,65,72,249,118,65,254,170,30,65,108,151,90,142,65,133,73,60,65,108,46,181,124,65,123,182,115,65, 108,50,46,80,65,18,215,97,65,98,99,130,72,65,70,221,103,65,96,248,63,65,83,213,108,65,32,200,54,65,66, 135,112,65,108,0,0,48,65,0,0,144,65,108,0,0,224,64,0,0,144,65,108,202,111,210,64,67,135,112,65,98,74, 15,192,64,84,213,108,65,65,251,174,64,70,221,103,65,164,163,159,64,19,215,97,65,108,92,43,13,64,123,182, 115,65,108,187,181,82,62,133,73,60,65,108,244,26,36,64,254,170,30,65,98,64,102,33,64,55,224,25,5,0,0,32, 64,145,250,20,65,0,0,32,64,0,0,16,65,98,0,0,32,64,111,5,11,65,64,102,33,64,201,31,6,65,244,26,36,64,2,85, 1,65,108,187,181,82,62,246,108,199,64,108,92,43,13,64,20,38,49,64,108,164,163,159,64,180,163,120,64,98,65, 251,174,64,231,138,96,64,74,15,192,64,175,170,76,64,202,111,210,64,243,226,61,64,99,109,0,0,16,65,0,0,64, 65,98,121,130,42,65,0,0,64,65,0,0,64,65,121,130,42,65,0,0,64,65,0,0,16,65,98,0,0,64,65,13,251,234,64,121, 130,42,65,0,0,192,64,0,0,16,65,0,0,192,64,98,13,251,234,64,0,0,192,64,0,0,192,64,13,251,234,64,0,0,192,64, 0,0,16,65,98,0,0,192,64,121,130,42,65,13,251,234,64,0,0,64,65,0,0,16,65,0,0,64,65,99,101,0,0 }; Path p; p.loadPathFromData(homeIconPathData, sizeof(homeIconPathData)); m_homeButton.setShape(p, true, true, false); p.clear(); p.loadPathFromData(settingsIconPathData, sizeof(settingsIconPathData)); m_settingsButton.setShape(p, true, true, false); m_titleLabel.setText(titleText, NotificationType::dontSendNotification); addAndMakeVisible(m_titleLabel); addAndMakeVisible(m_homeButton); addAndMakeVisible(m_settingsButton); } SidePanelHeader::~SidePanelHeader() { } void SidePanelHeader::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background auto normal = getLookAndFeel().findColour(SidePanel::dismissButtonNormalColour); auto over = getLookAndFeel().findColour(SidePanel::dismissButtonOverColour); auto down = getLookAndFeel().findColour(SidePanel::dismissButtonDownColour); m_homeButton.setColours(normal, over, down); m_settingsButton.setColours(normal, over, down); } void SidePanelHeader::resized() { auto bounds = getLocalBounds(); bounds.removeFromLeft(10); m_homeButton.setBounds(bounds.removeFromLeft(m_homeButton.getWidth()+20).reduced(7)); m_settingsButton.setBounds(bounds.removeFromLeft(m_settingsButton.getWidth()+20).reduced(7)); bounds.removeFromLeft(10); bounds.removeFromRight(10); m_titleLabel.setBounds(bounds); } I copied the path data for home button and settings button from DemoRunner. This comes with Juce Framework. Everything else is straight forward. In the MainComponent, we set this header as the title bar component of side panel. // MainComponent.cpp #include \"MainComponent.h\" #include \"SidePanelHeader.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"\", 250, true, nullptr, false) // we don't need the title here anymore { //... auto sidePanelHeader = new SidePanelHeader(\"Side Panel\"); m_sidePanel.setTitleBarComponent(sidePanelHeader, true); } Notice that the object is dynamically created. After we set, the parent component takes the ownership. void setTitleBarComponent (Component* titleBarComponentToUse, bool keepDismissButton, bool deleteComponentWhenNoLongerNeeded = true); The last parameter decides whether the parent component needs to take care of the ownership or not. Now, let\u2019s add the side panel list. This is just a list box which contains a list and responds to row selection. // SidePanelList.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelList : public Component, public ListBoxModel { public: SidePanelList(); ~SidePanelList(); void paint (Graphics&) override; void resized() override; void paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) override; int getNumRows() override; void addEntry(const String& entry); void selectedRowsChanged(int row) override; private: ListBox m_entries; StringArray m_sidePanelEntries; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelList) }; // SidePanelList #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelList.h\" SidePanelList::SidePanelList() { setOpaque(true); addAndMakeVisible(m_entries); m_entries.setModel(this); m_entries.setRowHeight(40); } SidePanelList::~SidePanelList() { } void SidePanelList::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background } void SidePanelList::resized() { m_entries.setBounds(getLocalBounds()); } void SidePanelList::paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) { if (rowNumber < 0 || rowNumber >= getNumRows()) return; Rectangle<int> bounds(0, 0, width, height); auto textColour = findColour(Label::textColourId); g.setColour(textColour.withAlpha(0.4f)); if (rowNumber == 0) g.fillRect(bounds.removeFromTop(2).reduced(10, 0)); g.fillRect(bounds.removeFromBottom(2).reduced(10, 0)); if (rowIsSelected) { g.setColour(findColour(TextEditor::highlightColourId).withAlpha(0.4f)); g.fillRect(bounds); textColour = findColour(TextEditor::highlightedTextColourId); } g.setColour(textColour); g.drawFittedText(m_sidePanelEntries[rowNumber], bounds, Justification::centred, 1); } void SidePanelList::addEntry(const String& entry) { m_entries.deselectAllRows(); m_sidePanelEntries.add(entry); m_entries.updateContent(); } int SidePanelList::getNumRows() { return m_sidePanelEntries.size(); } void SidePanelList::selectedRowsChanged(int row) { if (row < 0) return; } We can integrate this list component with the side panel. // MainComponent.cpp MainComponent::MainComponent() { //..... auto sidePanelList = new SidePanelList; sidePanelList->addEntry(\"Entry 1\"); sidePanelList->addEntry(\"Entry 2\"); sidePanelList->addEntry(\"Entry 3\"); m_sidePanel.setContent(sidePanelList); } The setContent is like setTitleBarComponent , it takes the ownership. After attaching all click listeners, we can update the status. The source code is shared in the github. https://github.com/asit-dhal/Juce-SidePanel-Example","title":"Header Component"}]}