{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Me Hi ! I am Asit Dhal. I am a software engineer by profession, I work in C++14, OpenGL and Qt. I try to write simple and elegant code. I also know a little bit about Golang and Rust, have worked in Python and PyQt. Contact Me Github Mail me","title":"Home"},{"location":"#about-me","text":"Hi ! I am Asit Dhal. I am a software engineer by profession, I work in C++14, OpenGL and Qt. I try to write simple and elegant code. I also know a little bit about Golang and Rust, have worked in Python and PyQt.","title":"About Me"},{"location":"#contact-me","text":"Github Mail me","title":"Contact Me"},{"location":"cpp/string-conversion-benchmark/","text":"string conversion benchmark in C++ There are three ways to convert any fundamental data to string. std::to_string std::ostringstream boost::lexical_cast template <typename T> std::string stringify_ostringstream(T val) { std::ostringstream ss; ss << val; return ss.str(); } std::ostringstream g_buffer; template <typename T> std::string stringify_ostringstream_reuse(T val) { g_buffer.str(\"\"); g_buffer.clear(); g_buffer << val; return g_buffer.str(); } template <typename T> std::string stringify_tostring(T val) { return std::to_string(val); } In this post, I will analyze which one is the fastest to convert any fundamental(int, double, boolean) data to string. I am using google benchmark to measure the time difference. In all charts, y-axis is time in nano seconds. type=int input_count = 1 For only, one conversion, both std::stringstream and std::ostringstream take nearly same time. boost::lexical_cast in the fastest. And std::to_string is faster than stringstream and slower than boost::lexical_cast. boost::lexical_cast is not the best way for string conversion, because it throws an exception in case of failure. type=int input_count > 30 Here both std::stringstream and std::ostringstream outperform std::to_string and boost::lexical_cast. You can get better result by reusing std::stringstream and std::ostringstream buffer. std::ostringstream oss; oss.str(\u201c\u201d); oss.clear(); Creating stream objects are very expensive. So, reuse of buffer gives better result. type=double input_count=1 Performance is very similar to integer. Boost lexical_cast outperforms std::to_string and stringstream. type=double input_count=30 For multiple inputs, boost::lexical_cast outperforms everyone else. So, my observations are Always use std::to_string to convert any single value to std::string. In case of double, use std::string. If you need, precision, use std::ostringstream. In all other cases, use std::ostringstream. Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"string conversion benchmark in C++"},{"location":"cpp/string-conversion-benchmark/#string-conversion-benchmark-in-c","text":"There are three ways to convert any fundamental data to string. std::to_string std::ostringstream boost::lexical_cast template <typename T> std::string stringify_ostringstream(T val) { std::ostringstream ss; ss << val; return ss.str(); } std::ostringstream g_buffer; template <typename T> std::string stringify_ostringstream_reuse(T val) { g_buffer.str(\"\"); g_buffer.clear(); g_buffer << val; return g_buffer.str(); } template <typename T> std::string stringify_tostring(T val) { return std::to_string(val); } In this post, I will analyze which one is the fastest to convert any fundamental(int, double, boolean) data to string. I am using google benchmark to measure the time difference. In all charts, y-axis is time in nano seconds.","title":"string conversion benchmark in C++"},{"location":"cpp/string-conversion-benchmark/#typeint-input_count-1","text":"For only, one conversion, both std::stringstream and std::ostringstream take nearly same time. boost::lexical_cast in the fastest. And std::to_string is faster than stringstream and slower than boost::lexical_cast. boost::lexical_cast is not the best way for string conversion, because it throws an exception in case of failure.","title":"type=int input_count = 1"},{"location":"cpp/string-conversion-benchmark/#typeint-input_count-30","text":"Here both std::stringstream and std::ostringstream outperform std::to_string and boost::lexical_cast. You can get better result by reusing std::stringstream and std::ostringstream buffer. std::ostringstream oss; oss.str(\u201c\u201d); oss.clear(); Creating stream objects are very expensive. So, reuse of buffer gives better result.","title":"type=int input_count &gt; 30"},{"location":"cpp/string-conversion-benchmark/#typedouble-input_count1","text":"Performance is very similar to integer. Boost lexical_cast outperforms std::to_string and stringstream.","title":"type=double input_count=1"},{"location":"cpp/string-conversion-benchmark/#typedouble-input_count30","text":"For multiple inputs, boost::lexical_cast outperforms everyone else. So, my observations are Always use std::to_string to convert any single value to std::string. In case of double, use std::string. If you need, precision, use std::ostringstream. In all other cases, use std::ostringstream. Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"type=double input_count=30"},{"location":"git/delete-old-branches-in-git/","text":"Sometimes there are many branches, accumulated over the years in a git repository. And you need to delete it to save some space or make management of your repository easy. To get the list of all local branches \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git branch ci-build-script dev * master remotes/origin/add-license-1 remotes/origin/benchmark After that, you can iterate over all local branches and get some technical details like branch creation date(age of the branch), last commit date, last commit message etc. I will try to delete ci-build-script. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git merge-base ci-build-script master e3b47d97284b911baa266853b208f5ea25115e67 git merge-base tries to find out a good common ancestor. This can be assumed to return the earliest commit id where branch deviates from master branch. You can use the commit id of the common ancestor to get creation date and the age of the branch. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%ad\u201d \u2014 date=short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 2017\u201309\u201325 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%cr\u201d \u2014 date=short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 6 months ago Similarly, you can use the branch name to get the latest commit date, age of last commit and the subject line of last commit message. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%ad\u201d \u2014 date=short -n 1 ci-build-script 2017\u201309\u201326 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty=format:\u201d%cr\u201d \u2014 date=short -n 1 ci-build-script 5 months ago \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log --pretty=format:\"%s\" -n 1 ci-build-script gcc tnd clang config for travis From that you can make an intelligent guess, should you delete the branch or not. The branch ci-build-script was created 5 months ago and last committed 5 months ago. The commit message was \u201cgcc and clang config for travis\u201d. You can delete it git branch -d ci-build-script -d option won\u2019t allow you delete unless it is merged. In some cases branch were never merged. So, you can use -D option You can wrap all the above and make a script. #!/bin/bash # # Copyright(c) 2018 Asit Dhal. # Distributed under the MIT License (http://opensource.org/licenses/MIT) # LIGHT_BLUE='\\033[1;34m' RED='\\033[0;31m' NC='\\033[0m' # No Color INTERACTIVE=\"\" FORCE_DELETE=\"\" MASTER=\"master\" while [[ $# -gt 0 ]] do key=\"$1\" case $key in -f) FORCE_DELETE=\"y\" shift ;; -i) INTERACTIVE=\"i\" shift ;; -fi|-if) INTERACTIVE=\"i\" FORCE_DELETE=\"y\" shift ;; -h) echo \"$(basename $0) -i Intecative deletion of local branches\" echo \"$(basename $0) -f Force delete the branch(es)\" echo \"$(basename $0) List local branches with creation and last update date\" exit ;; *) shift esac done current_branch=$(git branch | grep \"*\") current_branch=${current_branch/* /} if [ \"${current_branch}\" != \"${MASTER}\" ]; then printf \"Please change the current branch to ${LIGHT_BLUE}${MASTER}${NC}\\n\" exit fi if ! git diff-files --quiet; then printf \"you have unstaged changes. $(basename $0) needs a clean working index\\n\" git diff-files --name-status printf \"Please commit or stash them.\\n\" exit fi if ! git diff-index --cached --quiet HEAD; then printf \"your index contains uncommitted changes. $(basename $0) needs a clean working index\\n\" git diff-index --cached --name-status HEAD printf \"Please commit or stash them.\\n\" exit fi for brnch in $(git branch | sed /\\*/d); do created_commit_id=$(git merge-base ${brnch} ${MASTER}) created_date=$(git log --pretty=format:\"%ad\" --date=short -n 1 ${created_commit_id}) created_ago=$(git log --pretty=format:\"%cr\" --date=short -n 1 ${created_commit_id}) last_updated_date=$(git log --pretty=format:\"%ad\" --date=short -n 1 ${brnch}) updated_before=$(git log --pretty=format:\"%cr\" --date=short -n 1 ${brnch}) commit_message_subject=$(git log --pretty=format:'%s' -n 1 ${brnch}) printf \"Branch name : ${brnch} \\n\" printf \"Created on : ${created_date}${RED}(${created_ago})${NC}\\n\" printf \"Last updated on : ${last_updated_date}${RED}(${updated_before}${NC})\\n\" printf \"Last commit message : ${commit_message_subject}\\n\" if [ \"${INTERACTIVE}\" == \"i\" ]; then printf \"${LIGHT_BLUE}Delete the branch, followed by [y/n]?${NC} \" read ip if [ \"$ip\" == \"y\" ]; then if [ \"${FORCE_DELETE}\" == \"y\" ]; then git branch -D ${brnch} else git branch -d ${brnch} if [ $? -ne 0 ]; then printf \"${LIGHT_BLUE}Run with -fi command to delete ${brnch}${NC}\\n\" fi fi fi fi done The script has 2 options: -i and -f-. If the run the script without any options, it will give you list of all local branches and the above information. \u2570\u2500$ git-clean-local-branches Branch name : ci-build-script Created on : 2017\u201309\u201325(6 months ago) Last updated on : 2017\u201309\u201326(5 months ago) Last commit message : gcc tnd clang config for travis Branch name : dev Created on : 2017\u201310\u201314(5 months ago) Last updated on : 2017\u201311\u201325(4 months ago) Last commit message : stringify improvement, size and type name removal Branch name : remotes/origin/add-license-1 Created on : 2017\u201310\u201314(5 months ago) Last updated on : 2017\u201310\u201314(5 months ago) Last commit message : Create LICENSE Branch name : remotes/origin/benchmark Created on : 2017\u201310\u201306(5 months ago) Last updated on : 2017\u201310\u201316(5 months ago) Last commit message : cxx-pretty print integration -i option allows you interactive deletion. -f option uses git delete -D(force delete). \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git-clean-local-branches -fi Branch name : ci-build-script Created on : 2017\u201309\u201325(6 months ago) Last updated on : 2017\u201309\u201326(5 months ago) Last commit message : gcc tnd clang config for travis Delete the branch, followed by [y/n]? y Deleted branch ci-build-script (was 2cb728c). Branch name : dev Created on : 2017\u201310\u201314(5 months ago) Last updated on : 2017\u201311\u201325(4 months ago) Last commit message : stringify improvement, size and type name removal Delete the branch, followed by [y/n]? y Deleted branch dev (was f8698b4). Thanks for reading.","title":"Delete old branches in Git"},{"location":"golang/golang-slice-and-append/","text":"Golang slice and append In Golang, a slice is a reference to a contiguous segment of an array. Slice is basically a pointer, with additional properties about the array. A slice is a structure of 3 fields. a pointer to the underlying array length of the slice capacity of the slice You can see this in slice.go, here https://github.com/golang/go/blob/master/src/runtime/slice.go // slice1.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:3] var slice2 []int = arr1[2:] fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) arr1[2] = 35 fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) } Output array: [10 20 30 40 50] len: 5 slice1: [20 30] len: 2 cap: 4 slice2: [30 40 50] len: 3 cap: 3 array: [10 20 35 40 50] len: 5 slice1: [20 35] len: 2 cap: 4 slice2: [35 40 50] len: 3 cap: 3 Both the slices point to the same memory, any changes to the actual data will impact all the slices pointing to the array. So, if you have an array and many slices pointing to the same array, there can be many places where the array can be changed. So, this is a disaster going to happen. You should avoid exposing the array and always keep it anonymous. Golang provides make() to achieve this objective. make() allows us to create a slice when the underlying array is not defined. slice1 := make([]type, len) //case 1 slice2 := make([]type, len, cap) // case 2 In the first case, the slice is pointing to an array of length \u2018len\u2019. Here, the following statement is true cap(slice1) = len(slice1) = len In the second case, slice2 doesn\u2019t occupy the entire underlying array. The array has a length \u2018cap\u2019 and slice has length \u2018len\u2019. There is space for reslicing. Reslicing Changing the length of the slice is called reslicing. It is done by increasing the end index of the slice, until it occupies the entire array. Increase the slice length by 1 s = s[0:len(s)+1] Slice length can be reached upto the capacity. If the length crosses the capacity, it will panic at run time. The capacity is a limitation in reslicing. So, golang provides an built-in function append() to fix this issue. The built-in append() does the following append() appends zero or more values to a slice and returns the resulting slice. allocates a new, sufficiently large slice always succeeds, unless the computer runs out of memory append() may either modify its argument in-place or return a copy of its argument with an additional entry, depending on the size and capacity of its input. append() function creates a new slice, if the length the slice is greater than the length of the array pointed by the slice. // append.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:4] fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //modify the underlying array slice1 = append(slice1, 56) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //creates a new array and returns slice pointing to it slice1 = append(slice1, 69) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) } Output array: [10 20 30 40 50] slice1: [20 30 40] array: [10 20 30 40 56] slice1: [20 30 40 56] array: [10 20 30 40 56] slice1: [20 30 40 56 69] In the first append(), the argument is modified and in the 2nd append(), a new slice is created.","title":"Golang slice and append"},{"location":"golang/golang-slice-and-append/#golang-slice-and-append","text":"In Golang, a slice is a reference to a contiguous segment of an array. Slice is basically a pointer, with additional properties about the array. A slice is a structure of 3 fields. a pointer to the underlying array length of the slice capacity of the slice You can see this in slice.go, here https://github.com/golang/go/blob/master/src/runtime/slice.go // slice1.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:3] var slice2 []int = arr1[2:] fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) arr1[2] = 35 fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) } Output array: [10 20 30 40 50] len: 5 slice1: [20 30] len: 2 cap: 4 slice2: [30 40 50] len: 3 cap: 3 array: [10 20 35 40 50] len: 5 slice1: [20 35] len: 2 cap: 4 slice2: [35 40 50] len: 3 cap: 3 Both the slices point to the same memory, any changes to the actual data will impact all the slices pointing to the array. So, if you have an array and many slices pointing to the same array, there can be many places where the array can be changed. So, this is a disaster going to happen. You should avoid exposing the array and always keep it anonymous. Golang provides make() to achieve this objective. make() allows us to create a slice when the underlying array is not defined. slice1 := make([]type, len) //case 1 slice2 := make([]type, len, cap) // case 2 In the first case, the slice is pointing to an array of length \u2018len\u2019. Here, the following statement is true cap(slice1) = len(slice1) = len In the second case, slice2 doesn\u2019t occupy the entire underlying array. The array has a length \u2018cap\u2019 and slice has length \u2018len\u2019. There is space for reslicing.","title":"Golang slice and append"},{"location":"golang/golang-slice-and-append/#reslicing","text":"Changing the length of the slice is called reslicing. It is done by increasing the end index of the slice, until it occupies the entire array. Increase the slice length by 1 s = s[0:len(s)+1] Slice length can be reached upto the capacity. If the length crosses the capacity, it will panic at run time. The capacity is a limitation in reslicing. So, golang provides an built-in function append() to fix this issue. The built-in append() does the following append() appends zero or more values to a slice and returns the resulting slice. allocates a new, sufficiently large slice always succeeds, unless the computer runs out of memory append() may either modify its argument in-place or return a copy of its argument with an additional entry, depending on the size and capacity of its input. append() function creates a new slice, if the length the slice is greater than the length of the array pointed by the slice. // append.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:4] fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //modify the underlying array slice1 = append(slice1, 56) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //creates a new array and returns slice pointing to it slice1 = append(slice1, 69) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) } Output array: [10 20 30 40 50] slice1: [20 30 40] array: [10 20 30 40 56] slice1: [20 30 40 56] array: [10 20 30 40 56] slice1: [20 30 40 56 69] In the first append(), the argument is modified and in the 2nd append(), a new slice is created.","title":"Reslicing"},{"location":"golang/golang-templates-1-introduction/","text":"Golang Templates-1: Introduction A template engine is a software application which generates dynamic HTML. This can be assumed as the view of the MVC paradigm. But, in reality, the template is exactly not view, a little bit of controller logic is added to make not too rigid. In Golang, the handler(controller) calls the template engine, passing it the template(s) to be used, usually as a list of template files and the dynamic data. The template engine then generates the HTML and writes it to the ResponseWriter, which adds it to the HTTP response sends back to the client. A template is a string or file containing one or more portions enclosed in double braces, {{\u2026}} , called actions. These actions are processed by the template engine to produce dynamic HTML. Steps to produce HTML from template file Parse the template string/file to create a parsed template struct. Execute the parsed template, passing a ResponseWriter and some data to it. // main.go package main import ( \"net/http\" \"html/template\" ) func handler(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"view.html\") //setp 1 t.Execute(w, \"Hello World!\") //step 2 } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } <!-- view.html--> <html> <head> <title>First Program</title> </head> <body> {{ . }} </body> </html> Template Names All templates are associated with a name. Template name are defined using template.New(). In case of ParseFiles() and ParseGlob(), the first file in the argument list and the first file picked up are the names respectively. https://golang.org/pkg/html/template/#New Templates can be looked up by using the name(template.Lookup()). https://golang.org/pkg/html/template/#Template.Lookup . Template name can be queried(template.Name()) https://golang.org/pkg/html/template/#Template.Name . Parsing Templates template.Parse() method takes a string and returns a parsed structured template. // main2.go package main import ( \"html/template\" \"net/http\" ) var tmpl = `<html> <head> <title>Hello World!</title> </head> <body> {{ . }} </body> </html> ` func handler(w http.ResponseWriter, r *http.Request) { t := template.New(\"main\") //name of the template is main t, _ = t.Parse(tmpl) // parsing of template string t.Execute(w, \"Hello World!\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } template.ParseFiles() is a variadic function call. It takes variable number arguments. template.ParseGlob() uses pattern matching. Both of the above functions return a set of parsed templates. The returned template name will be the first file in PraseFiles() and the first file matched in the regular expression in ParseGlob(). https://golang.org/pkg/text/template/#ParseFiles // main3.go package main import ( \"net/http\" \"html/template\" ) func handler1(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.Execute(w, \"Asit\") } func handler2(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.ExecuteTemplate(w, \"t2.html\", \"Golang\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/t1\", handler1) http.HandleFunc(\"/t2\", handler2) server.ListenAndServe() } <!-- t1.html--> <html> <head> <title>T1 template</title> </head> <body> Hi, My name is {{ . }}. </body> </html> <!-- t2.html--> <html> <head> <title>T2 template</title> </head> <body> Hi, I am learning {{ . }}. </body> </html> Executing Templates The template.Execute() method applies a parsed template to the specified data object and writes the output to an output writer.The template.ExecuteTemplate() method works if the template contains multiple parsed template object. This is shown in the previous example. template.ExecuteTemplate() calls template.Execute() internally. It basically looks for the named template and executes that one. In Golang library, you can see the implementation . Error Handling All three parse methods returns error in case of failure. The standard library provides template.Must(), which wraps around a function that returns a pointer to a template and an error, and panics if the error is not a nil. t := template.Must(template.ParseFiles(\"tmpl.html\")) While Executing, both the methods may fail and return error. But, by that time, some data might have been written to the buffer and sent back to browser. The programmer should handle this situation.","title":"Golang Templates-1 Introduction"},{"location":"golang/golang-templates-1-introduction/#golang-templates-1-introduction","text":"A template engine is a software application which generates dynamic HTML. This can be assumed as the view of the MVC paradigm. But, in reality, the template is exactly not view, a little bit of controller logic is added to make not too rigid. In Golang, the handler(controller) calls the template engine, passing it the template(s) to be used, usually as a list of template files and the dynamic data. The template engine then generates the HTML and writes it to the ResponseWriter, which adds it to the HTTP response sends back to the client. A template is a string or file containing one or more portions enclosed in double braces, {{\u2026}} , called actions. These actions are processed by the template engine to produce dynamic HTML.","title":"Golang Templates-1: Introduction"},{"location":"golang/golang-templates-1-introduction/#steps-to-produce-html-from-template-file","text":"Parse the template string/file to create a parsed template struct. Execute the parsed template, passing a ResponseWriter and some data to it. // main.go package main import ( \"net/http\" \"html/template\" ) func handler(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"view.html\") //setp 1 t.Execute(w, \"Hello World!\") //step 2 } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } <!-- view.html--> <html> <head> <title>First Program</title> </head> <body> {{ . }} </body> </html>","title":"Steps to produce HTML from template file"},{"location":"golang/golang-templates-1-introduction/#template-names","text":"All templates are associated with a name. Template name are defined using template.New(). In case of ParseFiles() and ParseGlob(), the first file in the argument list and the first file picked up are the names respectively. https://golang.org/pkg/html/template/#New Templates can be looked up by using the name(template.Lookup()). https://golang.org/pkg/html/template/#Template.Lookup . Template name can be queried(template.Name()) https://golang.org/pkg/html/template/#Template.Name .","title":"Template Names"},{"location":"golang/golang-templates-1-introduction/#parsing-templates","text":"template.Parse() method takes a string and returns a parsed structured template. // main2.go package main import ( \"html/template\" \"net/http\" ) var tmpl = `<html> <head> <title>Hello World!</title> </head> <body> {{ . }} </body> </html> ` func handler(w http.ResponseWriter, r *http.Request) { t := template.New(\"main\") //name of the template is main t, _ = t.Parse(tmpl) // parsing of template string t.Execute(w, \"Hello World!\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } template.ParseFiles() is a variadic function call. It takes variable number arguments. template.ParseGlob() uses pattern matching. Both of the above functions return a set of parsed templates. The returned template name will be the first file in PraseFiles() and the first file matched in the regular expression in ParseGlob(). https://golang.org/pkg/text/template/#ParseFiles // main3.go package main import ( \"net/http\" \"html/template\" ) func handler1(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.Execute(w, \"Asit\") } func handler2(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.ExecuteTemplate(w, \"t2.html\", \"Golang\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/t1\", handler1) http.HandleFunc(\"/t2\", handler2) server.ListenAndServe() } <!-- t1.html--> <html> <head> <title>T1 template</title> </head> <body> Hi, My name is {{ . }}. </body> </html> <!-- t2.html--> <html> <head> <title>T2 template</title> </head> <body> Hi, I am learning {{ . }}. </body> </html>","title":"Parsing Templates"},{"location":"golang/golang-templates-1-introduction/#executing-templates","text":"The template.Execute() method applies a parsed template to the specified data object and writes the output to an output writer.The template.ExecuteTemplate() method works if the template contains multiple parsed template object. This is shown in the previous example. template.ExecuteTemplate() calls template.Execute() internally. It basically looks for the named template and executes that one. In Golang library, you can see the implementation .","title":"Executing Templates"},{"location":"golang/golang-templates-1-introduction/#error-handling","text":"All three parse methods returns error in case of failure. The standard library provides template.Must(), which wraps around a function that returns a pointer to a template and an error, and panics if the error is not a nil. t := template.Must(template.ParseFiles(\"tmpl.html\")) While Executing, both the methods may fail and return error. But, by that time, some data might have been written to the buffer and sent back to browser. The programmer should handle this situation.","title":"Error Handling"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/","text":"Golang Template-2: Template composition Golang template library provides certain actions to make an efficient and flexible use of multiple template files. define action {{define \"templ_name\"}}second template{{end}} Here, a template with name \u201ctempl_name\u201d is defined. // defineActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var defineDemo = ` {{ define \"a\" }} Template A {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"defineActionDemo\") t, err = t.Parse(defineDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } fmt.Println() err = t.ExecuteTemplate(os.Stdout, \"b\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } c:\\medium\\src>go build defineActionDemo.go c:\\medium\\src>defineActionDemo Template A Template B If there multiple definitions of same template, except one, all other should be empty. template action {{template \"templ_name\" }} {{template \"templ_name\" pipeline}} Here, the template with name \u201ctempl_name\u201d will be executed and output will be rendered at the same place. Output Template A includes Template B Template B Template A ends // templateActionDemo.go package main import ( \"html/template\" \"os\" \"fmt\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ template \"b\" .}} Template A ends {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } block action Block action is defining a template and executing in place. {{block \"name\" pipeline}} huuw {{end}} // blockActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ block \"b\" .}} Template B {{ end }} Template A ends {{ end }} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } Output Template A includes Template B Template B Template A ends All these three actions are very powerful. Template composition(nested template or template embedding or template inheritance) can be achieved. Empty template can be used as placeholder templates. How to organize template files ? We keep our template files in two directories. One is the layout and other is the application specific views. The layout will contain base template and other common templates. base.tmpl will contain the skeleton of HTML page for the entire website. <!-- base.tmpl --> {{ define \"base\" }} <html> <head> <title>{{block \"title\" .}} {{end}}</title> {{block \"style\" .}} {{end}} </head> <body> <body> {{template \"content\" .}} </body> <footer>{{block \"footer\" .}} {{end}}</footer> {{block \"js\" .}} {{end}} </body> </html> {{ end }} <!-- js.tmpl --> {{ define \"js\" }} <script type=\"javascript\"> console.log(\"a small js\"); </script> {{ end }} <!-- style.tmpl --> {{define \"style\"}} <style> body { background-color: lightblue; } h1 { color: navy; margin-left: 20px; } </style> {{end}} Now, all other templates which is a view to user. Each of these will be rendered individually. <!-- aboutme.tmpl --> {{define \"title\"}}About Me{{end}} {{define \"content\"}} <h2>This is About me page.</h2> <ul> <li>My name is {{ .Name }}. </li> <li>My home city is {{ .City }}. </li> <li>My nationaliy is {{ .Nationality }}. </li> </ul> <p><a href=\"/\">Home</a></p> {{end}} <!-- index.tmpl --> {{define \"title\"}}Home{{end}} {{define \"content\"}} <ul> <li><a href=\"/skillset\">Skillset</a></li> <li><a href=\"/aboutme\">About Me</a></li> </ul> {{end}} <!-- skillset.tmpl --> {{define \"title\"}}Skillset{{end}} {{define \"content\"}} <h3>My Skillset</h3> <table class=\"table\"> <thead> <tr> <th>Language</th> <th>Level</th> </tr> </thead> <tbody> {{ range . }} <tr> <td>{{ .Language }}</td> <td>{{ .Level }}</td> </tr> {{ end }} </tbody> </table> <p> <a href=\"/\">Home</a></p> {{end}} In Go, we need to do the following. //golang package main import ( \"fmt\" \"github.com/oxtoacart/bpool\" \"html/template\" \"log\" \"net/http\" \"path/filepath\" ) var templates map[string]*template.Template var bufpool *bpool.BufferPool type UserData struct { Name string City string Nationality string } type SkillSet struct { Language string Level string } type TemplateConfig struct { TemplateLayoutPath string TemplateIncludePath string } type SkillSets []*SkillSet var mainTmpl = `{{define \"main\" }} {{ template \"base\" . }} {{ end }}` var templateConfig TemplateConfig func loadConfiguration() { templateConfig.TemplateLayoutPath = \"templates/layouts/\" templateConfig.TemplateIncludePath = \"templates/\" } func loadTemplates() { if templates == nil { templates = make(map[string]*template.Template) } layoutFiles, err := filepath.Glob(templateConfig.TemplateLayoutPath + \"*.tmpl\") if err != nil { log.Fatal(err) } includeFiles, err := filepath.Glob(templateConfig.TemplateIncludePath + \"*.tmpl\") if err != nil { log.Fatal(err) } mainTemplate := template.New(\"main\") mainTemplate, err = mainTemplate.Parse(mainTmpl) if err != nil { log.Fatal(err) } for _, file := range includeFiles { fileName := filepath.Base(file) files := append(layoutFiles, file) templates[fileName], err = mainTemplate.Clone() if err != nil { log.Fatal(err) } templates[fileName] = template.Must(templates[fileName].ParseFiles(files...)) } log.Println(\"templates loading successful\") bufpool = bpool.NewBufferPool(64) log.Println(\"buffer allocation successful\") } func renderTemplate(w http.ResponseWriter, name string, data interface{}) { tmpl, ok := templates[name] if !ok { http.Error(w, fmt.Sprintf(\"The template %s does not exist.\", name), http.StatusInternalServerError) } buf := bufpool.Get() defer bufpool.Put(buf) err := tmpl.Execute(buf, data) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\") buf.WriteTo(w) } func index(w http.ResponseWriter, r *http.Request) { renderTemplate(w, \"index.tmpl\", nil) } func aboutMe(w http.ResponseWriter, r *http.Request) { userData := &UserData{Name: \"Asit Dhal\", City: \"Bhubaneswar\", Nationality: \"Indian\"} renderTemplate(w, \"aboutme.tmpl\", userData) } func skillSet(w http.ResponseWriter, r *http.Request) { skillSets := SkillSets{&SkillSet{Language: \"Golang\", Level: \"Beginner\"}, &SkillSet{Language: \"C++\", Level: \"Advanced\"}, &SkillSet{Language: \"Python\", Level: \"Advanced\"}} renderTemplate(w, \"skillset.tmpl\", skillSets) } func main() { loadConfiguration() loadTemplates() server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/\", index) http.HandleFunc(\"/aboutme\", aboutMe) http.HandleFunc(\"/skillset\", skillSet) server.ListenAndServe() } Before the application starts to listen for HTTP request, all template files are loaded. Every time there is a request, the specific template is executed. Working example: https://github.com/asit-dhal/golang-template-layout . Thanks for reading !!","title":"Golang Template-2 Template composition"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#golang-template-2-template-composition","text":"Golang template library provides certain actions to make an efficient and flexible use of multiple template files. define action {{define \"templ_name\"}}second template{{end}} Here, a template with name \u201ctempl_name\u201d is defined. // defineActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var defineDemo = ` {{ define \"a\" }} Template A {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"defineActionDemo\") t, err = t.Parse(defineDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } fmt.Println() err = t.ExecuteTemplate(os.Stdout, \"b\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } c:\\medium\\src>go build defineActionDemo.go c:\\medium\\src>defineActionDemo Template A Template B If there multiple definitions of same template, except one, all other should be empty.","title":"Golang Template-2: Template composition"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#template-action","text":"{{template \"templ_name\" }} {{template \"templ_name\" pipeline}} Here, the template with name \u201ctempl_name\u201d will be executed and output will be rendered at the same place. Output Template A includes Template B Template B Template A ends // templateActionDemo.go package main import ( \"html/template\" \"os\" \"fmt\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ template \"b\" .}} Template A ends {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } }","title":"template action"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#block-action","text":"Block action is defining a template and executing in place. {{block \"name\" pipeline}} huuw {{end}} // blockActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ block \"b\" .}} Template B {{ end }} Template A ends {{ end }} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } Output Template A includes Template B Template B Template A ends All these three actions are very powerful. Template composition(nested template or template embedding or template inheritance) can be achieved. Empty template can be used as placeholder templates.","title":"block action"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#how-to-organize-template-files","text":"We keep our template files in two directories. One is the layout and other is the application specific views. The layout will contain base template and other common templates. base.tmpl will contain the skeleton of HTML page for the entire website. <!-- base.tmpl --> {{ define \"base\" }} <html> <head> <title>{{block \"title\" .}} {{end}}</title> {{block \"style\" .}} {{end}} </head> <body> <body> {{template \"content\" .}} </body> <footer>{{block \"footer\" .}} {{end}}</footer> {{block \"js\" .}} {{end}} </body> </html> {{ end }} <!-- js.tmpl --> {{ define \"js\" }} <script type=\"javascript\"> console.log(\"a small js\"); </script> {{ end }} <!-- style.tmpl --> {{define \"style\"}} <style> body { background-color: lightblue; } h1 { color: navy; margin-left: 20px; } </style> {{end}} Now, all other templates which is a view to user. Each of these will be rendered individually. <!-- aboutme.tmpl --> {{define \"title\"}}About Me{{end}} {{define \"content\"}} <h2>This is About me page.</h2> <ul> <li>My name is {{ .Name }}. </li> <li>My home city is {{ .City }}. </li> <li>My nationaliy is {{ .Nationality }}. </li> </ul> <p><a href=\"/\">Home</a></p> {{end}} <!-- index.tmpl --> {{define \"title\"}}Home{{end}} {{define \"content\"}} <ul> <li><a href=\"/skillset\">Skillset</a></li> <li><a href=\"/aboutme\">About Me</a></li> </ul> {{end}} <!-- skillset.tmpl --> {{define \"title\"}}Skillset{{end}} {{define \"content\"}} <h3>My Skillset</h3> <table class=\"table\"> <thead> <tr> <th>Language</th> <th>Level</th> </tr> </thead> <tbody> {{ range . }} <tr> <td>{{ .Language }}</td> <td>{{ .Level }}</td> </tr> {{ end }} </tbody> </table> <p> <a href=\"/\">Home</a></p> {{end}} In Go, we need to do the following. //golang package main import ( \"fmt\" \"github.com/oxtoacart/bpool\" \"html/template\" \"log\" \"net/http\" \"path/filepath\" ) var templates map[string]*template.Template var bufpool *bpool.BufferPool type UserData struct { Name string City string Nationality string } type SkillSet struct { Language string Level string } type TemplateConfig struct { TemplateLayoutPath string TemplateIncludePath string } type SkillSets []*SkillSet var mainTmpl = `{{define \"main\" }} {{ template \"base\" . }} {{ end }}` var templateConfig TemplateConfig func loadConfiguration() { templateConfig.TemplateLayoutPath = \"templates/layouts/\" templateConfig.TemplateIncludePath = \"templates/\" } func loadTemplates() { if templates == nil { templates = make(map[string]*template.Template) } layoutFiles, err := filepath.Glob(templateConfig.TemplateLayoutPath + \"*.tmpl\") if err != nil { log.Fatal(err) } includeFiles, err := filepath.Glob(templateConfig.TemplateIncludePath + \"*.tmpl\") if err != nil { log.Fatal(err) } mainTemplate := template.New(\"main\") mainTemplate, err = mainTemplate.Parse(mainTmpl) if err != nil { log.Fatal(err) } for _, file := range includeFiles { fileName := filepath.Base(file) files := append(layoutFiles, file) templates[fileName], err = mainTemplate.Clone() if err != nil { log.Fatal(err) } templates[fileName] = template.Must(templates[fileName].ParseFiles(files...)) } log.Println(\"templates loading successful\") bufpool = bpool.NewBufferPool(64) log.Println(\"buffer allocation successful\") } func renderTemplate(w http.ResponseWriter, name string, data interface{}) { tmpl, ok := templates[name] if !ok { http.Error(w, fmt.Sprintf(\"The template %s does not exist.\", name), http.StatusInternalServerError) } buf := bufpool.Get() defer bufpool.Put(buf) err := tmpl.Execute(buf, data) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\") buf.WriteTo(w) } func index(w http.ResponseWriter, r *http.Request) { renderTemplate(w, \"index.tmpl\", nil) } func aboutMe(w http.ResponseWriter, r *http.Request) { userData := &UserData{Name: \"Asit Dhal\", City: \"Bhubaneswar\", Nationality: \"Indian\"} renderTemplate(w, \"aboutme.tmpl\", userData) } func skillSet(w http.ResponseWriter, r *http.Request) { skillSets := SkillSets{&SkillSet{Language: \"Golang\", Level: \"Beginner\"}, &SkillSet{Language: \"C++\", Level: \"Advanced\"}, &SkillSet{Language: \"Python\", Level: \"Advanced\"}} renderTemplate(w, \"skillset.tmpl\", skillSets) } func main() { loadConfiguration() loadTemplates() server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/\", index) http.HandleFunc(\"/aboutme\", aboutMe) http.HandleFunc(\"/skillset\", skillSet) server.ListenAndServe() } Before the application starts to listen for HTTP request, all template files are loaded. Every time there is a request, the specific template is executed. Working example: https://github.com/asit-dhal/golang-template-layout . Thanks for reading !!","title":"How to organize template files ?"},{"location":"juce/broadcasters-and-listeners-in-juce/","text":"Broadcasters and listeners in JUCE Juce uses broadcasters and listeners pattern to propagate state changes. This is like classical observer pattern. Broadcasters are subjects and listeners are observers. Juce Framework provides predefined library to automate this process. Let\u2019s say we have a Window with a slider and a label. When the user changes the slider position, the label will show the value. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } At this moment both the slider and the label don\u2019t interact with each other. We are going to show the value of slider in the label. Listeners Most Juce components have an inner class called Listener. This class is an abstract class with at least one pure virtual function. An observer has to inherit from this abstract class and implement the pure virtual function(s). This pure virtual function is the callback. one member function called void addListener(Listener* listener). Using this function, an observer can register it self. another member function called void removeListener(Listener* listener). This one removes the previously registered listener. Whenever a listener is registered, the address is stored in a ListenerList container. Whenever the state changes, the broadcaster iterates over all the registered listeners and calls the appropriate callback. Slider::Listener provides Slider::Listener::sliderValueChanged( Slider *slide) . We can override that function in the MainComponent. Then register the main component as a listener. In the implementation of sliderValueChanged, we can set the value of the slider in the label. //MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, public Slider::Listener // step 1: inherit the listener abstract class { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; // step 2: implementation of pure virtual function void sliderValueChanged(Slider *slider) override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; //MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); // step 3: register the listener m_valueSlider.addListener(this); } MainComponent::~MainComponent() { // step 5: unregister the listener m_valueSlider.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } void MainComponent::sliderValueChanged(Slider *slider) { // step 4: when the value changes, do whatever you want to do. if (&m_valueSlider == slider) { auto value = slider->getValue(); m_sliderLabel.setText(String(std::to_string(static_cast<int>(value))), dontSendNotification); } } The broadcaster and listener can have a many to many relationship. One callback can be invoked by many broadcaster. So, you need to know which instanced invoked it. So we do the address comparison in line 44(In this case, it\u2019s not necessary, because we have only one broadcaster.). User provided Listener You can also provide your own Listener interface. Let\u2019s say you have a login form. It has two input boxes, one submit button and one clear button. Clear button is activated when at least one input box has some text and Submit button is activated if both are filled with some data. We separate the username and password input control to a separate component, called InputForm. In the main component, we have the InputForm and bothe the buttons. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: InputForm(); ~InputForm(); void paint (Graphics&) override; void resized() override; void submit(); void clear(); private: Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); } InputForm::~InputForm() { } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } We can add a listener interface to the InputForm. It will have to callbacks clearActivated() submitActivated() InputForm must maintain a list of interested listeners and should provide api call for registration and de-registration. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: // other code class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); // ... private: void clearActivate(bool isActive); void submitActivate(bool isActive); // ... bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; // .... }; // InputForm.cpp InputForm::InputForm() { // ... m_clearActive = false; m_submitActive = false; } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } Juce ListenerList class should be used to store the list of listeners. It has many advantages than the std lists, like add or remove listeners from the list during one of the callbacks\u200a\u2014\u200ai.e. while it\u2019s in the middle of iterating the listeners, then it\u2019s guaranteed that no listeners will be mistakenly called after they\u2019ve been removed, but it may mean that some of the listeners could be called more than once, or not at all, depending on the list\u2019s order. It has a bailout checker(Component::BailOutChecker class) which checks if the component has already been deleted. This provides safety guarantee that no callback will be called on a deleted component. ListenerList checks if the listener is already in the list or not. So, double addition won\u2019t have any effect. Now, after implementing input and clear logic, the InputForm control looks like this. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component, public Label::Listener { public: InputForm(); ~InputForm(); class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); void paint (Graphics&) override; void resized() override; void labelTextChanged(Label *labelThatHasChanged) override; void submit(); void clear(); private: void clearActivate(bool isActive); void submitActivate(bool isActive); Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); m_clearActive = false; m_submitActive = false; m_usernameInput.addListener(this); m_passwordInput.addListener(this); } InputForm::~InputForm() { m_usernameInput.removeListener(this); m_passwordInput.removeListener(this); } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } void InputForm::labelTextChanged(Label *labelThatHasChanged) { bool atLeastOneTextFilled = false; if (labelThatHasChanged == &m_usernameInput) { atLeastOneTextFilled = !m_usernameInput.getText(false).isEmpty(); } else if (labelThatHasChanged == &m_passwordInput) { atLeastOneTextFilled = !m_passwordInput.getText(false).isEmpty(); } if (!m_clearActive && atLeastOneTextFilled) { m_clearActive = true; clearActivate(true); } else if (m_clearActive && !atLeastOneTextFilled) { m_clearActive = false; clearActivate(false); } bool allTextFilled = !m_usernameInput.getText(true).isEmpty() && !m_passwordInput.getText(true).isEmpty(); if (!m_submitActive && allTextFilled) { m_submitActive = true; submitActivate(true); } else if (m_submitActive && !allTextFilled) { m_submitActive = false; submitActivate(false); } } void InputForm::submit() { // do nothing } void InputForm::clear() { m_usernameInput.setText(\"\", NotificationType::sendNotification); m_passwordInput.setText(\"\", NotificationType::sendNotification); } When you clear the label programmatically, you need to set the NotificationType. In this case, once the input texts are cleared, we need the callbacks to be called to set the submit and active status. So, we use NotificationType as sendNotification. In the main component, we implement the InputForm::Listener interface and accordingly set the enabled/disabled status of the buttons. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component, public InputForm::Listener { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; void clearActivated(InputForm*, bool isActive) override; void submitActivated(InputForm*, bool isActive) override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; {% endhighlight %} {% highlight cpp %} // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); m_clearButton.setEnabled(false); m_submitButton.setEnabled(false); m_inputForm.addListener(this); m_clearButton.onClick = [this] {m_inputForm.clear(); }; m_submitButton.onClick = [this] {m_inputForm.submit(); }; setSize (600, 400); } MainComponent::~MainComponent() { m_inputForm.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } void MainComponent::clearActivated(InputForm*, bool isActive) { m_clearButton.setEnabled(isActive); } void MainComponent::submitActivated(InputForm*, bool isActive) { m_submitButton.setEnabled(isActive); } The application finally looks like this Comparison with Qt Signal/Slots Callbacks are like Slots in Qt. Qt MOC does all the major work of adding code for callback handling. There is no MOC here, so developer has to write everything. In Qt, signal emitters are completely decoupled from signal receivers. So, if you want to add a new signal, it needs minimum amount of code change. In Juce, you will need at least one pure virtual function, code for listener registration and removal. Both Qt and Juce provide asynchronous call by using Qt Event loop and Juce AsyncUpdater respectively. But Juce needs some protection from race condition. I wrote this blog to clarify my doubts. Feel free to correct if I am wrong or write a comment if you want to suggest something. The source code is shared here https://github.com/asit-dhal/Broadcaster-Listener-Demo","title":"Broadcasters and listeners in JUCE"},{"location":"juce/broadcasters-and-listeners-in-juce/#broadcasters-and-listeners-in-juce","text":"Juce uses broadcasters and listeners pattern to propagate state changes. This is like classical observer pattern. Broadcasters are subjects and listeners are observers. Juce Framework provides predefined library to automate this process. Let\u2019s say we have a Window with a slider and a label. When the user changes the slider position, the label will show the value. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } At this moment both the slider and the label don\u2019t interact with each other. We are going to show the value of slider in the label.","title":"Broadcasters and listeners in JUCE"},{"location":"juce/broadcasters-and-listeners-in-juce/#listeners","text":"Most Juce components have an inner class called Listener. This class is an abstract class with at least one pure virtual function. An observer has to inherit from this abstract class and implement the pure virtual function(s). This pure virtual function is the callback. one member function called void addListener(Listener* listener). Using this function, an observer can register it self. another member function called void removeListener(Listener* listener). This one removes the previously registered listener. Whenever a listener is registered, the address is stored in a ListenerList container. Whenever the state changes, the broadcaster iterates over all the registered listeners and calls the appropriate callback. Slider::Listener provides Slider::Listener::sliderValueChanged( Slider *slide) . We can override that function in the MainComponent. Then register the main component as a listener. In the implementation of sliderValueChanged, we can set the value of the slider in the label. //MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, public Slider::Listener // step 1: inherit the listener abstract class { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; // step 2: implementation of pure virtual function void sliderValueChanged(Slider *slider) override; private: Slider m_valueSlider; Label m_sliderLabel; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; //MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_valueSlider); m_valueSlider.setRange(10, 100); m_valueSlider.setTextValueSuffix(\" Cnt\"); m_valueSlider.setTextBoxStyle(Slider::TextEntryBoxPosition::NoTextBox, false, 0, 0); addAndMakeVisible(m_sliderLabel); m_sliderLabel.setText(\"Value\", dontSendNotification); setSize (600, 400); // step 3: register the listener m_valueSlider.addListener(this); } MainComponent::~MainComponent() { // step 5: unregister the listener m_valueSlider.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto sliderLeft = 120; m_valueSlider.setBounds(sliderLeft, 20, getWidth() - sliderLeft - 10, 20); m_sliderLabel.setBounds(sliderLeft, 50, getWidth() - sliderLeft - 10, 20); } void MainComponent::sliderValueChanged(Slider *slider) { // step 4: when the value changes, do whatever you want to do. if (&m_valueSlider == slider) { auto value = slider->getValue(); m_sliderLabel.setText(String(std::to_string(static_cast<int>(value))), dontSendNotification); } } The broadcaster and listener can have a many to many relationship. One callback can be invoked by many broadcaster. So, you need to know which instanced invoked it. So we do the address comparison in line 44(In this case, it\u2019s not necessary, because we have only one broadcaster.).","title":"Listeners"},{"location":"juce/broadcasters-and-listeners-in-juce/#user-provided-listener","text":"You can also provide your own Listener interface. Let\u2019s say you have a login form. It has two input boxes, one submit button and one clear button. Clear button is activated when at least one input box has some text and Submit button is activated if both are filled with some data. We separate the username and password input control to a separate component, called InputForm. In the main component, we have the InputForm and bothe the buttons. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: InputForm(); ~InputForm(); void paint (Graphics&) override; void resized() override; void submit(); void clear(); private: Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); } InputForm::~InputForm() { } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } We can add a listener interface to the InputForm. It will have to callbacks clearActivated() submitActivated() InputForm must maintain a list of interested listeners and should provide api call for registration and de-registration. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public: // other code class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); // ... private: void clearActivate(bool isActive); void submitActivate(bool isActive); // ... bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; // .... }; // InputForm.cpp InputForm::InputForm() { // ... m_clearActive = false; m_submitActive = false; } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } Juce ListenerList class should be used to store the list of listeners. It has many advantages than the std lists, like add or remove listeners from the list during one of the callbacks\u200a\u2014\u200ai.e. while it\u2019s in the middle of iterating the listeners, then it\u2019s guaranteed that no listeners will be mistakenly called after they\u2019ve been removed, but it may mean that some of the listeners could be called more than once, or not at all, depending on the list\u2019s order. It has a bailout checker(Component::BailOutChecker class) which checks if the component has already been deleted. This provides safety guarantee that no callback will be called on a deleted component. ListenerList checks if the listener is already in the list or not. So, double addition won\u2019t have any effect. Now, after implementing input and clear logic, the InputForm control looks like this. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component, public Label::Listener { public: InputForm(); ~InputForm(); class Listener { public: virtual ~Listener() = default; virtual void clearActivated(InputForm*, bool isActive) = 0; virtual void submitActivated(InputForm*, bool isActive) = 0; }; void addListener(Listener* listenerToAdd); void removeListener(Listener* listenerToRemove); void paint (Graphics&) override; void resized() override; void labelTextChanged(Label *labelThatHasChanged) override; void submit(); void clear(); private: void clearActivate(bool isActive); void submitActivate(bool isActive); Label m_usernameLabel; Label m_passwordLabel; Label m_usernameInput; Label m_passwordInput; bool m_clearActive; bool m_submitActive; ListenerList<Listener> m_listeners; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputForm) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm::InputForm() { addAndMakeVisible(m_usernameLabel); m_usernameLabel.setText(\"Username:\", dontSendNotification); m_usernameLabel.attachToComponent(&m_usernameInput, true); m_usernameLabel.setColour(Label::textColourId, Colours::orange); m_usernameLabel.setJustificationType(Justification::right); addAndMakeVisible(m_passwordLabel); m_passwordLabel.setText(\"Password:\", dontSendNotification); m_passwordLabel.attachToComponent(&m_passwordInput, true); m_passwordLabel.setColour(Label::textColourId, Colours::orange); m_passwordLabel.setJustificationType(Justification::right); addAndMakeVisible(m_usernameInput); m_usernameInput.setEditable(true); m_usernameInput.setColour(Label::backgroundColourId, Colours::darkblue); m_usernameInput.setJustificationType(Justification::left); addAndMakeVisible(m_passwordInput); m_passwordInput.setEditable(true); m_passwordInput.setColour(Label::backgroundColourId, Colours::darkblue); m_passwordInput.setJustificationType(Justification::left); m_clearActive = false; m_submitActive = false; m_usernameInput.addListener(this); m_passwordInput.addListener(this); } InputForm::~InputForm() { m_usernameInput.removeListener(this); m_passwordInput.removeListener(this); } void InputForm::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); // clear the background g.setColour (Colours::grey); g.drawRect (getLocalBounds(), 1); } void InputForm::resized() { auto marginX = 10; auto marginY = 10; auto localBounds = getLocalBounds(); auto usernameRect = localBounds.removeFromTop(50); m_usernameLabel.setBounds(usernameRect.removeFromLeft(usernameRect.getWidth() / 5).reduced(marginX, marginY)); m_usernameInput.setBounds(usernameRect.reduced(marginX, marginY)); auto passwordRect = localBounds.removeFromTop(50); m_passwordLabel.setBounds(passwordRect.removeFromLeft(passwordRect.getWidth() / 5).reduced(marginX)); m_passwordInput.setBounds(passwordRect.reduced(marginX, marginY)); } void InputForm::addListener(Listener* listenerToAdd) { m_listeners.add(listenerToAdd); } void InputForm::removeListener(Listener* listenerToRemove) { jassert(m_listeners.contains(listenerToRemove)); m_listeners.remove(listenerToRemove); } void InputForm::clearActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.clearActivated(this, isActive); }); } void InputForm::submitActivate(bool isActive) { m_listeners.call([this, isActive](Listener& l) { l.submitActivated(this, isActive); }); } void InputForm::labelTextChanged(Label *labelThatHasChanged) { bool atLeastOneTextFilled = false; if (labelThatHasChanged == &m_usernameInput) { atLeastOneTextFilled = !m_usernameInput.getText(false).isEmpty(); } else if (labelThatHasChanged == &m_passwordInput) { atLeastOneTextFilled = !m_passwordInput.getText(false).isEmpty(); } if (!m_clearActive && atLeastOneTextFilled) { m_clearActive = true; clearActivate(true); } else if (m_clearActive && !atLeastOneTextFilled) { m_clearActive = false; clearActivate(false); } bool allTextFilled = !m_usernameInput.getText(true).isEmpty() && !m_passwordInput.getText(true).isEmpty(); if (!m_submitActive && allTextFilled) { m_submitActive = true; submitActivate(true); } else if (m_submitActive && !allTextFilled) { m_submitActive = false; submitActivate(false); } } void InputForm::submit() { // do nothing } void InputForm::clear() { m_usernameInput.setText(\"\", NotificationType::sendNotification); m_passwordInput.setText(\"\", NotificationType::sendNotification); } When you clear the label programmatically, you need to set the NotificationType. In this case, once the input texts are cleared, we need the callbacks to be called to set the submit and active status. So, we use NotificationType as sendNotification. In the main component, we implement the InputForm::Listener interface and accordingly set the enabled/disabled status of the buttons. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component, public InputForm::Listener { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; void clearActivated(InputForm*, bool isActive) override; void submitActivated(InputForm*, bool isActive) override; private: InputForm m_inputForm; TextButton m_clearButton; TextButton m_submitButton; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; {% endhighlight %} {% highlight cpp %} // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { addAndMakeVisible(m_inputForm); addAndMakeVisible(m_clearButton); addAndMakeVisible(m_submitButton); m_clearButton.setButtonText(\"Clear\"); m_submitButton.setButtonText(\"Submit\"); m_clearButton.setEnabled(false); m_submitButton.setEnabled(false); m_inputForm.addListener(this); m_clearButton.onClick = [this] {m_inputForm.clear(); }; m_submitButton.onClick = [this] {m_inputForm.submit(); }; setSize (600, 400); } MainComponent::~MainComponent() { m_inputForm.removeListener(this); } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); g.setFont (Font (16.0f)); g.setColour (Colours::white); } void MainComponent::resized() { auto localBounds = getLocalBounds(); auto buttonArea = localBounds.removeFromBottom(50); m_clearButton.setBounds(buttonArea.removeFromLeft(buttonArea.getWidth() / 2).reduced(10)); m_submitButton.setBounds(buttonArea.reduced(10)); m_inputForm.setBounds(localBounds.reduced(10, 10)); } void MainComponent::clearActivated(InputForm*, bool isActive) { m_clearButton.setEnabled(isActive); } void MainComponent::submitActivated(InputForm*, bool isActive) { m_submitButton.setEnabled(isActive); } The application finally looks like this Comparison with Qt Signal/Slots Callbacks are like Slots in Qt. Qt MOC does all the major work of adding code for callback handling. There is no MOC here, so developer has to write everything. In Qt, signal emitters are completely decoupled from signal receivers. So, if you want to add a new signal, it needs minimum amount of code change. In Juce, you will need at least one pure virtual function, code for listener registration and removal. Both Qt and Juce provide asynchronous call by using Qt Event loop and Juce AsyncUpdater respectively. But Juce needs some protection from race condition. I wrote this blog to clarify my doubts. Feel free to correct if I am wrong or write a comment if you want to suggest something. The source code is shared here https://github.com/asit-dhal/Broadcaster-Listener-Demo","title":"User provided Listener"},{"location":"juce/side-panel-in-juce/","text":"Side Panel in JUCE This tutorial explains the side panel in JUCE GUI framework. Side Panel can be used for navigation if the application doesn\u2019t have a tool bar or menu bar. Usually, it stays on the left or right side of the application and triggered by the user. Juce has built-in support for side panel. Let\u2019s first make a skeleton app. The app will have a button to trigger side panel and a label to show the status. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: TextButton m_invokeSidePanel; Label m_sidePanelStatus; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\") { addAndMakeVisible(m_invokeSidePanel); addAndMakeVisible(m_sidePanelStatus); m_sidePanelStatus.setText(\"status\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); } void MainComponent::resized() { auto localBounds = getLocalBounds(); if (localBounds.getHeight() / 2 - 50 > 5) localBounds.removeFromTop(localBounds.getHeight() / 2 - 50); if (localBounds.getWidth() / 2 - 50 > 5) localBounds.removeFromLeft(localBounds.getWidth() / 2 - 50); auto buttonBound = localBounds.removeFromTop(30).removeFromRight(100); auto statusLabelBound = localBounds.removeFromTop(30).removeFromRight(100).reduced(5); m_invokeSidePanel.setBounds(buttonBound); m_sidePanelStatus.setBounds(statusLabelBound); } When user clicks the button, the side panel should appear. There is already a closed button on the side panel, the user can click on this to close the side panel. The side panel will have a list of entries. When the user selects any of those entries, the status label should show the text. Juce provides a built in component called Side Panel, https://docs.juce.com/master/classSidePanel.html Sidepanel Components SidePanel has two parts. header which can contain a label, a few buttons and a close button a list box which shows a list of entries Let\u2019s add a SidePanel component to the main component. The SidePanel should be shown when the user clicks on the sidePanel button in the main component. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, // step 2: override Button::Listener to get broadcast events from the button public Button::Listener { public: // ... // step 3: implement the button clicked callback void buttonClicked(Button*) override; private: // ... // step 1: add sidepanel SidePanel m_sidePanel; }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"Side Panel Demo\", 250, true, nullptr, false) { // .... addAndMakeVisible(m_sidePanel); // ... m_invokeSidePanel.addListener(this); } MainComponent::~MainComponent() { m_invokeSidePanel.removeListener(this); } void MainComponent::buttonClicked(Button* btn) { if (btn == &m_invokeSidePanel) { // step 4: show the side panel when the button is clicked m_sidePanel.showOrHide(true); } } Now, if you run this, you will a side Panel without any contents on this(there will be only title and a close button). Header Component Let\u2019s add the header component The header has two shape buttons(one for home and another for settings), a title and a close button. // SidePanelHeader.h #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelHeader : public Component { public: SidePanelHeader(const String& titleText); ~SidePanelHeader(); void paint (Graphics&) override; void resized() override; private: Label m_titleLabel; ShapeButton m_homeButton{ \"Home\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }, m_settingsButton{ \"Settings\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelHeader) }; ShapeButton has only one constructor, which takes three color ids, normal color(the colour to fill the shape with when the mouse isn\u2019t over), overColor(the colour to use when the mouse is over the shape) and downColour(the colour to use when the button is in the pressed-down state). In the beginning we will make everything transparent black and repaint with proper color in the paint() method. // SidePanelHeader.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelHeader.h\" SidePanelHeader::SidePanelHeader(const String& titleText) { setOpaque(true); static const unsigned char homeIconPathData[] = { 110,109,0,0,64,65,0,0,64,64,98,0,0,64,65,0,0,64,64,74,12,186,64,164,112,5,65,24,217,22,64,70,182, 51,65,98,35,219,9,64,240,167,54,65,0,0,0,64,170,241,58,65,0,0,0,64,0,0,64,65,98,0,0,0,64,22,217, 72,65,166,155,28,64,0,0,80,65,0,0,64,64,0,0,80,65,108,0,0,160,64,0,0,80,65,108,0,0,160,64,0,0, 160,65,98,0,0,160,64,139,108,164,65,211,77,174,64,0,0,168,65,0,0,192,64,0,0,168,65,108,0,0,16,65, 0,0,168,65,98,22,217,24,65,0,0,168,65,0,0,32,65,127,106,164,65,0,0,32,65,0,0,160,65,108,0,0,32,65,0,0,128, 65,108,0,0,96,65,0,0,128,65,108,0,0,96,65,0,0,160,65,98,0,0,96,65,127,106,164,65,233,38,103,65,0,0,168, 65,0,0,112,65,0,0,168,65,108,0,0,144,65,0,0,168,65,98,139,108,148,65,0,0,168,65,0,0,152,65,139,108,164, 65,0,0,152,65,0,0,160,65,108,0,0,152,65,0,0,80,65,108,0,0,168,65,0,0,80,65,98,139,108,172,65,0,0,80,65,0, 0,176,65,23,217,72,65,0,0,176,65,0,0,64,65,98,0,0,176,65,170,241,58,65,156,196,174,65,240,167,54,65,158,239, 172,65,70,182,51,65,98,213,120,145,65,164,112,5,65,0,0,64,65,0,0,64,64,0,0,64,65,0,0,64,64,99, 101,0,0 }; static const unsigned char settingsIconPathData[] = { 110,109,202,111,210,64,243,226,61,64,108,0,0,224,64,0,0,0,0,108,0,0,48,65,0,0,0,0,108,27,200,54,65,243, 226,61,64,98,91,248,63,65,174,170,76,64,95,130,72,65,231,138,96,64,46,46,80,65,180,163,120,64,108,42, 181,124,65,20,38,49,64,108,149,90,142,65,246,108,199,64,108,68,249,118,65,2,85,1,65,98,112,166,119,65, 201,31,6,65,0,0,120,65,111,5,11,65,0,0,120,65,0,0,16,65,98,0,0,120,65,145,250,20,65,108,166,119,65,55, 224,25,65,72,249,118,65,254,170,30,65,108,151,90,142,65,133,73,60,65,108,46,181,124,65,123,182,115,65, 108,50,46,80,65,18,215,97,65,98,99,130,72,65,70,221,103,65,96,248,63,65,83,213,108,65,32,200,54,65,66, 135,112,65,108,0,0,48,65,0,0,144,65,108,0,0,224,64,0,0,144,65,108,202,111,210,64,67,135,112,65,98,74, 15,192,64,84,213,108,65,65,251,174,64,70,221,103,65,164,163,159,64,19,215,97,65,108,92,43,13,64,123,182, 115,65,108,187,181,82,62,133,73,60,65,108,244,26,36,64,254,170,30,65,98,64,102,33,64,55,224,25,5,0,0,32, 64,145,250,20,65,0,0,32,64,0,0,16,65,98,0,0,32,64,111,5,11,65,64,102,33,64,201,31,6,65,244,26,36,64,2,85, 1,65,108,187,181,82,62,246,108,199,64,108,92,43,13,64,20,38,49,64,108,164,163,159,64,180,163,120,64,98,65, 251,174,64,231,138,96,64,74,15,192,64,175,170,76,64,202,111,210,64,243,226,61,64,99,109,0,0,16,65,0,0,64, 65,98,121,130,42,65,0,0,64,65,0,0,64,65,121,130,42,65,0,0,64,65,0,0,16,65,98,0,0,64,65,13,251,234,64,121, 130,42,65,0,0,192,64,0,0,16,65,0,0,192,64,98,13,251,234,64,0,0,192,64,0,0,192,64,13,251,234,64,0,0,192,64, 0,0,16,65,98,0,0,192,64,121,130,42,65,13,251,234,64,0,0,64,65,0,0,16,65,0,0,64,65,99,101,0,0 }; Path p; p.loadPathFromData(homeIconPathData, sizeof(homeIconPathData)); m_homeButton.setShape(p, true, true, false); p.clear(); p.loadPathFromData(settingsIconPathData, sizeof(settingsIconPathData)); m_settingsButton.setShape(p, true, true, false); m_titleLabel.setText(titleText, NotificationType::dontSendNotification); addAndMakeVisible(m_titleLabel); addAndMakeVisible(m_homeButton); addAndMakeVisible(m_settingsButton); } SidePanelHeader::~SidePanelHeader() { } void SidePanelHeader::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background auto normal = getLookAndFeel().findColour(SidePanel::dismissButtonNormalColour); auto over = getLookAndFeel().findColour(SidePanel::dismissButtonOverColour); auto down = getLookAndFeel().findColour(SidePanel::dismissButtonDownColour); m_homeButton.setColours(normal, over, down); m_settingsButton.setColours(normal, over, down); } void SidePanelHeader::resized() { auto bounds = getLocalBounds(); bounds.removeFromLeft(10); m_homeButton.setBounds(bounds.removeFromLeft(m_homeButton.getWidth()+20).reduced(7)); m_settingsButton.setBounds(bounds.removeFromLeft(m_settingsButton.getWidth()+20).reduced(7)); bounds.removeFromLeft(10); bounds.removeFromRight(10); m_titleLabel.setBounds(bounds); } I copied the path data for home button and settings button from DemoRunner. This comes with Juce Framework. Everything else is straight forward. In the MainComponent, we set this header as the title bar component of side panel. // MainComponent.cpp #include \"MainComponent.h\" #include \"SidePanelHeader.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"\", 250, true, nullptr, false) // we don't need the title here anymore { //... auto sidePanelHeader = new SidePanelHeader(\"Side Panel\"); m_sidePanel.setTitleBarComponent(sidePanelHeader, true); } Notice that the object is dynamically created. After we set, the parent component takes the ownership. void setTitleBarComponent (Component* titleBarComponentToUse, bool keepDismissButton, bool deleteComponentWhenNoLongerNeeded = true); The last parameter decides whether the parent component needs to take care of the ownership or not. Now, let\u2019s add the side panel list. This is just a list box which contains a list and responds to row selection. // SidePanelList.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelList : public Component, public ListBoxModel { public: SidePanelList(); ~SidePanelList(); void paint (Graphics&) override; void resized() override; void paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) override; int getNumRows() override; void addEntry(const String& entry); void selectedRowsChanged(int row) override; private: ListBox m_entries; StringArray m_sidePanelEntries; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelList) }; // SidePanelList #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelList.h\" SidePanelList::SidePanelList() { setOpaque(true); addAndMakeVisible(m_entries); m_entries.setModel(this); m_entries.setRowHeight(40); } SidePanelList::~SidePanelList() { } void SidePanelList::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background } void SidePanelList::resized() { m_entries.setBounds(getLocalBounds()); } void SidePanelList::paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) { if (rowNumber < 0 || rowNumber >= getNumRows()) return; Rectangle<int> bounds(0, 0, width, height); auto textColour = findColour(Label::textColourId); g.setColour(textColour.withAlpha(0.4f)); if (rowNumber == 0) g.fillRect(bounds.removeFromTop(2).reduced(10, 0)); g.fillRect(bounds.removeFromBottom(2).reduced(10, 0)); if (rowIsSelected) { g.setColour(findColour(TextEditor::highlightColourId).withAlpha(0.4f)); g.fillRect(bounds); textColour = findColour(TextEditor::highlightedTextColourId); } g.setColour(textColour); g.drawFittedText(m_sidePanelEntries[rowNumber], bounds, Justification::centred, 1); } void SidePanelList::addEntry(const String& entry) { m_entries.deselectAllRows(); m_sidePanelEntries.add(entry); m_entries.updateContent(); } int SidePanelList::getNumRows() { return m_sidePanelEntries.size(); } void SidePanelList::selectedRowsChanged(int row) { if (row < 0) return; } We can integrate this list component with the side panel. // MainComponent.cpp MainComponent::MainComponent() { //..... auto sidePanelList = new SidePanelList; sidePanelList->addEntry(\"Entry 1\"); sidePanelList->addEntry(\"Entry 2\"); sidePanelList->addEntry(\"Entry 3\"); m_sidePanel.setContent(sidePanelList); } The setContent is like setTitleBarComponent , it takes the ownership. After attaching all click listeners, we can update the status. The source code is shared in the github. https://github.com/asit-dhal/Juce-SidePanel-Example","title":"Side Panel in JUCE"},{"location":"juce/side-panel-in-juce/#side-panel-in-juce","text":"This tutorial explains the side panel in JUCE GUI framework. Side Panel can be used for navigation if the application doesn\u2019t have a tool bar or menu bar. Usually, it stays on the left or right side of the application and triggered by the user. Juce has built-in support for side panel. Let\u2019s first make a skeleton app. The app will have a button to trigger side panel and a label to show the status. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public: MainComponent(); ~MainComponent(); void paint (Graphics&) override; void resized() override; private: TextButton m_invokeSidePanel; Label m_sidePanelStatus; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\") { addAndMakeVisible(m_invokeSidePanel); addAndMakeVisible(m_sidePanelStatus); m_sidePanelStatus.setText(\"status\", dontSendNotification); setSize (600, 400); } MainComponent::~MainComponent() { } void MainComponent::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId)); } void MainComponent::resized() { auto localBounds = getLocalBounds(); if (localBounds.getHeight() / 2 - 50 > 5) localBounds.removeFromTop(localBounds.getHeight() / 2 - 50); if (localBounds.getWidth() / 2 - 50 > 5) localBounds.removeFromLeft(localBounds.getWidth() / 2 - 50); auto buttonBound = localBounds.removeFromTop(30).removeFromRight(100); auto statusLabelBound = localBounds.removeFromTop(30).removeFromRight(100).reduced(5); m_invokeSidePanel.setBounds(buttonBound); m_sidePanelStatus.setBounds(statusLabelBound); } When user clicks the button, the side panel should appear. There is already a closed button on the side panel, the user can click on this to close the side panel. The side panel will have a list of entries. When the user selects any of those entries, the status label should show the text. Juce provides a built in component called Side Panel, https://docs.juce.com/master/classSidePanel.html","title":"Side Panel in JUCE"},{"location":"juce/side-panel-in-juce/#sidepanel-components","text":"SidePanel has two parts. header which can contain a label, a few buttons and a close button a list box which shows a list of entries Let\u2019s add a SidePanel component to the main component. The SidePanel should be shown when the user clicks on the sidePanel button in the main component. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component, // step 2: override Button::Listener to get broadcast events from the button public Button::Listener { public: // ... // step 3: implement the button clicked callback void buttonClicked(Button*) override; private: // ... // step 1: add sidepanel SidePanel m_sidePanel; }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"Side Panel Demo\", 250, true, nullptr, false) { // .... addAndMakeVisible(m_sidePanel); // ... m_invokeSidePanel.addListener(this); } MainComponent::~MainComponent() { m_invokeSidePanel.removeListener(this); } void MainComponent::buttonClicked(Button* btn) { if (btn == &m_invokeSidePanel) { // step 4: show the side panel when the button is clicked m_sidePanel.showOrHide(true); } } Now, if you run this, you will a side Panel without any contents on this(there will be only title and a close button).","title":"Sidepanel Components"},{"location":"juce/side-panel-in-juce/#header-component","text":"Let\u2019s add the header component The header has two shape buttons(one for home and another for settings), a title and a close button. // SidePanelHeader.h #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelHeader : public Component { public: SidePanelHeader(const String& titleText); ~SidePanelHeader(); void paint (Graphics&) override; void resized() override; private: Label m_titleLabel; ShapeButton m_homeButton{ \"Home\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }, m_settingsButton{ \"Settings\", Colours::transparentBlack, Colours::transparentBlack, Colours::transparentBlack }; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelHeader) }; ShapeButton has only one constructor, which takes three color ids, normal color(the colour to fill the shape with when the mouse isn\u2019t over), overColor(the colour to use when the mouse is over the shape) and downColour(the colour to use when the button is in the pressed-down state). In the beginning we will make everything transparent black and repaint with proper color in the paint() method. // SidePanelHeader.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelHeader.h\" SidePanelHeader::SidePanelHeader(const String& titleText) { setOpaque(true); static const unsigned char homeIconPathData[] = { 110,109,0,0,64,65,0,0,64,64,98,0,0,64,65,0,0,64,64,74,12,186,64,164,112,5,65,24,217,22,64,70,182, 51,65,98,35,219,9,64,240,167,54,65,0,0,0,64,170,241,58,65,0,0,0,64,0,0,64,65,98,0,0,0,64,22,217, 72,65,166,155,28,64,0,0,80,65,0,0,64,64,0,0,80,65,108,0,0,160,64,0,0,80,65,108,0,0,160,64,0,0, 160,65,98,0,0,160,64,139,108,164,65,211,77,174,64,0,0,168,65,0,0,192,64,0,0,168,65,108,0,0,16,65, 0,0,168,65,98,22,217,24,65,0,0,168,65,0,0,32,65,127,106,164,65,0,0,32,65,0,0,160,65,108,0,0,32,65,0,0,128, 65,108,0,0,96,65,0,0,128,65,108,0,0,96,65,0,0,160,65,98,0,0,96,65,127,106,164,65,233,38,103,65,0,0,168, 65,0,0,112,65,0,0,168,65,108,0,0,144,65,0,0,168,65,98,139,108,148,65,0,0,168,65,0,0,152,65,139,108,164, 65,0,0,152,65,0,0,160,65,108,0,0,152,65,0,0,80,65,108,0,0,168,65,0,0,80,65,98,139,108,172,65,0,0,80,65,0, 0,176,65,23,217,72,65,0,0,176,65,0,0,64,65,98,0,0,176,65,170,241,58,65,156,196,174,65,240,167,54,65,158,239, 172,65,70,182,51,65,98,213,120,145,65,164,112,5,65,0,0,64,65,0,0,64,64,0,0,64,65,0,0,64,64,99, 101,0,0 }; static const unsigned char settingsIconPathData[] = { 110,109,202,111,210,64,243,226,61,64,108,0,0,224,64,0,0,0,0,108,0,0,48,65,0,0,0,0,108,27,200,54,65,243, 226,61,64,98,91,248,63,65,174,170,76,64,95,130,72,65,231,138,96,64,46,46,80,65,180,163,120,64,108,42, 181,124,65,20,38,49,64,108,149,90,142,65,246,108,199,64,108,68,249,118,65,2,85,1,65,98,112,166,119,65, 201,31,6,65,0,0,120,65,111,5,11,65,0,0,120,65,0,0,16,65,98,0,0,120,65,145,250,20,65,108,166,119,65,55, 224,25,65,72,249,118,65,254,170,30,65,108,151,90,142,65,133,73,60,65,108,46,181,124,65,123,182,115,65, 108,50,46,80,65,18,215,97,65,98,99,130,72,65,70,221,103,65,96,248,63,65,83,213,108,65,32,200,54,65,66, 135,112,65,108,0,0,48,65,0,0,144,65,108,0,0,224,64,0,0,144,65,108,202,111,210,64,67,135,112,65,98,74, 15,192,64,84,213,108,65,65,251,174,64,70,221,103,65,164,163,159,64,19,215,97,65,108,92,43,13,64,123,182, 115,65,108,187,181,82,62,133,73,60,65,108,244,26,36,64,254,170,30,65,98,64,102,33,64,55,224,25,5,0,0,32, 64,145,250,20,65,0,0,32,64,0,0,16,65,98,0,0,32,64,111,5,11,65,64,102,33,64,201,31,6,65,244,26,36,64,2,85, 1,65,108,187,181,82,62,246,108,199,64,108,92,43,13,64,20,38,49,64,108,164,163,159,64,180,163,120,64,98,65, 251,174,64,231,138,96,64,74,15,192,64,175,170,76,64,202,111,210,64,243,226,61,64,99,109,0,0,16,65,0,0,64, 65,98,121,130,42,65,0,0,64,65,0,0,64,65,121,130,42,65,0,0,64,65,0,0,16,65,98,0,0,64,65,13,251,234,64,121, 130,42,65,0,0,192,64,0,0,16,65,0,0,192,64,98,13,251,234,64,0,0,192,64,0,0,192,64,13,251,234,64,0,0,192,64, 0,0,16,65,98,0,0,192,64,121,130,42,65,13,251,234,64,0,0,64,65,0,0,16,65,0,0,64,65,99,101,0,0 }; Path p; p.loadPathFromData(homeIconPathData, sizeof(homeIconPathData)); m_homeButton.setShape(p, true, true, false); p.clear(); p.loadPathFromData(settingsIconPathData, sizeof(settingsIconPathData)); m_settingsButton.setShape(p, true, true, false); m_titleLabel.setText(titleText, NotificationType::dontSendNotification); addAndMakeVisible(m_titleLabel); addAndMakeVisible(m_homeButton); addAndMakeVisible(m_settingsButton); } SidePanelHeader::~SidePanelHeader() { } void SidePanelHeader::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background auto normal = getLookAndFeel().findColour(SidePanel::dismissButtonNormalColour); auto over = getLookAndFeel().findColour(SidePanel::dismissButtonOverColour); auto down = getLookAndFeel().findColour(SidePanel::dismissButtonDownColour); m_homeButton.setColours(normal, over, down); m_settingsButton.setColours(normal, over, down); } void SidePanelHeader::resized() { auto bounds = getLocalBounds(); bounds.removeFromLeft(10); m_homeButton.setBounds(bounds.removeFromLeft(m_homeButton.getWidth()+20).reduced(7)); m_settingsButton.setBounds(bounds.removeFromLeft(m_settingsButton.getWidth()+20).reduced(7)); bounds.removeFromLeft(10); bounds.removeFromRight(10); m_titleLabel.setBounds(bounds); } I copied the path data for home button and settings button from DemoRunner. This comes with Juce Framework. Everything else is straight forward. In the MainComponent, we set this header as the title bar component of side panel. // MainComponent.cpp #include \"MainComponent.h\" #include \"SidePanelHeader.h\" MainComponent::MainComponent(): m_invokeSidePanel(\"Sidepanel\", \"Show Sidepanel\"), m_sidePanel(\"\", 250, true, nullptr, false) // we don't need the title here anymore { //... auto sidePanelHeader = new SidePanelHeader(\"Side Panel\"); m_sidePanel.setTitleBarComponent(sidePanelHeader, true); } Notice that the object is dynamically created. After we set, the parent component takes the ownership. void setTitleBarComponent (Component* titleBarComponentToUse, bool keepDismissButton, bool deleteComponentWhenNoLongerNeeded = true); The last parameter decides whether the parent component needs to take care of the ownership or not. Now, let\u2019s add the side panel list. This is just a list box which contains a list and responds to row selection. // SidePanelList.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelList : public Component, public ListBoxModel { public: SidePanelList(); ~SidePanelList(); void paint (Graphics&) override; void resized() override; void paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) override; int getNumRows() override; void addEntry(const String& entry); void selectedRowsChanged(int row) override; private: ListBox m_entries; StringArray m_sidePanelEntries; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SidePanelList) }; // SidePanelList #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelList.h\" SidePanelList::SidePanelList() { setOpaque(true); addAndMakeVisible(m_entries); m_entries.setModel(this); m_entries.setRowHeight(40); } SidePanelList::~SidePanelList() { } void SidePanelList::paint (Graphics& g) { g.fillAll (getLookAndFeel().findColour (SidePanel::backgroundColour)); // clear the background } void SidePanelList::resized() { m_entries.setBounds(getLocalBounds()); } void SidePanelList::paintListBoxItem(int rowNumber, Graphics& g, int width, int height, bool rowIsSelected) { if (rowNumber < 0 || rowNumber >= getNumRows()) return; Rectangle<int> bounds(0, 0, width, height); auto textColour = findColour(Label::textColourId); g.setColour(textColour.withAlpha(0.4f)); if (rowNumber == 0) g.fillRect(bounds.removeFromTop(2).reduced(10, 0)); g.fillRect(bounds.removeFromBottom(2).reduced(10, 0)); if (rowIsSelected) { g.setColour(findColour(TextEditor::highlightColourId).withAlpha(0.4f)); g.fillRect(bounds); textColour = findColour(TextEditor::highlightedTextColourId); } g.setColour(textColour); g.drawFittedText(m_sidePanelEntries[rowNumber], bounds, Justification::centred, 1); } void SidePanelList::addEntry(const String& entry) { m_entries.deselectAllRows(); m_sidePanelEntries.add(entry); m_entries.updateContent(); } int SidePanelList::getNumRows() { return m_sidePanelEntries.size(); } void SidePanelList::selectedRowsChanged(int row) { if (row < 0) return; } We can integrate this list component with the side panel. // MainComponent.cpp MainComponent::MainComponent() { //..... auto sidePanelList = new SidePanelList; sidePanelList->addEntry(\"Entry 1\"); sidePanelList->addEntry(\"Entry 2\"); sidePanelList->addEntry(\"Entry 3\"); m_sidePanel.setContent(sidePanelList); } The setContent is like setTitleBarComponent , it takes the ownership. After attaching all click listeners, we can update the status. The source code is shared in the github. https://github.com/asit-dhal/Juce-SidePanel-Example","title":"Header Component"}]}