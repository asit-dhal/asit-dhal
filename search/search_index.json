{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Me \u00b6 Hi ! I am Asit Dhal. I am from Bhubaneswar, a small and not so popular and important city in the eastern India. At this moment I work in Munich for a small automotive software company. I work in C++17, OpenGL(distributed 3D rendering) and Qt. I try to write simple and elegant code. Sometimes, I also work in open source projects. I also know a little bit about Golang and Rust, have worked in Python and PyQt. If you want me to work in your open source project, drop me a mail. I usually prefer modern C++, Desktop Applications(C++ based, not those horrible CEF or Electron). Contact Me \u00b6 Github Mail me","title":"Home"},{"location":"#about-me","text":"Hi ! I am Asit Dhal. I am from Bhubaneswar, a small and not so popular and important city in the eastern India. At this moment I work in Munich for a small automotive software company. I work in C++17, OpenGL(distributed 3D rendering) and Qt. I try to write simple and elegant code. Sometimes, I also work in open source projects. I also know a little bit about Golang and Rust, have worked in Python and PyQt. If you want me to work in your open source project, drop me a mail. I usually prefer modern C++, Desktop Applications(C++ based, not those horrible CEF or Electron).","title":"About Me"},{"location":"#contact-me","text":"Github Mail me","title":"Contact Me"},{"location":"archives/","text":"2019 \u00b6 Positioning with Anchors Properties Functions and Macros Property Check Algorithms Range Generator Algorithms Side Panel in JUCE Broadcasters and listeners in JUCE 2018 \u00b6 string conversion benchmark in C++ Delete old branches in Git 2016 \u00b6 Golang Template-2 Template composition Golang Templates-1 Introduction Golang slice and append","title":"Archives"},{"location":"archives/#2019","text":"Positioning with Anchors Properties Functions and Macros Property Check Algorithms Range Generator Algorithms Side Panel in JUCE Broadcasters and listeners in JUCE","title":"2019"},{"location":"archives/#2018","text":"string conversion benchmark in C++ Delete old branches in Git","title":"2018"},{"location":"archives/#2016","text":"Golang Template-2 Template composition Golang Templates-1 Introduction Golang slice and append","title":"2016"},{"location":"cmake/custom-command-and-custom-tasks/","text":"Custom Commands and Custom Targets \u00b6 Sometimes you need to do some tasks before the build or after the build, like runnning protocol buffer compiler to generate stubs before the actual build running moc on header files copying the resource files to a predefined path. You can assume these as custom targets and you can write custom commands to do these things. CMake provides add_custom_target and add_custom_command to do these tasks. CMake targets \u00b6 CMake allows three types of targets generates an execuatable( add_executable ) generates a library( add_library ) a custom target(can be anything) CMake generates a dependency graph for every target. If a target depends on another target, cmake makes sure the other targate is generated before. However, you can always cmake to build a specific target. Unlike executable and libraries, custom target don't represent a thing. add_custom_target \u00b6 add_custom_target ( targetName [ALL] [command1 [args1...]] [COMMAND command2 [args2...] ...] [DEPENDS depend depend depend ... ] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [JOB_POOL job_pool] [VERBATIM] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] [SOURCES src1 [src2...]] ) targetName is the new target name. You can run the target using the following command. cmake . --build --target targetName ALL option makes the ALL target depend on the targetName. By default ALL target is built if nothing is specified. By making ALL depend on this target, we make this target to be built. Otherwise you have to explicitly request a build. Or, it will be built if some other target depends on this. Custom targets are always built(always out of date). So, if some other target depends on this, that other target will always be built. The next arguments are one or more commands with their arguments. You can skip the COMMAND keyword for the first command. Commands are the good old commands which can be executed. The order is always the order in which it is specified. CMake provides some predefined command which can be usec by ${CMAKE_COMMAND} -E (cmake in command mode). ${CMAKE_COMMAND} is the cmake command which is used to invoke this project. This way of invoking cmake command makes sure that wrong cmake is not invoked. It's recommended to use ${CMAKE_COMMAND} -E to call cmake provided commands. It's more platform independent. add_custom_target ( target1 ALL COMMAND ${ CMAKE_COMMAND } -E echo \"This is command 1\" COMMAND ${ CMAKE_COMMAND } -E echo \"This is command 2\" COMMAND ${ CMAKE_COMMAND } -E echo \"This is command 3\" ) Output This is command 1 This is command 2 This is command 3 DEPENDS argument will take one or more targets. This will always create a target level dependency. These targets will be built before the current target. add_custom_target ( target1 COMMAND ${ CMAKE_COMMAND } -E echo \"This is target1\" ) add_custom_target ( target2 COMMAND ${ CMAKE_COMMAND } -E echo \"This is target2\" ) add_custom_target ( target3 ALL COMMAND ${ CMAKE_COMMAND } -E echo \"This is target3\" DEPENDS target1 target2 ) Output This is target2 Built target target2 This is target1 Built target target1 This is target3 Built target target3 BYPRODUCTS are the list of files expected to be generated. These are marked as GENERATED . This tells CMake not to check for its existence at configure time, since it gets created as part of the build process. This is useful if you have targe which needs a GENERATED file from another custom target. CMake will not check the existence during configuration phase. WORKING_DIRECTORY is the directory where the commands are generated. If this option is not given, the commands will be run in ${CMAKE_CURRENT_BINARY_DIR} . COMMENT is the message which will be shown in the console before the targetName is built. JOB_POOL is optional and I have no clue what it is. SOURCES option has no role in the build process. Any files mentioned here will be shown in the IDE. If you have a custom command which copies some shader files to a specific path, you can add those files in the SOURCES. Then IDE will show the files in the project tree. Some header only libraries also use custom command to show the header files in the project set ( HEADER_BASE \"${CMAKE_CURRENT_SOURCE_DIR}/external/stringify\" ) file ( GLOB_RECURSE stringify_include_SRCS \"${HEADER_BASE}/*.hpp\" ) add_custom_target ( stringify_headers_for_ide SOURCES ${ stringify_include_SRCS } ) VERBATIM : Example 1: copy resource files after build \u00b6 I have some vertex and fragment shader, which are in current source directory. . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 CoordinateSystem.cpp \u251c\u2500\u2500 CoordinateSystem.h \u251c\u2500\u2500 main.cpp \u2514\u2500\u2500 res \u251c\u2500\u2500 shader.frag \u2514\u2500\u2500 shader.vert I need to copy the resource files in res folder to the binary folder. set ( TARGET_NAME coordinate_system ) add_executable ( ${ TARGET_NAME } CoordinateSystem.cpp main.cpp ) target_link_libraries ( ${ TARGET_NAME } PRIVATE opengl-framework ) set ( RES_FILES \"${CMAKE_CURRENT_SOURCE_DIR}/res/shader.frag\" \"${CMAKE_CURRENT_SOURCE_DIR}/res/shader.vert\" ) add_custom_target ( ${ TARGET_NAME } _copy_resources ALL COMMAND ${ CMAKE_COMMAND } -E copy_if_different ${ RES_FILES } ${ CMAKE_CURRENT_BINARY_DIR } DEPENDS ${ TARGET_NAME } COMMENT \"Copying resource files for ${TARGET_NAME}\" SOURCES ${ RES_FILES } ) My custom command depends on the target(technically not :P ). ${CMAKE_COMMAND} is the cmake command which is used to invoke this project. In some projects, there are multiple versions of cmake. This way of invoking cmake command makes sure that wrong cmake is not invoked. -E is the option to invoke some predefined cmake command. You can get a list of cmake supported commands by --help option. \ue0a0 master \u25cf \ue0b0 cmake -E --help CMake Error: cmake version 3.13.5 Usage: cmake -E <command> [arguments...] Available commands: capabilities - Report capabilities built into cmake in JSON format chdir dir cmd [args...] - run command in a given directory .... .... blah blah It's recommended to use ${CMAKE_COMMAND} -E to call cmake provided commands. It's more platform independent. \ue0a0 master \u25cf \ue0b0 cmake -E --help CMake Error: cmake version 3.13.5 Usage: cmake -E <command> [arguments...] Available commands: capabilities - Report capabilities built into cmake in JSON format chdir dir cmd [args...] - run command in a given directory compare_files file1 file2 - check if file1 is same as file2 copy <file>... destination - copy files to destination (either file or directory) copy_directory <dir>... destination - copy content of <dir>... directories to 'destination' directory copy_if_different <file>... destination - copy files if it has changed echo [<string>...] - displays arguments as text .... .... blah blah copy_if_different uses the timestamp to check if the source files are changed. I have added explicit dependency with orginal target. What's point of copying the resource files if the binary build fails ? COMMENT text will be visible when you run the build. SOURCES will make the IDE show the resource files. Here the build log Scanning dependencies of target coordinate_system [ 88%] Building CXX object example/coordinate_system/CMakeFiles/coordinate_system.dir/CoordinateSystem.cpp.o [ 92%] Building CXX object example/coordinate_system/CMakeFiles/coordinate_system.dir/main.cpp.o [ 96%] Linking CXX executable coordinate_system [ 96%] Built target coordinate_system Scanning dependencies of target coordinate_system_copy_resources [100%] Copying resource files for coordinate_system [100%] Built target coordinate_system_copy_resources SOURCES will make the IDE show the resource files. add_custom_command \u00b6 Sometimes a custom target is a little over engineering, e.g. you need to run a small script for each binary generated. Instead you can add the additional rules when the target is built. add_custom_command serves this purpose. There are two kinds of custom command command to generate files: generates specified OUTPUT file(s) command which runs on build events Generating Files \u00b6 add_custom_command ( OUTPUT output1 [output2 ...] COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [MAIN_DEPENDENCY depend] [DEPENDS [depends...]] [BYPRODUCTS [files...]] [IMPLICIT_DEPENDS <lang1> depend1 [<lang2> depend2] ...] [WORKING_DIRECTORY dir] [COMMENT comment] [DEPFILE depfile] [JOB_POOL job_pool] [VERBATIM] [APPEND] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] ) add_custom_command takes one or more output file names to be given after the OUTPUT keyword. The series of commands will be executed to generate that file. Custom commands are not executed on its own. If some other target has some dependency on the output file, then the custom command is invoked. add_custom_command generates file by running a one or more commands after the dependent target has been built. COMMAND, BYPRODUCTS, COMMENT and USES_TERMINAL options behave like add_custom_target. IMPLICIT_DEPENDS Request scanning of implicit dependencies of an input file. The language given specifies the programming language whose corresponding dependency scanner should be used. Currently only C and CXX language scanners are supported. The language has to be specified for every file in the IMPLICIT_DEPENDS list. Dependencies discovered from the scanning are added to those of the custom command at build time. Note that the IMPLICIT_DEPENDS option is currently supported only for Makefile generators and will be ignored by other generators. DEPENDS \u00b6 If DEPENDS is missing, the custom command will be run when the OUTPUT is missing. If the custom command doesn't create any file, then this will run always. If any dependency is an OUTPUT of another custom command in the same directory (CMakeLists.txt file) CMake automatically brings the other custom command into the target in which this command is built. If the DEPENDS is the target of any add_executable, add_library or add_custom_target, a target level dependency is created. Build Events \u00b6 add_custom_command ( TARGET <target> PRE_BUILD | PRE_LINK | POST_BUILD COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [VERBATIM] [USES_TERMINAL] ) This custom command will add additional rule to existing targets. The first argument is the target name, it should be specifiec before the command. The target should be created either by add_executable , add_library or add_custom__target . PRE_BUILD , PRE_LINK or POST_BUILD is the time when the command will run. PRE_BUILD :- The command will run before any other rules are executed within the target in case of Visual Studio. In other generators, it will behave like PRE_LINK . PRE_LINK :- The command will run after the compilation and before the linking. It's not supported for custom commands. POST_BUILD :- This will be run after the target is built. You can add any number of custom commands for a build. All other options are similar to add_custom_target. add_executable ( main main.cpp ) add_custom_command ( TARGET main PRE_BUILD COMMAND ${ CMAKE_COMMAND } -E echo \"This is pre build command\" COMMENT \"Custom command for pre build\" ) add_custom_command ( TARGET main PRE_LINK COMMAND ${ CMAKE_COMMAND } -E echo \"This is pre link command\" COMMENT \"Custom command for pre link\" ) add_custom_command ( TARGET main POST_BUILD COMMAND ${ CMAKE_COMMAND } -E echo \"This is post build command\" COMMENT \"Custom command for post build\" ) Output Custom command for pre build This is pre build command Custom command for pre build 2 This is pre build command 2 Custom command for pre link This is pre link command Custom command for post build This is post build command [100%] Built target main If the target is not rebuilt, custom command won't be executed. Example:- \u00b6 I have a benchmarking project where I need to execute all binaries and generate report. I want this to be fully integrated into the build system. add_executable ( fill fill.cpp ) target_link_libraries ( fill PRIVATE benchmark::benchmark benchmark::benchmark_main PRIVATE meta range-v3 ) add_custom_command ( TARGET fill POST_BUILD COMMAND ${ CMAKE_RUNTIME_OUTPUT_DIRECTORY } /fill \"--benchmark_format=json\" > ${ BENCHMARK_REPORT_DIRECTORY } /fill.json COMMENT \"Generating report for fill\" ) Output Scanning dependencies of target fill [ 12%] Building CXX object CMakeFiles/fill.dir/fill.cpp.o [ 25%] Linking CXX executable bin/fill Generating report for fill Here after the target fill is built, it will be executed to generate report. The entire source code can be found here CMakeLists.txt","title":"Custom Commands and Custom Tasks"},{"location":"cmake/custom-command-and-custom-tasks/#custom-commands-and-custom-targets","text":"Sometimes you need to do some tasks before the build or after the build, like runnning protocol buffer compiler to generate stubs before the actual build running moc on header files copying the resource files to a predefined path. You can assume these as custom targets and you can write custom commands to do these things. CMake provides add_custom_target and add_custom_command to do these tasks.","title":"Custom Commands and Custom Targets"},{"location":"cmake/custom-command-and-custom-tasks/#cmake-targets","text":"CMake allows three types of targets generates an execuatable( add_executable ) generates a library( add_library ) a custom target(can be anything) CMake generates a dependency graph for every target. If a target depends on another target, cmake makes sure the other targate is generated before. However, you can always cmake to build a specific target. Unlike executable and libraries, custom target don't represent a thing.","title":"CMake targets"},{"location":"cmake/custom-command-and-custom-tasks/#add_custom_target","text":"add_custom_target ( targetName [ALL] [command1 [args1...]] [COMMAND command2 [args2...] ...] [DEPENDS depend depend depend ... ] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [JOB_POOL job_pool] [VERBATIM] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] [SOURCES src1 [src2...]] ) targetName is the new target name. You can run the target using the following command. cmake . --build --target targetName ALL option makes the ALL target depend on the targetName. By default ALL target is built if nothing is specified. By making ALL depend on this target, we make this target to be built. Otherwise you have to explicitly request a build. Or, it will be built if some other target depends on this. Custom targets are always built(always out of date). So, if some other target depends on this, that other target will always be built. The next arguments are one or more commands with their arguments. You can skip the COMMAND keyword for the first command. Commands are the good old commands which can be executed. The order is always the order in which it is specified. CMake provides some predefined command which can be usec by ${CMAKE_COMMAND} -E (cmake in command mode). ${CMAKE_COMMAND} is the cmake command which is used to invoke this project. This way of invoking cmake command makes sure that wrong cmake is not invoked. It's recommended to use ${CMAKE_COMMAND} -E to call cmake provided commands. It's more platform independent. add_custom_target ( target1 ALL COMMAND ${ CMAKE_COMMAND } -E echo \"This is command 1\" COMMAND ${ CMAKE_COMMAND } -E echo \"This is command 2\" COMMAND ${ CMAKE_COMMAND } -E echo \"This is command 3\" ) Output This is command 1 This is command 2 This is command 3 DEPENDS argument will take one or more targets. This will always create a target level dependency. These targets will be built before the current target. add_custom_target ( target1 COMMAND ${ CMAKE_COMMAND } -E echo \"This is target1\" ) add_custom_target ( target2 COMMAND ${ CMAKE_COMMAND } -E echo \"This is target2\" ) add_custom_target ( target3 ALL COMMAND ${ CMAKE_COMMAND } -E echo \"This is target3\" DEPENDS target1 target2 ) Output This is target2 Built target target2 This is target1 Built target target1 This is target3 Built target target3 BYPRODUCTS are the list of files expected to be generated. These are marked as GENERATED . This tells CMake not to check for its existence at configure time, since it gets created as part of the build process. This is useful if you have targe which needs a GENERATED file from another custom target. CMake will not check the existence during configuration phase. WORKING_DIRECTORY is the directory where the commands are generated. If this option is not given, the commands will be run in ${CMAKE_CURRENT_BINARY_DIR} . COMMENT is the message which will be shown in the console before the targetName is built. JOB_POOL is optional and I have no clue what it is. SOURCES option has no role in the build process. Any files mentioned here will be shown in the IDE. If you have a custom command which copies some shader files to a specific path, you can add those files in the SOURCES. Then IDE will show the files in the project tree. Some header only libraries also use custom command to show the header files in the project set ( HEADER_BASE \"${CMAKE_CURRENT_SOURCE_DIR}/external/stringify\" ) file ( GLOB_RECURSE stringify_include_SRCS \"${HEADER_BASE}/*.hpp\" ) add_custom_target ( stringify_headers_for_ide SOURCES ${ stringify_include_SRCS } ) VERBATIM :","title":"add_custom_target"},{"location":"cmake/custom-command-and-custom-tasks/#example-1-copy-resource-files-after-build","text":"I have some vertex and fragment shader, which are in current source directory. . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 CoordinateSystem.cpp \u251c\u2500\u2500 CoordinateSystem.h \u251c\u2500\u2500 main.cpp \u2514\u2500\u2500 res \u251c\u2500\u2500 shader.frag \u2514\u2500\u2500 shader.vert I need to copy the resource files in res folder to the binary folder. set ( TARGET_NAME coordinate_system ) add_executable ( ${ TARGET_NAME } CoordinateSystem.cpp main.cpp ) target_link_libraries ( ${ TARGET_NAME } PRIVATE opengl-framework ) set ( RES_FILES \"${CMAKE_CURRENT_SOURCE_DIR}/res/shader.frag\" \"${CMAKE_CURRENT_SOURCE_DIR}/res/shader.vert\" ) add_custom_target ( ${ TARGET_NAME } _copy_resources ALL COMMAND ${ CMAKE_COMMAND } -E copy_if_different ${ RES_FILES } ${ CMAKE_CURRENT_BINARY_DIR } DEPENDS ${ TARGET_NAME } COMMENT \"Copying resource files for ${TARGET_NAME}\" SOURCES ${ RES_FILES } ) My custom command depends on the target(technically not :P ). ${CMAKE_COMMAND} is the cmake command which is used to invoke this project. In some projects, there are multiple versions of cmake. This way of invoking cmake command makes sure that wrong cmake is not invoked. -E is the option to invoke some predefined cmake command. You can get a list of cmake supported commands by --help option. \ue0a0 master \u25cf \ue0b0 cmake -E --help CMake Error: cmake version 3.13.5 Usage: cmake -E <command> [arguments...] Available commands: capabilities - Report capabilities built into cmake in JSON format chdir dir cmd [args...] - run command in a given directory .... .... blah blah It's recommended to use ${CMAKE_COMMAND} -E to call cmake provided commands. It's more platform independent. \ue0a0 master \u25cf \ue0b0 cmake -E --help CMake Error: cmake version 3.13.5 Usage: cmake -E <command> [arguments...] Available commands: capabilities - Report capabilities built into cmake in JSON format chdir dir cmd [args...] - run command in a given directory compare_files file1 file2 - check if file1 is same as file2 copy <file>... destination - copy files to destination (either file or directory) copy_directory <dir>... destination - copy content of <dir>... directories to 'destination' directory copy_if_different <file>... destination - copy files if it has changed echo [<string>...] - displays arguments as text .... .... blah blah copy_if_different uses the timestamp to check if the source files are changed. I have added explicit dependency with orginal target. What's point of copying the resource files if the binary build fails ? COMMENT text will be visible when you run the build. SOURCES will make the IDE show the resource files. Here the build log Scanning dependencies of target coordinate_system [ 88%] Building CXX object example/coordinate_system/CMakeFiles/coordinate_system.dir/CoordinateSystem.cpp.o [ 92%] Building CXX object example/coordinate_system/CMakeFiles/coordinate_system.dir/main.cpp.o [ 96%] Linking CXX executable coordinate_system [ 96%] Built target coordinate_system Scanning dependencies of target coordinate_system_copy_resources [100%] Copying resource files for coordinate_system [100%] Built target coordinate_system_copy_resources SOURCES will make the IDE show the resource files.","title":"Example 1: copy resource files after build"},{"location":"cmake/custom-command-and-custom-tasks/#add_custom_command","text":"Sometimes a custom target is a little over engineering, e.g. you need to run a small script for each binary generated. Instead you can add the additional rules when the target is built. add_custom_command serves this purpose. There are two kinds of custom command command to generate files: generates specified OUTPUT file(s) command which runs on build events","title":"add_custom_command"},{"location":"cmake/custom-command-and-custom-tasks/#generating-files","text":"add_custom_command ( OUTPUT output1 [output2 ...] COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [MAIN_DEPENDENCY depend] [DEPENDS [depends...]] [BYPRODUCTS [files...]] [IMPLICIT_DEPENDS <lang1> depend1 [<lang2> depend2] ...] [WORKING_DIRECTORY dir] [COMMENT comment] [DEPFILE depfile] [JOB_POOL job_pool] [VERBATIM] [APPEND] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] ) add_custom_command takes one or more output file names to be given after the OUTPUT keyword. The series of commands will be executed to generate that file. Custom commands are not executed on its own. If some other target has some dependency on the output file, then the custom command is invoked. add_custom_command generates file by running a one or more commands after the dependent target has been built. COMMAND, BYPRODUCTS, COMMENT and USES_TERMINAL options behave like add_custom_target. IMPLICIT_DEPENDS Request scanning of implicit dependencies of an input file. The language given specifies the programming language whose corresponding dependency scanner should be used. Currently only C and CXX language scanners are supported. The language has to be specified for every file in the IMPLICIT_DEPENDS list. Dependencies discovered from the scanning are added to those of the custom command at build time. Note that the IMPLICIT_DEPENDS option is currently supported only for Makefile generators and will be ignored by other generators.","title":"Generating Files"},{"location":"cmake/custom-command-and-custom-tasks/#depends","text":"If DEPENDS is missing, the custom command will be run when the OUTPUT is missing. If the custom command doesn't create any file, then this will run always. If any dependency is an OUTPUT of another custom command in the same directory (CMakeLists.txt file) CMake automatically brings the other custom command into the target in which this command is built. If the DEPENDS is the target of any add_executable, add_library or add_custom_target, a target level dependency is created.","title":"DEPENDS"},{"location":"cmake/custom-command-and-custom-tasks/#build-events","text":"add_custom_command ( TARGET <target> PRE_BUILD | PRE_LINK | POST_BUILD COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [VERBATIM] [USES_TERMINAL] ) This custom command will add additional rule to existing targets. The first argument is the target name, it should be specifiec before the command. The target should be created either by add_executable , add_library or add_custom__target . PRE_BUILD , PRE_LINK or POST_BUILD is the time when the command will run. PRE_BUILD :- The command will run before any other rules are executed within the target in case of Visual Studio. In other generators, it will behave like PRE_LINK . PRE_LINK :- The command will run after the compilation and before the linking. It's not supported for custom commands. POST_BUILD :- This will be run after the target is built. You can add any number of custom commands for a build. All other options are similar to add_custom_target. add_executable ( main main.cpp ) add_custom_command ( TARGET main PRE_BUILD COMMAND ${ CMAKE_COMMAND } -E echo \"This is pre build command\" COMMENT \"Custom command for pre build\" ) add_custom_command ( TARGET main PRE_LINK COMMAND ${ CMAKE_COMMAND } -E echo \"This is pre link command\" COMMENT \"Custom command for pre link\" ) add_custom_command ( TARGET main POST_BUILD COMMAND ${ CMAKE_COMMAND } -E echo \"This is post build command\" COMMENT \"Custom command for post build\" ) Output Custom command for pre build This is pre build command Custom command for pre build 2 This is pre build command 2 Custom command for pre link This is pre link command Custom command for post build This is post build command [100%] Built target main If the target is not rebuilt, custom command won't be executed.","title":"Build Events"},{"location":"cmake/custom-command-and-custom-tasks/#example-","text":"I have a benchmarking project where I need to execute all binaries and generate report. I want this to be fully integrated into the build system. add_executable ( fill fill.cpp ) target_link_libraries ( fill PRIVATE benchmark::benchmark benchmark::benchmark_main PRIVATE meta range-v3 ) add_custom_command ( TARGET fill POST_BUILD COMMAND ${ CMAKE_RUNTIME_OUTPUT_DIRECTORY } /fill \"--benchmark_format=json\" > ${ BENCHMARK_REPORT_DIRECTORY } /fill.json COMMENT \"Generating report for fill\" ) Output Scanning dependencies of target fill [ 12%] Building CXX object CMakeFiles/fill.dir/fill.cpp.o [ 25%] Linking CXX executable bin/fill Generating report for fill Here after the target fill is built, it will be executed to generate report. The entire source code can be found here CMakeLists.txt","title":"Example:-"},{"location":"cmake/functions-and-macros/","text":"Functions and Macros \u00b6 Cmake supports both functions and macros to provide a named abstraction for some repetative works. A functtion or macro always define a new command. Functions \u00b6 function ( <someName> [<arg1> ...] ) <commands> endfunction () where name is the name of the function, with arguments arg1, arg2, etc. Example function ( foo ) message ( \"I am foo!!\" ) endfunction () foo () FOO () fOO () Foo () I am foo!! I am foo!! I am foo!! I am foo!! Here the function name is case-insensitive . You can call in any case, but it's always recommended to use the same name declared in the function definition. Function Arguments \u00b6 A cmake function can take two types of arguments. named or keyword arguments optional arguments Named arguments are mandatory and will throw error if not provided. You don't need a comma between argument names. function ( fooKeyword country city ) message ( \"Address: ${country} ${city}\" ) endfunction () fooKeyword ( \"germany\" \"munich\" ) Output Address: germany munich Optional arguments can be accessed using some predefined variables. Variable Name Description ARGC Total number of arguments(named arguments + optional arguments) ARGV list of variables containing both named and optional arguments ARGN list of variables containing only optional arguments function ( foo name1 name2 ) message ( \"Argument count: ${ARGC}\" ) message ( \"all arguments: ${ARGV}\" ) message ( \"optional arguments: ${ARGN}\" ) endfunction () foo ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) message ( \"only named arguments\" ) foo ( \"harry\" \"potter\" ) # foo() #error Output Argument count: 4 all arguments: asit;dhal;India;Bhubaneswar optional arguments: India;Bhubaneswar only named arguments Argument count: 2 all arguments: harry;potter optional arguments: Other than those three variables, CMake also provides ARGV0, ARGV1, ARGV2, \u2026 which will have the actual values of the arguments passed in. Referencing to ARGV# arguments beyond ARGC will have undefined behavior. function ( foo name1 name2 ) if ( DEFINED ARGV0 ) message ( \"ARGV0 defined value=${ARGV0}\" ) else () message ( \"ARGV0 not defined\" ) endif () math ( EXPR lastIndex \"${ARGC}-1\" ) foreach ( index RANGE 0 ${ lastIndex } ) message ( \"arguments at index ${index}: ${ARGV${index}}\" ) endforeach () endfunction () foo ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) Output ARGV0 defined value=asit arguments at index 0: asit arguments at index 1: dhal arguments at index 2: India arguments at index 3: Bhubaneswar Usually, named arguments are accessed using the variable and optional arguments are accessed using ARGN. function ( foo firstName lastName ) message ( \"first name: ${firstName}\" ) message ( \"last name: ${lastName}\" ) foreach ( arg IN LISTS ARGN ) message ( \"address parts: ${arg}\" ) endforeach () endfunction () foo ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) Output first name: asit last name: dhal address parts: India address parts: Bhubaneswar Variable Scope \u00b6 CMake functions introduce new scopes, a variable modified inside the function won't be accessible outside the function. Another problem in CMake, the functions don't return any value. This will make the function difficult to use. So, CMake provides the keyword PARENT_SCOPE to set a variable in the parent scope. You can send variable name as a function parameter. The function will set the variable in the parent scope. set ( name \"Uttam Mohanty\" ) function ( set_name varName ) set ( ${ varName } \"Sriram Panda\" PARENT_SCOPE ) endfunction () message ( \"before call first name: ${name}\" ) set_name ( name ) message ( \"after call first name: ${name}\" ) Output before call first name: Uttam Mohanty after call first name: Sriram Panda This way of returning value from function is self documenting. But, it becomes repetative if the function has to return many values. So, many library functions explicitly document well known variables which are set by a function and you don't need to send any variable name as argument. In some projects, it's to common to have functions which set project specific variables in the parent scope. The cmake libraries provide FindPackageHandleStandardArgs function which sets a variable called Package_FOUND in the parent scope. find_package ( Git ) message ( \"Git found: ${GIT_FOUND}\" ) if ( Git_FOUND ) message ( \"Git executable: ${GIT_EXECUTABLE}\" ) message ( \"Git version: ${GIT_VERSION_STRING}\" ) endif () Output Git found: TRUE Git executable: /usr/bin/git Git version: 2.17.1 return() command \u00b6 You can call return() to exit a function early. function ( early_ret ) message ( \"one\" ) return () message ( \"two\" ) # won't be printed endfunction () early_ret () Output one Macros \u00b6 macro ( <name> [<arg1> ...] ) <commands> endmacro () where name is the name of the macro, with arguments arg1, arg2, etc. macro(foo_macro) message(\"I am a poor little macro!!\") endmacro() foo_macro() fOO_macro() Foo_Macro() FOO_MACRO() Output I am a poor little macro!! I am a poor little macro!! I am a poor little macro!! I am a poor little macro!! Like functions, macro names are also case insensitive. You can call in any case, but it's always recommended to use the same name declared in the macro definition. Macro Arguments \u00b6 Like functions, macros also take both named and positional arguments. macro ( foo_macro name1 name2 ) message ( \"Argument count: ${ARGC}\" ) message ( \"all arguments: ${ARGV}\" ) message ( \"optional arguments: ${ARGN}\" ) endmacro () foo_macro ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) message ( \"only named arguments\" ) foo_macro ( \"harry\" \"potter\" ) #foo_macro() #error Output Argument count: 4 all arguments: asit;dhal;India;Bhubaneswar optional arguments: India;Bhubaneswar only named arguments Argument count: 2 all arguments: harry;potter optional arguments: Functions always introduce a new scope when called. In case of macro, the macro call is substituted with the macro body and arguments are replaced using string substitution. No new scope is created. So both functions and macros behave differently in some cases. Using the DEFINED keyword, you can check if a variable, cache variable or environment variable with given is defined. The value of the variable does not matter. macro ( foo_macro name ) if ( DEFINED name ) message ( \"macro argument name is defined\" ) else () message ( \"macro argument name is not defined\" ) endif () endmacro () function ( foo_func name ) if ( DEFINED name ) message ( \"func argument name is defined\" ) else () message ( \"func argument name is not defined\" ) endif () endfunction () foo_macro ( \"asit\" ) foo_func ( \"asit\" ) Output macro argument name is not defined func argument name is defined Macros show strange behavior while using the three special variables(in some cases). Variable Scope \u00b6 Unlike functions, macro introduce no new scope. The variables declared inside the macro(other than the arguments) will be available after the call. set ( name \"asit\" ) macro ( foo_macro macro_arg1 ) message ( \"macro arg: ${macro_arg1}\" ) message ( \"macro name: ${name}\" ) set ( middle_name \"kumar\" ) set ( name \"ASIT\" ) message ( \"micro middle name: ${middle_name}\" ) endmacro () foo_macro ( \"bhubaneswar\" ) message ( \"after macro call name: ${name}\" ) message ( \"after micro call middle name: ${middle_name}\" ) Output macro arg: bhubaneswar macro name: asit micro middle name: kumar after macro call name: ASIT after micro call middle name: kumar return() command \u00b6 Since, micro doesn't create any new scope, return() will exit the current scope. macro ( early_ret ) message ( \"one\" ) return () message ( \"two\" ) # won't be printed endmacro () message ( \"before\" ) early_ret () message ( \"will never be executed\" ) Output before one Redefining Functions and Macros \u00b6 When function() or macro() is defined and if a command already exists with that name, the previous command will be overridden. The previous command can be accessed using the name and an underscore prepended. function ( good_func ) message ( \"first definition of good_func\" ) endfunction () function ( good_func ) message ( \"second definition of good_func\" ) endfunction () good_func () _good_func () Output second definition of good_func first definition of good_func If the same function is redefined again, the underscore version will call previously defined function. The original function will never be available. function ( good_func ) message ( \"first definition of good_func\" ) endfunction () function ( good_func ) message ( \"second definition of good_func\" ) endfunction () function ( good_func ) message ( \"third definition of good_func\" ) endfunction () good_func () _good_func () Output third definition of good_func second definition of good_func It has two problems. If a developer writes a function without knowing that the name is already used for some cmake library functions, then there are chances that the original function will be hidden forever. There are some developers who use this feature(or a bug) to add behavior to an existing function. If you do it more than twice, it can cause infinite recursion. It's difficult to debug when the function definition spans across many modules. function ( good_func ) message ( \"first definition of good_func\" ) endfunction () function ( good_func ) # second redefinition message ( \"second definition of good_func\" ) _good_func () endfunction () function ( good_func ) message ( \"third definition of good_func\" ) _good_func () endfunction () good_func () Output second definition of good_func second definition of good_func second definition of good_func second definition of good_func ...... .... The desired behavior is that 2nd redefinition will call the original function. But, in this scope, the 2nd redefinition is always the underscore version. CMakeParseArguments \u00b6 CMake has a predefined command to parse function and macro arguments. This command is for use in macros or functions. It processes the arguments given to that macro or function, and defines a set of variables which hold the values of the respective options. cmake_parse_arguments ( <prefix> <options> <one_value_keywords> <multi_value_keywords> <args>... ) cmake_parse_arguments ( PARSE_ARGV <N> <prefix> <options> <one_value_keywords> <multi_value_keywords> ) The first version can be used both in functions and macros. The 2nd version( PARSE_ARGV ) can only be used in functions. In this case the arguments that are parsed come from the ARGV# variables of the calling function. The parsing starts with the <N> th argument, where <N> is an unsigned integer. This allows for the values to have special characters like ; in them. prefix : a prefix string which will preceed all variable names. options : all options for the respective macro/function, i.e. keywords which can be used when calling the macro without any value following. These are the variables if passed will be set as TRUE, else FALSE. one_value_keywords : all keywords for this macro or funtion which are followed by one value, e.g. DESTINATION=/usr/lib multi_value_keywords : all keywords for this macro/function which can be followed by more than one value, like e.g. FILES=test.cpp;main.cpp All remaining arguments are collected in a variable <prefix>_UNPARSED_ARGUMENTS that will be undefined if all arguments were recognized. This can be checked afterwards to see whether your macro was called with unrecognized parameters. function ( demo_func ) set ( prefix DEMO ) set ( flags IS_ASCII IS_UNICODE ) set ( singleValues TARGET ) set ( multiValues SOURCES RES ) include ( CMakeParseArguments ) cmake_parse_arguments ( ${ prefix } \"${flags}\" \"${singleValues}\" \"${multiValues}\" ${ ARGN } ) message ( \" DEMO_IS_ASCII: ${DEMO_IS_ASCII}\" ) message ( \" DEMO_IS_UNICODE: ${DEMO_IS_UNICODE}\" ) message ( \" DEMO_TARGET: ${DEMO_TARGET}\" ) message ( \" DEMO_SOURCES: ${DEMO_SOURCES}\" ) message ( \" DEMO_RES: ${DEMO_RES}\" ) message ( \" DEMO_UNPARSED_ARGUMENTS: ${DEMO_UNPARSED_ARGUMENTS}\" ) endfunction () message ( \"test 1\" ) demo_func ( SOURCES test.cpp main.cpp TARGET mainApp IS_ASCII config DEBUG ) message ( \"test 2\" ) demo_func ( TARGET mainApp.so RES test.png cat.png bull.png IS_UNICODE config RELEASE ) Output test 1 DEMO_IS_ASCII: TRUE DEMO_IS_UNICODE: FALSE DEMO_TARGET: mainApp DEMO_SOURCES: test.cpp;main.cpp DEMO_RES: DEMO_UNPARSED_ARGUMENTS: config;DEBUG test 2 DEMO_IS_ASCII: FALSE DEMO_IS_UNICODE: TRUE DEMO_TARGET: mainApp.so DEMO_SOURCES: DEMO_RES: test.png;cat.png;bull.png DEMO_UNPARSED_ARGUMENTS: config;RELEASE The above example with PARSE_ARGV version function ( demo_func project_name project_type ) set ( prefix DEMO ) set ( flags IS_ASCII IS_UNICODE ) set ( singleValues TARGET ) set ( multiValues SOURCES RES ) include ( CMakeParseArguments ) cmake_parse_arguments ( PARSE_ARGV 2 ${ prefix } \"${flags}\" \"${singleValues}\" \"${multiValues}\" ) message ( \" DEMO_IS_ASCII: ${DEMO_IS_ASCII}\" ) message ( \" DEMO_IS_UNICODE: ${DEMO_IS_UNICODE}\" ) message ( \" DEMO_TARGET: ${DEMO_TARGET}\" ) message ( \" DEMO_SOURCES: ${DEMO_SOURCES}\" ) message ( \" DEMO_RES: ${DEMO_RES}\" ) message ( \" named arg project_name: ${project_name}\" ) message ( \" named arg project_type: ${project_type}\" ) endfunction () message ( \"test 1\" ) demo_func ( \"main_gen\" \"gen\" SOURCES test.cpp main.cpp TARGET mainApp IS_ASCII ) message ( \"test 2\" ) demo_func ( \"main_test\" \"unit test\" TARGET mainApp.so RES test.png cat.png bull.png IS_UNICODE ) Output test 1 DEMO_IS_ASCII: TRUE DEMO_IS_UNICODE: FALSE DEMO_TARGET: mainApp DEMO_SOURCES: test.cpp;main.cpp DEMO_RES: named arg project_name: main_gen named arg project_type: gen test 2 DEMO_IS_ASCII: FALSE DEMO_IS_UNICODE: TRUE DEMO_TARGET: mainApp.so DEMO_SOURCES: DEMO_RES: test.png;cat.png;bull.png named arg project_name: main_test named arg project_type: unit test","title":"Cmake Functions and Macros"},{"location":"cmake/functions-and-macros/#functions-and-macros","text":"Cmake supports both functions and macros to provide a named abstraction for some repetative works. A functtion or macro always define a new command.","title":"Functions and Macros"},{"location":"cmake/functions-and-macros/#functions","text":"function ( <someName> [<arg1> ...] ) <commands> endfunction () where name is the name of the function, with arguments arg1, arg2, etc. Example function ( foo ) message ( \"I am foo!!\" ) endfunction () foo () FOO () fOO () Foo () I am foo!! I am foo!! I am foo!! I am foo!! Here the function name is case-insensitive . You can call in any case, but it's always recommended to use the same name declared in the function definition.","title":"Functions"},{"location":"cmake/functions-and-macros/#function-arguments","text":"A cmake function can take two types of arguments. named or keyword arguments optional arguments Named arguments are mandatory and will throw error if not provided. You don't need a comma between argument names. function ( fooKeyword country city ) message ( \"Address: ${country} ${city}\" ) endfunction () fooKeyword ( \"germany\" \"munich\" ) Output Address: germany munich Optional arguments can be accessed using some predefined variables. Variable Name Description ARGC Total number of arguments(named arguments + optional arguments) ARGV list of variables containing both named and optional arguments ARGN list of variables containing only optional arguments function ( foo name1 name2 ) message ( \"Argument count: ${ARGC}\" ) message ( \"all arguments: ${ARGV}\" ) message ( \"optional arguments: ${ARGN}\" ) endfunction () foo ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) message ( \"only named arguments\" ) foo ( \"harry\" \"potter\" ) # foo() #error Output Argument count: 4 all arguments: asit;dhal;India;Bhubaneswar optional arguments: India;Bhubaneswar only named arguments Argument count: 2 all arguments: harry;potter optional arguments: Other than those three variables, CMake also provides ARGV0, ARGV1, ARGV2, \u2026 which will have the actual values of the arguments passed in. Referencing to ARGV# arguments beyond ARGC will have undefined behavior. function ( foo name1 name2 ) if ( DEFINED ARGV0 ) message ( \"ARGV0 defined value=${ARGV0}\" ) else () message ( \"ARGV0 not defined\" ) endif () math ( EXPR lastIndex \"${ARGC}-1\" ) foreach ( index RANGE 0 ${ lastIndex } ) message ( \"arguments at index ${index}: ${ARGV${index}}\" ) endforeach () endfunction () foo ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) Output ARGV0 defined value=asit arguments at index 0: asit arguments at index 1: dhal arguments at index 2: India arguments at index 3: Bhubaneswar Usually, named arguments are accessed using the variable and optional arguments are accessed using ARGN. function ( foo firstName lastName ) message ( \"first name: ${firstName}\" ) message ( \"last name: ${lastName}\" ) foreach ( arg IN LISTS ARGN ) message ( \"address parts: ${arg}\" ) endforeach () endfunction () foo ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) Output first name: asit last name: dhal address parts: India address parts: Bhubaneswar","title":"Function Arguments"},{"location":"cmake/functions-and-macros/#variable-scope","text":"CMake functions introduce new scopes, a variable modified inside the function won't be accessible outside the function. Another problem in CMake, the functions don't return any value. This will make the function difficult to use. So, CMake provides the keyword PARENT_SCOPE to set a variable in the parent scope. You can send variable name as a function parameter. The function will set the variable in the parent scope. set ( name \"Uttam Mohanty\" ) function ( set_name varName ) set ( ${ varName } \"Sriram Panda\" PARENT_SCOPE ) endfunction () message ( \"before call first name: ${name}\" ) set_name ( name ) message ( \"after call first name: ${name}\" ) Output before call first name: Uttam Mohanty after call first name: Sriram Panda This way of returning value from function is self documenting. But, it becomes repetative if the function has to return many values. So, many library functions explicitly document well known variables which are set by a function and you don't need to send any variable name as argument. In some projects, it's to common to have functions which set project specific variables in the parent scope. The cmake libraries provide FindPackageHandleStandardArgs function which sets a variable called Package_FOUND in the parent scope. find_package ( Git ) message ( \"Git found: ${GIT_FOUND}\" ) if ( Git_FOUND ) message ( \"Git executable: ${GIT_EXECUTABLE}\" ) message ( \"Git version: ${GIT_VERSION_STRING}\" ) endif () Output Git found: TRUE Git executable: /usr/bin/git Git version: 2.17.1","title":"Variable Scope"},{"location":"cmake/functions-and-macros/#return-command","text":"You can call return() to exit a function early. function ( early_ret ) message ( \"one\" ) return () message ( \"two\" ) # won't be printed endfunction () early_ret () Output one","title":"return() command"},{"location":"cmake/functions-and-macros/#macros","text":"macro ( <name> [<arg1> ...] ) <commands> endmacro () where name is the name of the macro, with arguments arg1, arg2, etc. macro(foo_macro) message(\"I am a poor little macro!!\") endmacro() foo_macro() fOO_macro() Foo_Macro() FOO_MACRO() Output I am a poor little macro!! I am a poor little macro!! I am a poor little macro!! I am a poor little macro!! Like functions, macro names are also case insensitive. You can call in any case, but it's always recommended to use the same name declared in the macro definition.","title":"Macros"},{"location":"cmake/functions-and-macros/#macro-arguments","text":"Like functions, macros also take both named and positional arguments. macro ( foo_macro name1 name2 ) message ( \"Argument count: ${ARGC}\" ) message ( \"all arguments: ${ARGV}\" ) message ( \"optional arguments: ${ARGN}\" ) endmacro () foo_macro ( \"asit\" \"dhal\" \"India\" \"Bhubaneswar\" ) message ( \"only named arguments\" ) foo_macro ( \"harry\" \"potter\" ) #foo_macro() #error Output Argument count: 4 all arguments: asit;dhal;India;Bhubaneswar optional arguments: India;Bhubaneswar only named arguments Argument count: 2 all arguments: harry;potter optional arguments: Functions always introduce a new scope when called. In case of macro, the macro call is substituted with the macro body and arguments are replaced using string substitution. No new scope is created. So both functions and macros behave differently in some cases. Using the DEFINED keyword, you can check if a variable, cache variable or environment variable with given is defined. The value of the variable does not matter. macro ( foo_macro name ) if ( DEFINED name ) message ( \"macro argument name is defined\" ) else () message ( \"macro argument name is not defined\" ) endif () endmacro () function ( foo_func name ) if ( DEFINED name ) message ( \"func argument name is defined\" ) else () message ( \"func argument name is not defined\" ) endif () endfunction () foo_macro ( \"asit\" ) foo_func ( \"asit\" ) Output macro argument name is not defined func argument name is defined Macros show strange behavior while using the three special variables(in some cases).","title":"Macro Arguments"},{"location":"cmake/functions-and-macros/#variable-scope_1","text":"Unlike functions, macro introduce no new scope. The variables declared inside the macro(other than the arguments) will be available after the call. set ( name \"asit\" ) macro ( foo_macro macro_arg1 ) message ( \"macro arg: ${macro_arg1}\" ) message ( \"macro name: ${name}\" ) set ( middle_name \"kumar\" ) set ( name \"ASIT\" ) message ( \"micro middle name: ${middle_name}\" ) endmacro () foo_macro ( \"bhubaneswar\" ) message ( \"after macro call name: ${name}\" ) message ( \"after micro call middle name: ${middle_name}\" ) Output macro arg: bhubaneswar macro name: asit micro middle name: kumar after macro call name: ASIT after micro call middle name: kumar","title":"Variable Scope"},{"location":"cmake/functions-and-macros/#return-command_1","text":"Since, micro doesn't create any new scope, return() will exit the current scope. macro ( early_ret ) message ( \"one\" ) return () message ( \"two\" ) # won't be printed endmacro () message ( \"before\" ) early_ret () message ( \"will never be executed\" ) Output before one","title":"return() command"},{"location":"cmake/functions-and-macros/#redefining-functions-and-macros","text":"When function() or macro() is defined and if a command already exists with that name, the previous command will be overridden. The previous command can be accessed using the name and an underscore prepended. function ( good_func ) message ( \"first definition of good_func\" ) endfunction () function ( good_func ) message ( \"second definition of good_func\" ) endfunction () good_func () _good_func () Output second definition of good_func first definition of good_func If the same function is redefined again, the underscore version will call previously defined function. The original function will never be available. function ( good_func ) message ( \"first definition of good_func\" ) endfunction () function ( good_func ) message ( \"second definition of good_func\" ) endfunction () function ( good_func ) message ( \"third definition of good_func\" ) endfunction () good_func () _good_func () Output third definition of good_func second definition of good_func It has two problems. If a developer writes a function without knowing that the name is already used for some cmake library functions, then there are chances that the original function will be hidden forever. There are some developers who use this feature(or a bug) to add behavior to an existing function. If you do it more than twice, it can cause infinite recursion. It's difficult to debug when the function definition spans across many modules. function ( good_func ) message ( \"first definition of good_func\" ) endfunction () function ( good_func ) # second redefinition message ( \"second definition of good_func\" ) _good_func () endfunction () function ( good_func ) message ( \"third definition of good_func\" ) _good_func () endfunction () good_func () Output second definition of good_func second definition of good_func second definition of good_func second definition of good_func ...... .... The desired behavior is that 2nd redefinition will call the original function. But, in this scope, the 2nd redefinition is always the underscore version.","title":"Redefining Functions and Macros"},{"location":"cmake/functions-and-macros/#cmakeparsearguments","text":"CMake has a predefined command to parse function and macro arguments. This command is for use in macros or functions. It processes the arguments given to that macro or function, and defines a set of variables which hold the values of the respective options. cmake_parse_arguments ( <prefix> <options> <one_value_keywords> <multi_value_keywords> <args>... ) cmake_parse_arguments ( PARSE_ARGV <N> <prefix> <options> <one_value_keywords> <multi_value_keywords> ) The first version can be used both in functions and macros. The 2nd version( PARSE_ARGV ) can only be used in functions. In this case the arguments that are parsed come from the ARGV# variables of the calling function. The parsing starts with the <N> th argument, where <N> is an unsigned integer. This allows for the values to have special characters like ; in them. prefix : a prefix string which will preceed all variable names. options : all options for the respective macro/function, i.e. keywords which can be used when calling the macro without any value following. These are the variables if passed will be set as TRUE, else FALSE. one_value_keywords : all keywords for this macro or funtion which are followed by one value, e.g. DESTINATION=/usr/lib multi_value_keywords : all keywords for this macro/function which can be followed by more than one value, like e.g. FILES=test.cpp;main.cpp All remaining arguments are collected in a variable <prefix>_UNPARSED_ARGUMENTS that will be undefined if all arguments were recognized. This can be checked afterwards to see whether your macro was called with unrecognized parameters. function ( demo_func ) set ( prefix DEMO ) set ( flags IS_ASCII IS_UNICODE ) set ( singleValues TARGET ) set ( multiValues SOURCES RES ) include ( CMakeParseArguments ) cmake_parse_arguments ( ${ prefix } \"${flags}\" \"${singleValues}\" \"${multiValues}\" ${ ARGN } ) message ( \" DEMO_IS_ASCII: ${DEMO_IS_ASCII}\" ) message ( \" DEMO_IS_UNICODE: ${DEMO_IS_UNICODE}\" ) message ( \" DEMO_TARGET: ${DEMO_TARGET}\" ) message ( \" DEMO_SOURCES: ${DEMO_SOURCES}\" ) message ( \" DEMO_RES: ${DEMO_RES}\" ) message ( \" DEMO_UNPARSED_ARGUMENTS: ${DEMO_UNPARSED_ARGUMENTS}\" ) endfunction () message ( \"test 1\" ) demo_func ( SOURCES test.cpp main.cpp TARGET mainApp IS_ASCII config DEBUG ) message ( \"test 2\" ) demo_func ( TARGET mainApp.so RES test.png cat.png bull.png IS_UNICODE config RELEASE ) Output test 1 DEMO_IS_ASCII: TRUE DEMO_IS_UNICODE: FALSE DEMO_TARGET: mainApp DEMO_SOURCES: test.cpp;main.cpp DEMO_RES: DEMO_UNPARSED_ARGUMENTS: config;DEBUG test 2 DEMO_IS_ASCII: FALSE DEMO_IS_UNICODE: TRUE DEMO_TARGET: mainApp.so DEMO_SOURCES: DEMO_RES: test.png;cat.png;bull.png DEMO_UNPARSED_ARGUMENTS: config;RELEASE The above example with PARSE_ARGV version function ( demo_func project_name project_type ) set ( prefix DEMO ) set ( flags IS_ASCII IS_UNICODE ) set ( singleValues TARGET ) set ( multiValues SOURCES RES ) include ( CMakeParseArguments ) cmake_parse_arguments ( PARSE_ARGV 2 ${ prefix } \"${flags}\" \"${singleValues}\" \"${multiValues}\" ) message ( \" DEMO_IS_ASCII: ${DEMO_IS_ASCII}\" ) message ( \" DEMO_IS_UNICODE: ${DEMO_IS_UNICODE}\" ) message ( \" DEMO_TARGET: ${DEMO_TARGET}\" ) message ( \" DEMO_SOURCES: ${DEMO_SOURCES}\" ) message ( \" DEMO_RES: ${DEMO_RES}\" ) message ( \" named arg project_name: ${project_name}\" ) message ( \" named arg project_type: ${project_type}\" ) endfunction () message ( \"test 1\" ) demo_func ( \"main_gen\" \"gen\" SOURCES test.cpp main.cpp TARGET mainApp IS_ASCII ) message ( \"test 2\" ) demo_func ( \"main_test\" \"unit test\" TARGET mainApp.so RES test.png cat.png bull.png IS_UNICODE ) Output test 1 DEMO_IS_ASCII: TRUE DEMO_IS_UNICODE: FALSE DEMO_TARGET: mainApp DEMO_SOURCES: test.cpp;main.cpp DEMO_RES: named arg project_name: main_gen named arg project_type: gen test 2 DEMO_IS_ASCII: FALSE DEMO_IS_UNICODE: TRUE DEMO_TARGET: mainApp.so DEMO_SOURCES: DEMO_RES: test.png;cat.png;bull.png named arg project_name: main_test named arg project_type: unit test","title":"CMakeParseArguments"},{"location":"cmake/properties/","text":"CMake properties \u00b6 In CMake, properties are some named values associated with some objects like files, directories, targets, etc. E.g a target has a property of output name. Properties can be both set and get by using predefined commands. Properties are always associated with some object. CMake provides many command to manipulate properties. Generic Properties \u00b6 get_property ( <variable> <GLOBAL | DIRECTORY [<dir>] | TARGET <target> | SOURCE <source> | INSTALL <file> | TEST <test> | CACHE <entry> | VARIABLE > PROPERTY <name> [SET | DEFINED | BRIEF_DOCS | FULL_DOCS] ) get_property can be used to get one property of an object. <variable> : will hold the fetched value. The second argument is called scope in CMake terms. GLOBAL scope is unique, DIRECTORY default scope is current directory or a user has to provide a directory path. TARGET is one of the targets. SOURCE is one source file. INSTALL is one installed path. TEST scope must name one existing test. CACHE scope must name one cache entry. VARIABLE scope is unique and does not accept a name. It's usually the variables available in the current scope. <name> : name of the property. If not available in that scope, it will get from the parent scope( in some cases ). The fourth argument is optional. It fetches the information about the property. SET will return TRUE if the property is set. DEFINED will return TRUE if the property is defined using define_property() command. The BRIEF_DOCS or FULL_DOCS will return a string containing the documentation of the requested property. If documentation is requested for a property that has not been defined NOTFOUND is returned. If none of these options are provided, the value of the property is fetched. add_executable ( main main.cpp ) # global get_property ( prop1_value GLOBAL PROPERTY ENABLED_LANGUAGES ) get_property ( prop1_is_set GLOBAL PROPERTY ENABLED_LANGUAGES SET ) message ( \"ENABLED_LANGUAGES: ${prop1_value}\" ) message ( \"ENABLED_LANGUAGES is set: ${prop1_is_set}\" ) # dir get_property ( binary_dir_value DIRECTORY PROPERTY BINARY_DIR ) message ( \"BINARY_DIR: ${binary_dir_value}\" ) # target get_property ( target_name TARGET main PROPERTY SOURCES ) message ( \"SOURCES: ${target_name}\" ) In the above example a target called name is defined which has one source main.cpp. Output ENABLED_LANGUAGES: C;CXX ENABLED_LANGUAGES is set: 1 BINARY_DIR: /tmp/QtCreator-Zazvlo/qtc-cmake-MSxwSnMV SOURCES: main.cpp set_property ( <GLOBAL | DIRECTORY [<dir>] | TARGET [<target1> ...] | SOURCE [<src1> ...] | INSTALL [<file1> ...] | TEST [<test1> ...] | CACHE [<entry1> ...] > [APPEND] [APPEND_STRING] PROPERTY <name> [value1 ...] ) set_property sets property on one or more objects. The first argument is scope, which is similar to get_property. The 3rd argument <name> is the name of the property. The last argument is the value(s) to be set. In case of multiple values, ; is used to specify that its a list. The 2nd argument is bit tricky. If nothing is specified, the value will override the old value, else APPEND will append the new value and APPEND_STRING will append the new values considering it a string.","title":"CMake properties"},{"location":"cmake/properties/#cmake-properties","text":"In CMake, properties are some named values associated with some objects like files, directories, targets, etc. E.g a target has a property of output name. Properties can be both set and get by using predefined commands. Properties are always associated with some object. CMake provides many command to manipulate properties.","title":"CMake properties"},{"location":"cmake/properties/#generic-properties","text":"get_property ( <variable> <GLOBAL | DIRECTORY [<dir>] | TARGET <target> | SOURCE <source> | INSTALL <file> | TEST <test> | CACHE <entry> | VARIABLE > PROPERTY <name> [SET | DEFINED | BRIEF_DOCS | FULL_DOCS] ) get_property can be used to get one property of an object. <variable> : will hold the fetched value. The second argument is called scope in CMake terms. GLOBAL scope is unique, DIRECTORY default scope is current directory or a user has to provide a directory path. TARGET is one of the targets. SOURCE is one source file. INSTALL is one installed path. TEST scope must name one existing test. CACHE scope must name one cache entry. VARIABLE scope is unique and does not accept a name. It's usually the variables available in the current scope. <name> : name of the property. If not available in that scope, it will get from the parent scope( in some cases ). The fourth argument is optional. It fetches the information about the property. SET will return TRUE if the property is set. DEFINED will return TRUE if the property is defined using define_property() command. The BRIEF_DOCS or FULL_DOCS will return a string containing the documentation of the requested property. If documentation is requested for a property that has not been defined NOTFOUND is returned. If none of these options are provided, the value of the property is fetched. add_executable ( main main.cpp ) # global get_property ( prop1_value GLOBAL PROPERTY ENABLED_LANGUAGES ) get_property ( prop1_is_set GLOBAL PROPERTY ENABLED_LANGUAGES SET ) message ( \"ENABLED_LANGUAGES: ${prop1_value}\" ) message ( \"ENABLED_LANGUAGES is set: ${prop1_is_set}\" ) # dir get_property ( binary_dir_value DIRECTORY PROPERTY BINARY_DIR ) message ( \"BINARY_DIR: ${binary_dir_value}\" ) # target get_property ( target_name TARGET main PROPERTY SOURCES ) message ( \"SOURCES: ${target_name}\" ) In the above example a target called name is defined which has one source main.cpp. Output ENABLED_LANGUAGES: C;CXX ENABLED_LANGUAGES is set: 1 BINARY_DIR: /tmp/QtCreator-Zazvlo/qtc-cmake-MSxwSnMV SOURCES: main.cpp set_property ( <GLOBAL | DIRECTORY [<dir>] | TARGET [<target1> ...] | SOURCE [<src1> ...] | INSTALL [<file1> ...] | TEST [<test1> ...] | CACHE [<entry1> ...] > [APPEND] [APPEND_STRING] PROPERTY <name> [value1 ...] ) set_property sets property on one or more objects. The first argument is scope, which is similar to get_property. The 3rd argument <name> is the name of the property. The last argument is the value(s) to be set. In case of multiple values, ; is used to specify that its a list. The 2nd argument is bit tricky. If nothing is specified, the value will override the old value, else APPEND will append the new value and APPEND_STRING will append the new values considering it a string.","title":"Generic Properties"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/","text":"Range algorithms in less than an hour \u00b6 This post is a note about 179 range algorithms in less than an hour by Dvir Yitzchaki presented in Core C++ 2019. Motivation \u00b6 Primary motivation for ranges is to provide a simpler syntax for calling algorithims. In good old pre C++20 or without range-v3, std :: vector < int > v { 10 , 2 , 96 }; std :: sort ( v . begin (), v . end ()); In C++20 or with range-v3 library std :: ranges :: sort ( v ); Allowing algorithms to take a single range object instead of separate begin and end iterators opens the door torange adaptors which lazily transform or filter their underlying sequence in interesting ways, like accumulate ( view :: iota ( 1 ) | view :: transform ([]( int x ) { return x * x ;}) | view :: take ( 10 ), 0 ); Range \u00b6 Ranges are an abstraction over Iterators. Range is basically anything that has a begin() and an end(), both begin() returns an iterator and end() returns a sentinel. Range is a sequence of elements between two locations i,k, often denoted by [i, k) . In standard library, a range is a pair of iterators, usually a begin and an end iterator. std :: copy ( v . begin (), v . end (), buf ); Range can also be an iterator and count of elements. std :: copy_n ( v . begin (), 20 , buf ); Range can also be an iterator and a possiby stateful predicate that indicates when a range is exhausted. std :: copy ( std :: istream_iterator < int > { std :: cin }, std :: istream_iterator < int > {}, buf ); Iterator Concepts \u00b6 Iterator : can be derefenced( *it ) and incremented( it++ ). iterator InputIterator : referenced values can be read ( auto v = *it ). input iterator OutputIterator - referenced values can be written to ( *it = v ). output iterator ForwardIterator - Input Iterator + comparable and multi-pass. forward iterator . BidirectionalI terator - Forward Iterator + decrementable ( --it ). bidirectional iterator Random Access Iterator - Bidirectional Iterator + random access ( it += n ) random access iterator Contiguous Iterator - Random Access Iterator + contiguous in memory Sentinels \u00b6 From C++ standard document n4382 A sentinel is an abstraction of a past-the-end iterator. Sentinels are Regular types that can be used to denote the end of a range. A sentinel and an iterator denoting a range shall be EqualityComparable. A sentinel denotes an element when an iterator i compares equal to the sentinel, and i points to that element. You can detect the end of a range in two ways. by testing the iterator itself(past-the-end) by testing the data value at the iterator By allowing the type of the end iterator to differ from begin we: Give the optimizer more context, resulting in better codegen Make it easier to write correct iterators. Range Concepts \u00b6 Range is a type that allows iteration over its elements by providing an iterator and a sentinel that denote the elements of the range. ranges::begin : returns an iterator ranges::end : returns a sentinel Counted range provides an Iterator and a count. Input Range - e.g. Range over a std::istream_iterator Output Range - e.g. Range over a std::ostream_iterator Forward Range - e.g. std::forward_list Bidirectional Range - e.g. std::list Random Access Range - e.g. std::deque Contiguous Range - sentinel is of same type of iterator, e.g. std::vector Sized ranges \u00b6 Sized Sentinel - a Sentinel whose distance can be computed using the - operator in constant time. SizedRange - a Range type that knows its size in constant time with the ranges::size function. Not necessarily implies Size Sentinel (std::list) ranges::distance can compute the distant of any range but has linear complexity for non sized ranges/sentinels ranges::data gives a pointer to the data of a contiguous range Projections \u00b6 Projections allow you give a lambda or invocable that transforms the data on the fly while the algorihim is operating on data. It basically transforms the input sequence. Difference between Rangle algorithims and classic stl algorithims \u00b6 Accept either a Range object an Iterator+Sentinel pair an Iterator and a count ( _n ) Accept projections Some return type changes No Parallel overloads Views: Pipelines of lazy computation \u00b6 View is a range type that has constant time copy, move, and assignment operators. e.g. A range type that wraps a pair of iterators. A range type that holds its elements by shared_ptr and shares ownership with all its copies. A range type that generates its elements on demand. most containers are not views. int main () { std :: vector < int > is = ranges :: view :: iota ( 0 , 10 ); auto is_even = []( int i ) { return i % 2 == 0 ; }; for ( int i : is | ranges :: view :: filter ( is_even )) std :: cout << i << \" \" ; } view are implicitly converted to stl containers. Factoris & Adaptors \u00b6 For each view, the library defines a utility object called an adaptor (if it transforms an existing range) or a factory (otherwise), which creates such a view. Adapted views are lazy, which means they generate their elements only on demand, when the resulting adapted range is iterated. For this reason, there can be views with infinitely many elements Generators \u00b6 fill, fill_n \u00b6 #include <range/v3/core.hpp> #include <range/v3/algorithm/fill.hpp> #include <range/v3/algorithm/fill_n.hpp> #include <iostream> #include <vector> #include <algorithm> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; std :: fill ( v . begin (), v . end (), - 1 ); std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: fill ( v . begin (), v . end (), 10 ); std :: cout << \"v after std::fill(10): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: fill_n ( v . begin (), 3 , - 2 ); std :: cout << \"v after std::fill_n(3, -2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; ranges :: fill ( v , 6 ); std :: cout << \"v after ranges::fill(6): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; ranges :: fill_n ( v . begin (), 3 , 12 ); std :: cout << \"v after ranges::fill_n(3, -2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output v: -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, v after std::fill(10): 10,10,10,10,10,10,10,10,10,10, v after std::fill_n(3, -2): -2,-2,-2,10,10,10,10,10,10,10, v after ranges::fill(6): 6,6,6,6,6,6,6,6,6,6, v after ranges::fill_n(3, -2): 12,12,12,6,6,6,6,6,6,6, Just notice the difference for fill_n, both std::fill_n and ranges::fill_n have very similar sytaxes. iota \u00b6 #include <range/v3/core.hpp> #include <range/v3/numeric/iota.hpp> #include <iostream> #include <list> #include <algorithm> #include <numeric> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: list < int > l ( 10 ); std :: iota ( l . begin (), l . end (), - 4 ); std :: cout << \"l after std::iota(-4): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; ranges :: iota ( l , 6 ); std :: cout << \"l after ranges::iota(6): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output l after std::iota(-4): -4,-3,-2,-1,0,1,2,3,4,5, l after ranges::iota(6): 6,7,8,9,10,11,12,13,14,15, generate and generate_n \u00b6 #include <range/v3/core.hpp> #include <range/v3/algorithm/generate.hpp> #include <range/v3/algorithm/generate_n.hpp> #include <iostream> #include <vector> #include <algorithm> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v ( 5 ); std :: generate ( v . begin (), v . end (), [ n = 0 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 5 ); std :: generate_n ( v . begin (), 2 , [ n = 20 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate_n(2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 5 ); ranges :: generate ( v , [ n = 10 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 10 ); ranges :: generate_n ( v . begin (), 3 , [ n = 15 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate_n(3): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output v std::generate: 0,1,2,3,4, v std::generate_n(2): 20,21,0,0,0, v ranges::generate: 10,11,12,13,14, v ranges::generate_n(3): 15,16,17,0,0,0,0,0,0,0, Permutations \u00b6 reverse and reverse_copy \u00b6 #include <range/v3/core.hpp> #include <range/v3/algorithm/reverse.hpp> #include <range/v3/algorithm/reverse_copy.hpp> #include <iostream> #include <vector> #include <algorithm> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 1 , 2 , 3 }; std :: reverse ( v . begin (), v . end ()); std :: cout << \"v std::reverse: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > v_copy ( v . size ()); std :: reverse_copy ( v . begin (), v . end (), v_copy . begin ()); std :: cout << \"v_copy std::reverse_copy): \" ; std :: for_each ( v_copy . begin (), v_copy . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > v2 { 0 , 1 , 2 , 3 }; ranges :: reverse ( v2 ); std :: cout << \"v2 ranges::reverse: \" ; std :: for_each ( v2 . begin (), v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > v2_copy ( v2 . size ()); ranges :: reverse_copy ( v2 , v2_copy . begin ()); std :: cout << \"v2 ranges::reverse_copy: \" ; std :: for_each ( v2_copy . begin (), v2_copy . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output v std::reverse: 3,2,1,0, v_copy std::reverse_copy): 0,1,2,3, v2 ranges::reverse: 3,2,1,0, v2 ranges::reverse_copy: 0,1,2,3, Other functions \u00b6 function std ranges rotate, rotate_copy, shuffle, next_permutation and prev_permutation are very similar. Transformers \u00b6 copy, copy_n, copy_if \u00b6 #include <range/v3/core.hpp> #include <range/v3/algorithm/copy.hpp> #include <range/v3/algorithm/copy_n.hpp> #include <range/v3/algorithm/copy_if.hpp> #include <range/v3/iterator_range.hpp> #include <iostream> #include <vector> #include <algorithm> auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > from_v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; void copy_fun () { std :: vector < int > copy_to_v1 ; std :: copy ( from_v . begin (), from_v . end (), std :: back_inserter ( copy_to_v1 )); std :: cout << \"copy_to_v1: \" ; std :: for_each ( copy_to_v1 . begin (), copy_to_v1 . end (), printFunc ); std :: cout << '\\n' ; //or without a back_inserter std :: vector < int > copy_to_v2 ( from_v . size ()); std :: copy ( from_v . begin (), from_v . end (), copy_to_v2 . begin ()); std :: cout << \"copy_to_v2: \" ; std :: for_each ( copy_to_v2 . begin (), copy_to_v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_to_v1_ranges ; ranges :: copy ( from_v . begin (), from_v . end (), ranges :: back_inserter ( copy_to_v1_ranges )); std :: cout << \"copy_to_v1_ranges: \" ; std :: for_each ( copy_to_v1_ranges . begin (), copy_to_v1_ranges . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_to_v2_ranges ( from_v . size ()); ranges :: copy ( from_v , copy_to_v2_ranges . begin ()); std :: cout << \"copy_to_v2_ranges: \" ; std :: for_each ( copy_to_v2_ranges . begin (), copy_to_v2_ranges . end (), printFunc ); std :: cout << '\\n' ; } void copy_n_fun () { std :: vector < int > copy_n_to_v1 ; std :: copy_n ( from_v . begin (), 5 , std :: back_inserter ( copy_n_to_v1 )); std :: cout << \"copy_n_to_v1: \" ; std :: for_each ( copy_n_to_v1 . begin (), copy_n_to_v1 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_n_to_v2 ( from_v . size ()); std :: copy_n ( from_v . begin (), 5 , copy_n_to_v2 . begin ()); std :: cout << \"copy_n_to_v2: \" ; std :: for_each ( copy_n_to_v2 . begin (), copy_n_to_v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_n_to_v1_ranges ; ranges :: copy_n ( from_v . begin (), 5 , ranges :: back_inserter ( copy_n_to_v1_ranges )); std :: cout << \"copy_n_to_v1_ranges: \" ; std :: for_each ( copy_n_to_v1_ranges . begin (), copy_n_to_v1_ranges . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_n_to_v2_ranges ( from_v . size ()); ranges :: copy_n ( from_v . begin (), 5 , copy_n_to_v2_ranges . begin ()); std :: cout << \"copy_n_to_v2_ranges: \" ; std :: for_each ( copy_n_to_v2_ranges . begin (), copy_n_to_v2_ranges . end (), printFunc ); std :: cout << '\\n' ; } void copy_if_fun () { std :: vector < int > copy_if_to_v1 ; std :: copy_if ( from_v . begin (), from_v . end (), std :: back_inserter ( copy_if_to_v1 ), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v1: \" ; std :: for_each ( copy_if_to_v1 . begin (), copy_if_to_v1 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_if_to_v2 ( from_v . size ()); std :: copy_if ( from_v . begin (), from_v . end (), copy_if_to_v1 . begin (), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v2: \" ; std :: for_each ( copy_if_to_v2 . begin (), copy_if_to_v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_if_to_v1_ranges ; ranges :: copy_if ( from_v . begin (), from_v . end (), ranges :: back_inserter ( copy_if_to_v1_ranges ), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v1_ranges: \" ; std :: for_each ( copy_if_to_v1_ranges . begin (), copy_if_to_v1_ranges . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_if_to_v2_ranges ( from_v . size ()); ranges :: copy_if ( from_v , copy_if_to_v2_ranges . begin (), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v2_ranges: \" ; std :: for_each ( copy_if_to_v2_ranges . begin (), copy_if_to_v2_ranges . end (), printFunc ); std :: cout << '\\n' ; } int main () { copy_fun (); copy_n_fun (); copy_if_fun (); return 0 ; } Output copy_to_v1: 0,1,2,3,4,5,6,7,8,9, copy_to_v2: 0,1,2,3,4,5,6,7,8,9, copy_to_v1_ranges: 0,1,2,3,4,5,6,7,8,9, copy_to_v2_ranges: 0,1,2,3,4,5,6,7,8,9, copy_n_to_v1: 0,1,2,3,4, copy_n_to_v2: 0,1,2,3,4,0,0,0,0,0, copy_n_to_v1_ranges: 0,1,2,3,4, copy_n_to_v2_ranges: 0,1,2,3,4,0,0,0,0,0, copy_if_to_v1: 0,2,4,6,8, copy_if_to_v2: 0,0,0,0,0,0,0,0,0,0, copy_if_to_v1_ranges: 0,2,4,6,8, copy_if_to_v2_ranges: 0,2,4,6,8,0,0,0,0,0, for_each \u00b6 #include <range/v3/core.hpp> #include <range/v3/algorithm/for_each.hpp> #include <iostream> #include <vector> #include <algorithm> struct Sum { Sum () : sum { 0 } { } void operator ()( int n ) { sum += n ; } int sum ; }; int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 2 , 3 , 6 }; std :: cout << \"std::for_each printFunc: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Sum forEachSum = std :: for_each ( v . begin (), v . end (), Sum ()); std :: cout << \"std::for_each sum: \" << forEachSum . sum << '\\n' ; std :: cout << \"ranges::for_each printFunc: \" ; ranges :: for_each ( v , printFunc ); std :: cout << '\\n' ; auto res = ranges :: for_each ( v , Sum ()); std :: cout << \"range::for_each sum: \" << res . fun (). sum << '\\n' ; return 0 ; } Output ranges::for_each printFunc: 0,2,3,6, range::for_each sum: 11 std::for_each printFunc: 0,2,3,6, std::for_each sum: 11 Both ranges::for_each and std::for_each pass the operands by value(the function and the accumulated value). So Accumulation object is used as copies.","title":"179 range algorithms in less than an hour"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#range-algorithms-in-less-than-an-hour","text":"This post is a note about 179 range algorithms in less than an hour by Dvir Yitzchaki presented in Core C++ 2019.","title":"Range algorithms in less than an hour"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#motivation","text":"Primary motivation for ranges is to provide a simpler syntax for calling algorithims. In good old pre C++20 or without range-v3, std :: vector < int > v { 10 , 2 , 96 }; std :: sort ( v . begin (), v . end ()); In C++20 or with range-v3 library std :: ranges :: sort ( v ); Allowing algorithms to take a single range object instead of separate begin and end iterators opens the door torange adaptors which lazily transform or filter their underlying sequence in interesting ways, like accumulate ( view :: iota ( 1 ) | view :: transform ([]( int x ) { return x * x ;}) | view :: take ( 10 ), 0 );","title":"Motivation"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#range","text":"Ranges are an abstraction over Iterators. Range is basically anything that has a begin() and an end(), both begin() returns an iterator and end() returns a sentinel. Range is a sequence of elements between two locations i,k, often denoted by [i, k) . In standard library, a range is a pair of iterators, usually a begin and an end iterator. std :: copy ( v . begin (), v . end (), buf ); Range can also be an iterator and count of elements. std :: copy_n ( v . begin (), 20 , buf ); Range can also be an iterator and a possiby stateful predicate that indicates when a range is exhausted. std :: copy ( std :: istream_iterator < int > { std :: cin }, std :: istream_iterator < int > {}, buf );","title":"Range"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#iterator-concepts","text":"Iterator : can be derefenced( *it ) and incremented( it++ ). iterator InputIterator : referenced values can be read ( auto v = *it ). input iterator OutputIterator - referenced values can be written to ( *it = v ). output iterator ForwardIterator - Input Iterator + comparable and multi-pass. forward iterator . BidirectionalI terator - Forward Iterator + decrementable ( --it ). bidirectional iterator Random Access Iterator - Bidirectional Iterator + random access ( it += n ) random access iterator Contiguous Iterator - Random Access Iterator + contiguous in memory","title":"Iterator Concepts"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#sentinels","text":"From C++ standard document n4382 A sentinel is an abstraction of a past-the-end iterator. Sentinels are Regular types that can be used to denote the end of a range. A sentinel and an iterator denoting a range shall be EqualityComparable. A sentinel denotes an element when an iterator i compares equal to the sentinel, and i points to that element. You can detect the end of a range in two ways. by testing the iterator itself(past-the-end) by testing the data value at the iterator By allowing the type of the end iterator to differ from begin we: Give the optimizer more context, resulting in better codegen Make it easier to write correct iterators.","title":"Sentinels"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#range-concepts","text":"Range is a type that allows iteration over its elements by providing an iterator and a sentinel that denote the elements of the range. ranges::begin : returns an iterator ranges::end : returns a sentinel Counted range provides an Iterator and a count. Input Range - e.g. Range over a std::istream_iterator Output Range - e.g. Range over a std::ostream_iterator Forward Range - e.g. std::forward_list Bidirectional Range - e.g. std::list Random Access Range - e.g. std::deque Contiguous Range - sentinel is of same type of iterator, e.g. std::vector","title":"Range Concepts"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#sized-ranges","text":"Sized Sentinel - a Sentinel whose distance can be computed using the - operator in constant time. SizedRange - a Range type that knows its size in constant time with the ranges::size function. Not necessarily implies Size Sentinel (std::list) ranges::distance can compute the distant of any range but has linear complexity for non sized ranges/sentinels ranges::data gives a pointer to the data of a contiguous range","title":"Sized ranges"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#projections","text":"Projections allow you give a lambda or invocable that transforms the data on the fly while the algorihim is operating on data. It basically transforms the input sequence.","title":"Projections"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#difference-between-rangle-algorithims-and-classic-stl-algorithims","text":"Accept either a Range object an Iterator+Sentinel pair an Iterator and a count ( _n ) Accept projections Some return type changes No Parallel overloads","title":"Difference between Rangle algorithims and classic stl algorithims"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#views-pipelines-of-lazy-computation","text":"View is a range type that has constant time copy, move, and assignment operators. e.g. A range type that wraps a pair of iterators. A range type that holds its elements by shared_ptr and shares ownership with all its copies. A range type that generates its elements on demand. most containers are not views. int main () { std :: vector < int > is = ranges :: view :: iota ( 0 , 10 ); auto is_even = []( int i ) { return i % 2 == 0 ; }; for ( int i : is | ranges :: view :: filter ( is_even )) std :: cout << i << \" \" ; } view are implicitly converted to stl containers.","title":"Views: Pipelines of lazy computation"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#factoris-adaptors","text":"For each view, the library defines a utility object called an adaptor (if it transforms an existing range) or a factory (otherwise), which creates such a view. Adapted views are lazy, which means they generate their elements only on demand, when the resulting adapted range is iterated. For this reason, there can be views with infinitely many elements","title":"Factoris &amp; Adaptors"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#generators","text":"","title":"Generators"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#fill-fill_n","text":"#include <range/v3/core.hpp> #include <range/v3/algorithm/fill.hpp> #include <range/v3/algorithm/fill_n.hpp> #include <iostream> #include <vector> #include <algorithm> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; std :: fill ( v . begin (), v . end (), - 1 ); std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: fill ( v . begin (), v . end (), 10 ); std :: cout << \"v after std::fill(10): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: fill_n ( v . begin (), 3 , - 2 ); std :: cout << \"v after std::fill_n(3, -2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; ranges :: fill ( v , 6 ); std :: cout << \"v after ranges::fill(6): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; ranges :: fill_n ( v . begin (), 3 , 12 ); std :: cout << \"v after ranges::fill_n(3, -2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output v: -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, v after std::fill(10): 10,10,10,10,10,10,10,10,10,10, v after std::fill_n(3, -2): -2,-2,-2,10,10,10,10,10,10,10, v after ranges::fill(6): 6,6,6,6,6,6,6,6,6,6, v after ranges::fill_n(3, -2): 12,12,12,6,6,6,6,6,6,6, Just notice the difference for fill_n, both std::fill_n and ranges::fill_n have very similar sytaxes.","title":"fill, fill_n"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#iota","text":"#include <range/v3/core.hpp> #include <range/v3/numeric/iota.hpp> #include <iostream> #include <list> #include <algorithm> #include <numeric> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: list < int > l ( 10 ); std :: iota ( l . begin (), l . end (), - 4 ); std :: cout << \"l after std::iota(-4): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; ranges :: iota ( l , 6 ); std :: cout << \"l after ranges::iota(6): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output l after std::iota(-4): -4,-3,-2,-1,0,1,2,3,4,5, l after ranges::iota(6): 6,7,8,9,10,11,12,13,14,15,","title":"iota"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#generate-and-generate_n","text":"#include <range/v3/core.hpp> #include <range/v3/algorithm/generate.hpp> #include <range/v3/algorithm/generate_n.hpp> #include <iostream> #include <vector> #include <algorithm> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v ( 5 ); std :: generate ( v . begin (), v . end (), [ n = 0 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 5 ); std :: generate_n ( v . begin (), 2 , [ n = 20 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate_n(2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 5 ); ranges :: generate ( v , [ n = 10 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 10 ); ranges :: generate_n ( v . begin (), 3 , [ n = 15 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate_n(3): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output v std::generate: 0,1,2,3,4, v std::generate_n(2): 20,21,0,0,0, v ranges::generate: 10,11,12,13,14, v ranges::generate_n(3): 15,16,17,0,0,0,0,0,0,0,","title":"generate and generate_n"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#permutations","text":"","title":"Permutations"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#reverse-and-reverse_copy","text":"#include <range/v3/core.hpp> #include <range/v3/algorithm/reverse.hpp> #include <range/v3/algorithm/reverse_copy.hpp> #include <iostream> #include <vector> #include <algorithm> int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 1 , 2 , 3 }; std :: reverse ( v . begin (), v . end ()); std :: cout << \"v std::reverse: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > v_copy ( v . size ()); std :: reverse_copy ( v . begin (), v . end (), v_copy . begin ()); std :: cout << \"v_copy std::reverse_copy): \" ; std :: for_each ( v_copy . begin (), v_copy . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > v2 { 0 , 1 , 2 , 3 }; ranges :: reverse ( v2 ); std :: cout << \"v2 ranges::reverse: \" ; std :: for_each ( v2 . begin (), v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > v2_copy ( v2 . size ()); ranges :: reverse_copy ( v2 , v2_copy . begin ()); std :: cout << \"v2 ranges::reverse_copy: \" ; std :: for_each ( v2_copy . begin (), v2_copy . end (), printFunc ); std :: cout << '\\n' ; return 0 ; } Output v std::reverse: 3,2,1,0, v_copy std::reverse_copy): 0,1,2,3, v2 ranges::reverse: 3,2,1,0, v2 ranges::reverse_copy: 0,1,2,3,","title":"reverse and reverse_copy"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#other-functions","text":"function std ranges rotate, rotate_copy, shuffle, next_permutation and prev_permutation are very similar.","title":"Other functions"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#transformers","text":"","title":"Transformers"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#copy-copy_n-copy_if","text":"#include <range/v3/core.hpp> #include <range/v3/algorithm/copy.hpp> #include <range/v3/algorithm/copy_n.hpp> #include <range/v3/algorithm/copy_if.hpp> #include <range/v3/iterator_range.hpp> #include <iostream> #include <vector> #include <algorithm> auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > from_v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; void copy_fun () { std :: vector < int > copy_to_v1 ; std :: copy ( from_v . begin (), from_v . end (), std :: back_inserter ( copy_to_v1 )); std :: cout << \"copy_to_v1: \" ; std :: for_each ( copy_to_v1 . begin (), copy_to_v1 . end (), printFunc ); std :: cout << '\\n' ; //or without a back_inserter std :: vector < int > copy_to_v2 ( from_v . size ()); std :: copy ( from_v . begin (), from_v . end (), copy_to_v2 . begin ()); std :: cout << \"copy_to_v2: \" ; std :: for_each ( copy_to_v2 . begin (), copy_to_v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_to_v1_ranges ; ranges :: copy ( from_v . begin (), from_v . end (), ranges :: back_inserter ( copy_to_v1_ranges )); std :: cout << \"copy_to_v1_ranges: \" ; std :: for_each ( copy_to_v1_ranges . begin (), copy_to_v1_ranges . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_to_v2_ranges ( from_v . size ()); ranges :: copy ( from_v , copy_to_v2_ranges . begin ()); std :: cout << \"copy_to_v2_ranges: \" ; std :: for_each ( copy_to_v2_ranges . begin (), copy_to_v2_ranges . end (), printFunc ); std :: cout << '\\n' ; } void copy_n_fun () { std :: vector < int > copy_n_to_v1 ; std :: copy_n ( from_v . begin (), 5 , std :: back_inserter ( copy_n_to_v1 )); std :: cout << \"copy_n_to_v1: \" ; std :: for_each ( copy_n_to_v1 . begin (), copy_n_to_v1 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_n_to_v2 ( from_v . size ()); std :: copy_n ( from_v . begin (), 5 , copy_n_to_v2 . begin ()); std :: cout << \"copy_n_to_v2: \" ; std :: for_each ( copy_n_to_v2 . begin (), copy_n_to_v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_n_to_v1_ranges ; ranges :: copy_n ( from_v . begin (), 5 , ranges :: back_inserter ( copy_n_to_v1_ranges )); std :: cout << \"copy_n_to_v1_ranges: \" ; std :: for_each ( copy_n_to_v1_ranges . begin (), copy_n_to_v1_ranges . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_n_to_v2_ranges ( from_v . size ()); ranges :: copy_n ( from_v . begin (), 5 , copy_n_to_v2_ranges . begin ()); std :: cout << \"copy_n_to_v2_ranges: \" ; std :: for_each ( copy_n_to_v2_ranges . begin (), copy_n_to_v2_ranges . end (), printFunc ); std :: cout << '\\n' ; } void copy_if_fun () { std :: vector < int > copy_if_to_v1 ; std :: copy_if ( from_v . begin (), from_v . end (), std :: back_inserter ( copy_if_to_v1 ), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v1: \" ; std :: for_each ( copy_if_to_v1 . begin (), copy_if_to_v1 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_if_to_v2 ( from_v . size ()); std :: copy_if ( from_v . begin (), from_v . end (), copy_if_to_v1 . begin (), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v2: \" ; std :: for_each ( copy_if_to_v2 . begin (), copy_if_to_v2 . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_if_to_v1_ranges ; ranges :: copy_if ( from_v . begin (), from_v . end (), ranges :: back_inserter ( copy_if_to_v1_ranges ), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v1_ranges: \" ; std :: for_each ( copy_if_to_v1_ranges . begin (), copy_if_to_v1_ranges . end (), printFunc ); std :: cout << '\\n' ; std :: vector < int > copy_if_to_v2_ranges ( from_v . size ()); ranges :: copy_if ( from_v , copy_if_to_v2_ranges . begin (), []( int n ) { return n % 2 == 0 ; }); std :: cout << \"copy_if_to_v2_ranges: \" ; std :: for_each ( copy_if_to_v2_ranges . begin (), copy_if_to_v2_ranges . end (), printFunc ); std :: cout << '\\n' ; } int main () { copy_fun (); copy_n_fun (); copy_if_fun (); return 0 ; } Output copy_to_v1: 0,1,2,3,4,5,6,7,8,9, copy_to_v2: 0,1,2,3,4,5,6,7,8,9, copy_to_v1_ranges: 0,1,2,3,4,5,6,7,8,9, copy_to_v2_ranges: 0,1,2,3,4,5,6,7,8,9, copy_n_to_v1: 0,1,2,3,4, copy_n_to_v2: 0,1,2,3,4,0,0,0,0,0, copy_n_to_v1_ranges: 0,1,2,3,4, copy_n_to_v2_ranges: 0,1,2,3,4,0,0,0,0,0, copy_if_to_v1: 0,2,4,6,8, copy_if_to_v2: 0,0,0,0,0,0,0,0,0,0, copy_if_to_v1_ranges: 0,2,4,6,8, copy_if_to_v2_ranges: 0,2,4,6,8,0,0,0,0,0,","title":"copy, copy_n, copy_if"},{"location":"cpp/179-range-algorithms-in-less-than-an-hour/#for_each","text":"#include <range/v3/core.hpp> #include <range/v3/algorithm/for_each.hpp> #include <iostream> #include <vector> #include <algorithm> struct Sum { Sum () : sum { 0 } { } void operator ()( int n ) { sum += n ; } int sum ; }; int main () { auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 2 , 3 , 6 }; std :: cout << \"std::for_each printFunc: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Sum forEachSum = std :: for_each ( v . begin (), v . end (), Sum ()); std :: cout << \"std::for_each sum: \" << forEachSum . sum << '\\n' ; std :: cout << \"ranges::for_each printFunc: \" ; ranges :: for_each ( v , printFunc ); std :: cout << '\\n' ; auto res = ranges :: for_each ( v , Sum ()); std :: cout << \"range::for_each sum: \" << res . fun (). sum << '\\n' ; return 0 ; } Output ranges::for_each printFunc: 0,2,3,6, range::for_each sum: 11 std::for_each printFunc: 0,2,3,6, std::for_each sum: 11 Both ranges::for_each and std::for_each pass the operands by value(the function and the accumulated value). So Accumulation object is used as copies.","title":"for_each"},{"location":"cpp/property-check-agorithims/","text":"Property Check Algorithms in C++ \u00b6 There are three property check algorithms in range-v3 and standard c++ all_of none_of any_of All these functions take a sequence and a unary predicate. - all_of checks if the unary predicate is true for all elements - none_of checks the opposite - any_of checks at-least one is true. Boost functions take both iterators(begin and end pair) or range. std :: vector < int > v { 2 , 4 , 6 }; std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: cout << std :: boolalpha ; std :: cout << \"std::all_of evens: \" << std :: all_of ( v . begin (), v . end (), isEven ) << '\\n' ; std :: cout << \"std::any_of divisible by 4: \" << std :: any_of ( v . begin (), v . end (), isDivisibleBy4 ) << '\\n' ; std :: cout << \"std::none_of odd: \" << std :: none_of ( v . begin (), v . end (), isOdd ) << '\\n' ; std :: cout << \"ranges::all_of evens: \" << ranges :: all_of ( v , isEven ) << '\\n' ; std :: cout << \"ranges::any_of divisible by 4: \" << ranges :: any_of ( v , isDivisibleBy4 ) << '\\n' ; std :: cout << \"ranges::none_of odd: \" << ranges :: none_of ( v , isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::all_of(iter...) evens: \" << boost :: algorithm :: all_of ( v . begin (), v . end (), isEven ) << '\\n' ; std :: cout << \"boost::algorithm::all_of(range...) evens: \" << boost :: algorithm :: all_of ( v , isEven ) << '\\n' ; std :: cout << \"boost::algorithm::any_of divisible by 4(iter...): \" << boost :: algorithm :: any_of ( v . begin (), v . end (), isDivisibleBy4 ) << '\\n' ; std :: cout << \"boost::algorithm::any_of divisible by 4(range...): \" << boost :: algorithm :: any_of ( v , isDivisibleBy4 ) << '\\n' ; std :: cout << \"boost::algorithm::none_of(iter...) odd: \" << boost :: algorithm :: none_of ( v . begin (), v . end (), isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::none_of(range...) odd: \" << boost :: algorithm :: none_of ( v , isOdd ) << '\\n' ; Output v: 2,4,6, std::all_of evens: true std::any_of divisible by 4: true std::none_of odd: true ranges::all_of evens: true ranges::any_of divisible by 4: true ranges::none_of odd: true boost::algorithm::all_of(iter...) evens: true boost::algorithm::all_of(range...) evens: true boost::algorithm::any_of divisible by 4(iter...): true boost::algorithm::any_of divisible by 4(range...): true boost::algorithm::none_of(iter...) odd: true boost::algorithm::none_of(range...) odd: true Boost has a few additional property check functions. one_of is_sorted is_partioned one_of takes a sequence and a predicate. It will return true if the predicate returns true for one element in the sequence. The function is_sorted determines whether or not a sequence is completely sorted according to some criteria. If no comparison predicate is specified, then std::less_equal is used. is_partitioned takes a sequence and a predicate and returns true if the sequence is partitioned according to the predicate. std :: vector < int > v { 2 , 4 , 6 }; std :: vector < int > v2 { 1 , 3 , 4 , 2 , 4 , 6 }; std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: cout << std :: boolalpha ; std :: cout << \"boost::algorithm::one_of(iter...) odd: \" << boost :: algorithm :: one_of ( v . begin (), v . end (), isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::one_of(range...) odd: \" << boost :: algorithm :: one_of ( v , isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::is_sorted(iter...): \" << boost :: algorithm :: is_sorted ( v . begin (), v . end ()) << '\\n' ; std :: cout << \"boost::algorithm::is_sorted(range...): \" << boost :: algorithm :: is_sorted ( v ) << '\\n' ; std :: cout << \"boost::algorithm::is_partitioned(iter...): \" << boost :: algorithm :: is_partitioned ( v2 . begin (), v2 . end (), isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::is_partitioned(range...): \" << boost :: algorithm :: is_partitioned ( v2 , isOdd ) << '\\n' ; // range-v3 std :: cout << \"ranges::is_sorted: \" << ranges :: is_sorted ( v ) << '\\n' ; std :: cout << \"ranges::is_partitioned: \" << ranges :: is_partitioned ( v2 , isOdd ) << '\\n' ; Output v: 2,4,6, boost::algorithm::one_of(iter...) odd: false boost::algorithm::one_of(range...) odd: false boost::algorithm::is_sorted(iter...): true boost::algorithm::is_sorted(range...): true boost::algorithm::is_partitioned(iter...): true boost::algorithm::is_partitioned(range...): true ranges::is_sorted: true ranges::is_partitioned: true Boost also provides several algorithms with the _equal suffix. They take an additional parameter to compare the value with. all_of_equal none_of_equal any_of_equal one_of_equal std :: vector < int > v { 2 , 4 , 6 }; std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: cout << std :: boolalpha ; std :: cout << \"Iterator ... \\n \" ; std :: cout << \"boost::algorithm::all_of_equal: \" << boost :: algorithm :: all_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"boost::algorithm::any_of_equal: \" << boost :: algorithm :: any_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"boost::algorithm::none_of_equal: \" << boost :: algorithm :: none_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"boost::algorithm::one_of_equal: \" << boost :: algorithm :: one_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"Range ... \\n \" ; std :: cout << \"boost::algorithm::all_of_equal: \" << boost :: algorithm :: all_of_equal ( v , 4 ) << '\\n' ; std :: cout << \"boost::algorithm::any_of_equal: \" << boost :: algorithm :: any_of_equal ( v , 4 ) << '\\n' ; std :: cout << \"boost::algorithm::none_of_equal: \" << boost :: algorithm :: none_of_equal ( v , 4 ) << '\\n' ; std :: cout << \"boost::algorithm::one_of_equal: \" << boost :: algorithm :: one_of_equal ( v , 4 ) << '\\n' ; Output v: 2,4,6, Iterator ... boost::algorithm::all_of_equal: false boost::algorithm::any_of_equal: true boost::algorithm::none_of_equal: false boost::algorithm::one_of_equal: true Range ... boost::algorithm::all_of_equal: false boost::algorithm::any_of_equal: true boost::algorithm::none_of_equal: false boost::algorithm::one_of_equal: true property check on empty ranges \u00b6 Empty range behaves a little bit different. An empty range returns true for all_of and none_of. An empty range returns false for any_of and one_of. An empty range is always sorted and partioned. function on empty range result all_of true all_of_equal true any_of false any_of_equal false none_of true none_of_equal true one_of false one_of_equal false is_sorted true is_partitioned true","title":"Property Check Algorithms"},{"location":"cpp/property-check-agorithims/#property-check-algorithms-in-c","text":"There are three property check algorithms in range-v3 and standard c++ all_of none_of any_of All these functions take a sequence and a unary predicate. - all_of checks if the unary predicate is true for all elements - none_of checks the opposite - any_of checks at-least one is true. Boost functions take both iterators(begin and end pair) or range. std :: vector < int > v { 2 , 4 , 6 }; std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: cout << std :: boolalpha ; std :: cout << \"std::all_of evens: \" << std :: all_of ( v . begin (), v . end (), isEven ) << '\\n' ; std :: cout << \"std::any_of divisible by 4: \" << std :: any_of ( v . begin (), v . end (), isDivisibleBy4 ) << '\\n' ; std :: cout << \"std::none_of odd: \" << std :: none_of ( v . begin (), v . end (), isOdd ) << '\\n' ; std :: cout << \"ranges::all_of evens: \" << ranges :: all_of ( v , isEven ) << '\\n' ; std :: cout << \"ranges::any_of divisible by 4: \" << ranges :: any_of ( v , isDivisibleBy4 ) << '\\n' ; std :: cout << \"ranges::none_of odd: \" << ranges :: none_of ( v , isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::all_of(iter...) evens: \" << boost :: algorithm :: all_of ( v . begin (), v . end (), isEven ) << '\\n' ; std :: cout << \"boost::algorithm::all_of(range...) evens: \" << boost :: algorithm :: all_of ( v , isEven ) << '\\n' ; std :: cout << \"boost::algorithm::any_of divisible by 4(iter...): \" << boost :: algorithm :: any_of ( v . begin (), v . end (), isDivisibleBy4 ) << '\\n' ; std :: cout << \"boost::algorithm::any_of divisible by 4(range...): \" << boost :: algorithm :: any_of ( v , isDivisibleBy4 ) << '\\n' ; std :: cout << \"boost::algorithm::none_of(iter...) odd: \" << boost :: algorithm :: none_of ( v . begin (), v . end (), isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::none_of(range...) odd: \" << boost :: algorithm :: none_of ( v , isOdd ) << '\\n' ; Output v: 2,4,6, std::all_of evens: true std::any_of divisible by 4: true std::none_of odd: true ranges::all_of evens: true ranges::any_of divisible by 4: true ranges::none_of odd: true boost::algorithm::all_of(iter...) evens: true boost::algorithm::all_of(range...) evens: true boost::algorithm::any_of divisible by 4(iter...): true boost::algorithm::any_of divisible by 4(range...): true boost::algorithm::none_of(iter...) odd: true boost::algorithm::none_of(range...) odd: true Boost has a few additional property check functions. one_of is_sorted is_partioned one_of takes a sequence and a predicate. It will return true if the predicate returns true for one element in the sequence. The function is_sorted determines whether or not a sequence is completely sorted according to some criteria. If no comparison predicate is specified, then std::less_equal is used. is_partitioned takes a sequence and a predicate and returns true if the sequence is partitioned according to the predicate. std :: vector < int > v { 2 , 4 , 6 }; std :: vector < int > v2 { 1 , 3 , 4 , 2 , 4 , 6 }; std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: cout << std :: boolalpha ; std :: cout << \"boost::algorithm::one_of(iter...) odd: \" << boost :: algorithm :: one_of ( v . begin (), v . end (), isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::one_of(range...) odd: \" << boost :: algorithm :: one_of ( v , isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::is_sorted(iter...): \" << boost :: algorithm :: is_sorted ( v . begin (), v . end ()) << '\\n' ; std :: cout << \"boost::algorithm::is_sorted(range...): \" << boost :: algorithm :: is_sorted ( v ) << '\\n' ; std :: cout << \"boost::algorithm::is_partitioned(iter...): \" << boost :: algorithm :: is_partitioned ( v2 . begin (), v2 . end (), isOdd ) << '\\n' ; std :: cout << \"boost::algorithm::is_partitioned(range...): \" << boost :: algorithm :: is_partitioned ( v2 , isOdd ) << '\\n' ; // range-v3 std :: cout << \"ranges::is_sorted: \" << ranges :: is_sorted ( v ) << '\\n' ; std :: cout << \"ranges::is_partitioned: \" << ranges :: is_partitioned ( v2 , isOdd ) << '\\n' ; Output v: 2,4,6, boost::algorithm::one_of(iter...) odd: false boost::algorithm::one_of(range...) odd: false boost::algorithm::is_sorted(iter...): true boost::algorithm::is_sorted(range...): true boost::algorithm::is_partitioned(iter...): true boost::algorithm::is_partitioned(range...): true ranges::is_sorted: true ranges::is_partitioned: true Boost also provides several algorithms with the _equal suffix. They take an additional parameter to compare the value with. all_of_equal none_of_equal any_of_equal one_of_equal std :: vector < int > v { 2 , 4 , 6 }; std :: cout << \"v: \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; std :: cout << std :: boolalpha ; std :: cout << \"Iterator ... \\n \" ; std :: cout << \"boost::algorithm::all_of_equal: \" << boost :: algorithm :: all_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"boost::algorithm::any_of_equal: \" << boost :: algorithm :: any_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"boost::algorithm::none_of_equal: \" << boost :: algorithm :: none_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"boost::algorithm::one_of_equal: \" << boost :: algorithm :: one_of_equal ( v . begin (), v . end (), 4 ) << '\\n' ; std :: cout << \"Range ... \\n \" ; std :: cout << \"boost::algorithm::all_of_equal: \" << boost :: algorithm :: all_of_equal ( v , 4 ) << '\\n' ; std :: cout << \"boost::algorithm::any_of_equal: \" << boost :: algorithm :: any_of_equal ( v , 4 ) << '\\n' ; std :: cout << \"boost::algorithm::none_of_equal: \" << boost :: algorithm :: none_of_equal ( v , 4 ) << '\\n' ; std :: cout << \"boost::algorithm::one_of_equal: \" << boost :: algorithm :: one_of_equal ( v , 4 ) << '\\n' ; Output v: 2,4,6, Iterator ... boost::algorithm::all_of_equal: false boost::algorithm::any_of_equal: true boost::algorithm::none_of_equal: false boost::algorithm::one_of_equal: true Range ... boost::algorithm::all_of_equal: false boost::algorithm::any_of_equal: true boost::algorithm::none_of_equal: false boost::algorithm::one_of_equal: true","title":"Property Check Algorithms in C++"},{"location":"cpp/property-check-agorithims/#property-check-on-empty-ranges","text":"Empty range behaves a little bit different. An empty range returns true for all_of and none_of. An empty range returns false for any_of and one_of. An empty range is always sorted and partioned. function on empty range result all_of true all_of_equal true any_of false any_of_equal false none_of true none_of_equal true one_of false one_of_equal false is_sorted true is_partitioned true","title":"property check on empty ranges"},{"location":"cpp/range-generator-algorithms/","text":"Range Generator Algorithms \u00b6 This post is about range generator algorithims in C++ and comparision with stl classical algorithims. I will be using range-v3 and boost range library for this. Primary motivation for ranges is to provide a simpler syntax for calling algorithims. In good old pre C++20 or without range-v3, std :: vector < int > v { 10 , 2 , 96 }; std :: sort ( v . begin (), v . end ()); In range-v3 library ranges :: sort ( v ); Range \u00b6 Ranges are an abstraction over Iterators. Range is basically anything that has a begin() and an end(), both begin() returns an iterator and end() returns a sentinel. range { SomeIterator begin (); SomeSentinel end (); } From C++ standard document n4382 A sentinel is an abstraction of a past-the-end iterator. Sentinels are Regular types that can be used to denote the end of a range. A sentinel and an iterator denoting a range shall be EqualityComparable. A sentinel denotes an element when an iterator i compares equal to the sentinel, and i points to that element. You can detect the end of a range in two ways. - by testing the iterator itself(past-the-end) - by testing the data value at the iterator Most classical stl algorithim has an overload which takes a range, instead of begin() and end() iterator. Range based Generator Algorithim overloads \u00b6 In standard c++, there are three generator algorithims. std::fill, std::fill_n std::generate, std::generate_n std::iota std::fill populates a container with a value, std::generate generates a sequence of values to be populated in a container and std::iota generates a sequence of incremental values. std::fill and std::fill_n \u00b6 namespace std { template < class ForwardIt , class T > void fill ( ForwardIt first , ForwardIt last , const T & value ); } first -> forward iterator, usually the value of std::begin(c) or c.begin() or c.begin() + a distance value last -> past-the-end iterator or any position after first value -> is a value to be populated namespace std { template < class OutputIt , class Size , class T > OutputIt fill_n ( OutputIt first , Size count , const T & value ); } fill_n takes a size instead of an iterator. Notice that fill_n takes a output iterator and fill takes a forward iterator. Output iterator doesn't support equality/inequality comparison (including operator!= used in the possible implementation of fill() ) and multipass guarantee, while forward iterator does. That means output iterator can't be used for representing a range via two iterators (e.g. [first, last)) which is required by fill() 's interface. There is another difference, fill_n return type is an output iterator. The return value is first + n. Example auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; std :: fill ( v . begin (), v . end (), - 1 ); std :: cout << \"v after std::fill(..., -1): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; auto ret = std :: fill_n ( v . begin (), 3 , - 2 ); assert ( ret == v . begin () + 3 ); std :: cout << \"v after std::fill_n(..., 3, -2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v after std::fill(..., -1): -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, v after std::fill_n(..., 3, -2): -2,-2,-2,-1,-1,-1,-1,-1,-1,-1, Both range-v3 and boost range emulates this behavior. namespace range { namespace v3 { struct fill_fn { template < typename O , typename S , typename V , CONCEPT_REQUIRES_ ( OutputIterator < O , V const &> () && Sentinel < S , O > ()) > O operator ()( O begin , S end , V const & val ) const { for (; begin != end ; ++ begin ) * begin = val ; return begin ; } template < typename Rng , typename V , typename O = iterator_t < Rng > , CONCEPT_REQUIRES_ ( OutputRange < Rng , V const &> ()) > safe_iterator_t < Rng > operator ()( Rng && rng , V const & val ) const { return ( * this )( begin ( rng ), end ( rng ), val ); } } } // v3 } // range The first version of fill is straight forward. It takes both begin and end iterator, and a value. It returns end. The second version takes a range, basically a pair of begin and end. namespace range { namespace v3 { struct fill_n_fn { template < typename O , typename V , CONCEPT_REQUIRES_ ( OutputIterator < O , V const &> ()) > O operator ()( O begin , difference_type_t < O > n , V const & val ) const { RANGES_EXPECT ( n >= 0 ); auto norig = n ; auto b = uncounted ( begin ); for (; n != 0 ; ++ b , -- n ) * b = val ; return recounted ( begin , b , norig ); } }; } // v3 } // range The fill_n takes an output iterator and a length. It returns first + n. Example std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; auto ret1 = ranges :: fill ( v , 6 ); assert ( ret1 == v . end ()); std :: cout << \"v after ranges::fill(..., 6): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; auto ret2 = ranges :: fill_n ( v . begin (), 3 , 12 ); assert ( ret2 == v . begin () + 3 ); std :: cout << \"v after ranges::fill_n(..., 3, 12): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v after ranges::fill(..., 6): 6,6,6,6,6,6,6,6,6,6, v after ranges::fill_n(..., 3, 12): 12,12,12,6,6,6,6,6,6,6, Boost range is very similar to range-v3, except fill_n can figure out begin iterator easily. Example std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; oost :: range :: fill ( v , - 1 ); std :: cout << \"v after boost::range::fill(..., -1): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; boost :: range :: fill_n ( v , 5 , - 10 ); std :: cout << \"v after boost::range::fill(..., 5, -10): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v after boost::range::fill(..., -1): -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, v after boost::range::fill(..., 5, -10): -10,-10,-10,-10,-10,-1,-1,-1,-1,-1, Boost range interally uses classical stl algorithims. All three have a very similar performance. iota \u00b6 iota is very similar to fill. auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: list < int > l ( 10 ); std :: iota ( l . begin (), l . end (), - 4 ); std :: cout << \"l after std::iota(..., -4): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; ranges :: iota ( l , 6 ); std :: cout << \"l after ranges::iota(..., 6): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; boost :: range :: iota ( l , - 10 ); std :: cout << \"l after boost::range::iota(..., -10): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; Output l after std::iota(..., -4): -4,-3,-2,-1,0,1,2,3,4,5, l after ranges::iota(..., 6): 6,7,8,9,10,11,12,13,14,15, l after boost::range::iota(..., -10): -10,-9,-8,-7,-6,-5,-4,-3,-2,-1, Like fill and fill_n, iota has also similar performance. generate and generate_n \u00b6 Both generate and generate_n are very similar to fill and fill_n. Boost doesn't have an equivalent of n function. Example of std library std :: vector < int > v ( 5 ); std :: generate ( v . begin (), v . end (), [ n = 0 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate(...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 5 ); std :: generate_n ( v . begin (), 2 , [ n = 20 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate_n(..., 2, ...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v std::generate(...): 0,1,2,3,4, v std::generate_n(..., 2, ...): 20,21,0,0,0, Example of range library std :: vector < int > v ( 5 ); ranges :: generate ( v , [ n = 10 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate(...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 10 ); ranges :: generate_n ( v . begin (), 3 , [ n = 15 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate_n(.., 3, ..): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v ranges::generate(...): 10,11,12,13,14, v ranges::generate_n(.., 3, ..): 15,16,17,0,0,0,0,0,0,0, Example of boost library std :: vector < int > v ( 5 ); boost :: range :: generate ( v , [ n = 10 ] () mutable { return n ++ ; }); std :: cout << \"v boost::ranges::generate(...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v boost::ranges::generate(...): 10,11,12,13,14, And finally, the performance benchmark Benchmark source code is shared here https://github.com/asit-dhal/range-benchmarks.git Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"Range Generator Algorithms"},{"location":"cpp/range-generator-algorithms/#range-generator-algorithms","text":"This post is about range generator algorithims in C++ and comparision with stl classical algorithims. I will be using range-v3 and boost range library for this. Primary motivation for ranges is to provide a simpler syntax for calling algorithims. In good old pre C++20 or without range-v3, std :: vector < int > v { 10 , 2 , 96 }; std :: sort ( v . begin (), v . end ()); In range-v3 library ranges :: sort ( v );","title":"Range Generator Algorithms"},{"location":"cpp/range-generator-algorithms/#range","text":"Ranges are an abstraction over Iterators. Range is basically anything that has a begin() and an end(), both begin() returns an iterator and end() returns a sentinel. range { SomeIterator begin (); SomeSentinel end (); } From C++ standard document n4382 A sentinel is an abstraction of a past-the-end iterator. Sentinels are Regular types that can be used to denote the end of a range. A sentinel and an iterator denoting a range shall be EqualityComparable. A sentinel denotes an element when an iterator i compares equal to the sentinel, and i points to that element. You can detect the end of a range in two ways. - by testing the iterator itself(past-the-end) - by testing the data value at the iterator Most classical stl algorithim has an overload which takes a range, instead of begin() and end() iterator.","title":"Range"},{"location":"cpp/range-generator-algorithms/#range-based-generator-algorithim-overloads","text":"In standard c++, there are three generator algorithims. std::fill, std::fill_n std::generate, std::generate_n std::iota std::fill populates a container with a value, std::generate generates a sequence of values to be populated in a container and std::iota generates a sequence of incremental values.","title":"Range based Generator Algorithim overloads"},{"location":"cpp/range-generator-algorithms/#stdfill-and-stdfill_n","text":"namespace std { template < class ForwardIt , class T > void fill ( ForwardIt first , ForwardIt last , const T & value ); } first -> forward iterator, usually the value of std::begin(c) or c.begin() or c.begin() + a distance value last -> past-the-end iterator or any position after first value -> is a value to be populated namespace std { template < class OutputIt , class Size , class T > OutputIt fill_n ( OutputIt first , Size count , const T & value ); } fill_n takes a size instead of an iterator. Notice that fill_n takes a output iterator and fill takes a forward iterator. Output iterator doesn't support equality/inequality comparison (including operator!= used in the possible implementation of fill() ) and multipass guarantee, while forward iterator does. That means output iterator can't be used for representing a range via two iterators (e.g. [first, last)) which is required by fill() 's interface. There is another difference, fill_n return type is an output iterator. The return value is first + n. Example auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; std :: fill ( v . begin (), v . end (), - 1 ); std :: cout << \"v after std::fill(..., -1): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; auto ret = std :: fill_n ( v . begin (), 3 , - 2 ); assert ( ret == v . begin () + 3 ); std :: cout << \"v after std::fill_n(..., 3, -2): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v after std::fill(..., -1): -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, v after std::fill_n(..., 3, -2): -2,-2,-2,-1,-1,-1,-1,-1,-1,-1, Both range-v3 and boost range emulates this behavior. namespace range { namespace v3 { struct fill_fn { template < typename O , typename S , typename V , CONCEPT_REQUIRES_ ( OutputIterator < O , V const &> () && Sentinel < S , O > ()) > O operator ()( O begin , S end , V const & val ) const { for (; begin != end ; ++ begin ) * begin = val ; return begin ; } template < typename Rng , typename V , typename O = iterator_t < Rng > , CONCEPT_REQUIRES_ ( OutputRange < Rng , V const &> ()) > safe_iterator_t < Rng > operator ()( Rng && rng , V const & val ) const { return ( * this )( begin ( rng ), end ( rng ), val ); } } } // v3 } // range The first version of fill is straight forward. It takes both begin and end iterator, and a value. It returns end. The second version takes a range, basically a pair of begin and end. namespace range { namespace v3 { struct fill_n_fn { template < typename O , typename V , CONCEPT_REQUIRES_ ( OutputIterator < O , V const &> ()) > O operator ()( O begin , difference_type_t < O > n , V const & val ) const { RANGES_EXPECT ( n >= 0 ); auto norig = n ; auto b = uncounted ( begin ); for (; n != 0 ; ++ b , -- n ) * b = val ; return recounted ( begin , b , norig ); } }; } // v3 } // range The fill_n takes an output iterator and a length. It returns first + n. Example std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; auto ret1 = ranges :: fill ( v , 6 ); assert ( ret1 == v . end ()); std :: cout << \"v after ranges::fill(..., 6): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; auto ret2 = ranges :: fill_n ( v . begin (), 3 , 12 ); assert ( ret2 == v . begin () + 3 ); std :: cout << \"v after ranges::fill_n(..., 3, 12): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v after ranges::fill(..., 6): 6,6,6,6,6,6,6,6,6,6, v after ranges::fill_n(..., 3, 12): 12,12,12,6,6,6,6,6,6,6, Boost range is very similar to range-v3, except fill_n can figure out begin iterator easily. Example std :: vector < int > v { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; oost :: range :: fill ( v , - 1 ); std :: cout << \"v after boost::range::fill(..., -1): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; boost :: range :: fill_n ( v , 5 , - 10 ); std :: cout << \"v after boost::range::fill(..., 5, -10): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v after boost::range::fill(..., -1): -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, v after boost::range::fill(..., 5, -10): -10,-10,-10,-10,-10,-1,-1,-1,-1,-1, Boost range interally uses classical stl algorithims. All three have a very similar performance.","title":"std::fill and std::fill_n"},{"location":"cpp/range-generator-algorithms/#iota","text":"iota is very similar to fill. auto printFunc = []( auto x ) { std :: cout << x << ',' ;}; std :: list < int > l ( 10 ); std :: iota ( l . begin (), l . end (), - 4 ); std :: cout << \"l after std::iota(..., -4): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; ranges :: iota ( l , 6 ); std :: cout << \"l after ranges::iota(..., 6): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; boost :: range :: iota ( l , - 10 ); std :: cout << \"l after boost::range::iota(..., -10): \" ; std :: for_each ( l . begin (), l . end (), printFunc ); std :: cout << '\\n' ; Output l after std::iota(..., -4): -4,-3,-2,-1,0,1,2,3,4,5, l after ranges::iota(..., 6): 6,7,8,9,10,11,12,13,14,15, l after boost::range::iota(..., -10): -10,-9,-8,-7,-6,-5,-4,-3,-2,-1, Like fill and fill_n, iota has also similar performance.","title":"iota"},{"location":"cpp/range-generator-algorithms/#generate-and-generate_n","text":"Both generate and generate_n are very similar to fill and fill_n. Boost doesn't have an equivalent of n function. Example of std library std :: vector < int > v ( 5 ); std :: generate ( v . begin (), v . end (), [ n = 0 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate(...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 5 ); std :: generate_n ( v . begin (), 2 , [ n = 20 ] () mutable { return n ++ ; }); std :: cout << \"v std::generate_n(..., 2, ...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v std::generate(...): 0,1,2,3,4, v std::generate_n(..., 2, ...): 20,21,0,0,0, Example of range library std :: vector < int > v ( 5 ); ranges :: generate ( v , [ n = 10 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate(...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; v . clear (); v . resize ( 10 ); ranges :: generate_n ( v . begin (), 3 , [ n = 15 ] () mutable { return n ++ ; }); std :: cout << \"v ranges::generate_n(.., 3, ..): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v ranges::generate(...): 10,11,12,13,14, v ranges::generate_n(.., 3, ..): 15,16,17,0,0,0,0,0,0,0, Example of boost library std :: vector < int > v ( 5 ); boost :: range :: generate ( v , [ n = 10 ] () mutable { return n ++ ; }); std :: cout << \"v boost::ranges::generate(...): \" ; std :: for_each ( v . begin (), v . end (), printFunc ); std :: cout << '\\n' ; Output v boost::ranges::generate(...): 10,11,12,13,14, And finally, the performance benchmark Benchmark source code is shared here https://github.com/asit-dhal/range-benchmarks.git Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"generate and generate_n"},{"location":"cpp/string-conversion-benchmark/","text":"String Conversion Benchmark in C++ \u00b6 There are three ways to convert any fundamental data to string. std::to_string std::ostringstream boost::lexical_cast template < typename T > std :: string stringify_ostringstream ( T val ) { std :: ostringstream ss ; ss << val ; return ss . str (); } std :: ostringstream g_buffer ; template < typename T > std :: string stringify_ostringstream_reuse ( T val ) { g_buffer . str ( \"\" ); g_buffer . clear (); g_buffer << val ; return g_buffer . str (); } template < typename T > std :: string stringify_tostring ( T val ) { return std :: to_string ( val ); } In this post, I will analyze which one is the fastest to convert any fundamental(int, double, boolean) data to string. I am using google benchmark to measure the time difference. In all charts, y-axis is time in nano seconds. type=int input_count = 1 \u00b6 For only, one conversion, both std::stringstream and std::ostringstream take nearly same time. boost::lexical_cast in the fastest. And std::to_string is faster than stringstream and slower than boost::lexical_cast. boost::lexical_cast is not the best way for string conversion, because it throws an exception in case of failure. type=int input_count > 30 \u00b6 Here both std::stringstream and std::ostringstream outperform std::to_string and boost::lexical_cast. You can get better result by reusing std::stringstream and std::ostringstream buffer. std :: ostringstream oss ; oss . str ( \u201c\u201d ); oss . clear (); Creating stream objects are very expensive. So, reuse of buffer gives better result. type=double input_count=1 \u00b6 Performance is very similar to integer. Boost lexical_cast outperforms std::to_string and stringstream. type=double input_count=30 \u00b6 For multiple inputs, boost::lexical_cast outperforms everyone else. So, my observations are Always use std::to_string to convert any single value to std::string. In case of double, use std::string. If you need, precision, use std::ostringstream. In all other cases, use std::ostringstream. Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"string conversion benchmark in C++"},{"location":"cpp/string-conversion-benchmark/#string-conversion-benchmark-in-c","text":"There are three ways to convert any fundamental data to string. std::to_string std::ostringstream boost::lexical_cast template < typename T > std :: string stringify_ostringstream ( T val ) { std :: ostringstream ss ; ss << val ; return ss . str (); } std :: ostringstream g_buffer ; template < typename T > std :: string stringify_ostringstream_reuse ( T val ) { g_buffer . str ( \"\" ); g_buffer . clear (); g_buffer << val ; return g_buffer . str (); } template < typename T > std :: string stringify_tostring ( T val ) { return std :: to_string ( val ); } In this post, I will analyze which one is the fastest to convert any fundamental(int, double, boolean) data to string. I am using google benchmark to measure the time difference. In all charts, y-axis is time in nano seconds.","title":"String Conversion Benchmark in C++"},{"location":"cpp/string-conversion-benchmark/#typeint-input_count-1","text":"For only, one conversion, both std::stringstream and std::ostringstream take nearly same time. boost::lexical_cast in the fastest. And std::to_string is faster than stringstream and slower than boost::lexical_cast. boost::lexical_cast is not the best way for string conversion, because it throws an exception in case of failure.","title":"type=int input_count = 1"},{"location":"cpp/string-conversion-benchmark/#typeint-input_count-30","text":"Here both std::stringstream and std::ostringstream outperform std::to_string and boost::lexical_cast. You can get better result by reusing std::stringstream and std::ostringstream buffer. std :: ostringstream oss ; oss . str ( \u201c\u201d ); oss . clear (); Creating stream objects are very expensive. So, reuse of buffer gives better result.","title":"type=int input_count &gt; 30"},{"location":"cpp/string-conversion-benchmark/#typedouble-input_count1","text":"Performance is very similar to integer. Boost lexical_cast outperforms std::to_string and stringstream.","title":"type=double input_count=1"},{"location":"cpp/string-conversion-benchmark/#typedouble-input_count30","text":"For multiple inputs, boost::lexical_cast outperforms everyone else. So, my observations are Always use std::to_string to convert any single value to std::string. In case of double, use std::string. If you need, precision, use std::ostringstream. In all other cases, use std::ostringstream. Image produced: https://github.com/asit-dhal/BenchmarkViewer","title":"type=double input_count=30"},{"location":"git/delete-old-branches-in-git/","text":"Delete old branches in Git \u00b6 Sometimes there are many branches, accumulated over the years in a git repository. And you need to delete it to save some space or make management of your repository easy. To get the list of all local branches \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git branch ci-build-script dev * master remotes/origin/add-license-1 remotes/origin/benchmark After that, you can iterate over all local branches and get some technical details like branch creation date(age of the branch), last commit date, last commit message etc. I will try to delete ci-build-script. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git merge-base ci-build-script master e3b47d97284b911baa266853b208f5ea25115e67 git merge-base tries to find out a good common ancestor. This can be assumed to return the earliest commit id where branch deviates from master branch. You can use the commit id of the common ancestor to get creation date and the age of the branch. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%ad\u201d \u2014 date = short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 2017 \u201309\u201325 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%cr\u201d \u2014 date = short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 6 months ago Similarly, you can use the branch name to get the latest commit date, age of last commit and the subject line of last commit message. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%ad\u201d \u2014 date = short -n 1 ci-build-script 2017 \u201309\u201326 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%cr\u201d \u2014 date = short -n 1 ci-build-script 5 months ago \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log --pretty = format: \"%s\" -n 1 ci-build-script gcc tnd clang config for travis From that you can make an intelligent guess, should you delete the branch or not. The branch ci-build-script was created 5 months ago and last committed 5 months ago. The commit message was \u201cgcc and clang config for travis\u201d. You can delete it git branch -d ci-build-script -d option won\u2019t allow you delete unless it is merged. In some cases branch were never merged. So, you can use -D option You can wrap all the above and make a script. #!/bin/bash # # Copyright(c) 2018 Asit Dhal. # Distributed under the MIT License (http://opensource.org/licenses/MIT) # LIGHT_BLUE = '\\033[1;34m' RED = '\\033[0;31m' NC = '\\033[0m' # No Color INTERACTIVE = \"\" FORCE_DELETE = \"\" MASTER = \"master\" while [[ $# -gt 0 ]] do key = \" $1 \" case $key in -f ) FORCE_DELETE = \"y\" shift ;; -i ) INTERACTIVE = \"i\" shift ;; -fi | -if ) INTERACTIVE = \"i\" FORCE_DELETE = \"y\" shift ;; -h ) echo \" $( basename $0 ) -i Intecative deletion of local branches\" echo \" $( basename $0 ) -f Force delete the branch(es)\" echo \" $( basename $0 ) List local branches with creation and last update date\" exit ;; * ) shift esac done current_branch = $( git branch | grep \"*\" ) current_branch = ${ current_branch /* / } if [ \" ${ current_branch } \" ! = \" ${ MASTER } \" ] ; then printf \"Please change the current branch to ${ LIGHT_BLUE }${ MASTER }${ NC } \\n\" exit fi if ! git diff-files --quiet ; then printf \"you have unstaged changes. $( basename $0 ) needs a clean working index\\n\" git diff-files --name-status printf \"Please commit or stash them.\\n\" exit fi if ! git diff-index --cached --quiet HEAD ; then printf \"your index contains uncommitted changes. $( basename $0 ) needs a clean working index\\n\" git diff-index --cached --name-status HEAD printf \"Please commit or stash them.\\n\" exit fi for brnch in $( git branch | sed / \\* /d ) ; do created_commit_id = $( git merge-base ${ brnch } ${ MASTER } ) created_date = $( git log --pretty = format: \"%ad\" --date = short -n 1 ${ created_commit_id } ) created_ago = $( git log --pretty = format: \"%cr\" --date = short -n 1 ${ created_commit_id } ) last_updated_date = $( git log --pretty = format: \"%ad\" --date = short -n 1 ${ brnch } ) updated_before = $( git log --pretty = format: \"%cr\" --date = short -n 1 ${ brnch } ) commit_message_subject = $( git log --pretty = format: '%s' -n 1 ${ brnch } ) printf \"Branch name : ${ brnch } \\n\" printf \"Created on : ${ created_date }${ RED } ( ${ created_ago } ) ${ NC } \\n\" printf \"Last updated on : ${ last_updated_date }${ RED } ( ${ updated_before }${ NC } )\\n\" printf \"Last commit message : ${ commit_message_subject } \\n\" if [ \" ${ INTERACTIVE } \" == \"i\" ] ; then printf \" ${ LIGHT_BLUE } Delete the branch, followed by [y/n]? ${ NC } \" read ip if [ \" $ip \" == \"y\" ] ; then if [ \" ${ FORCE_DELETE } \" == \"y\" ] ; then git branch -D ${ brnch } else git branch -d ${ brnch } if [ $? -ne 0 ] ; then printf \" ${ LIGHT_BLUE } Run with -fi command to delete ${ brnch }${ NC } \\n\" fi fi fi fi done The script has 2 options: -i and -f-. If the run the script without any options, it will give you list of all local branches and the above information. \u2570\u2500$ git-clean-local-branches Branch name : ci-build-script Created on : 2017 \u201309\u201325 ( 6 months ago ) Last updated on : 2017 \u201309\u201326 ( 5 months ago ) Last commit message : gcc tnd clang config for travis Branch name : dev Created on : 2017 \u201310\u201314 ( 5 months ago ) Last updated on : 2017 \u201311\u201325 ( 4 months ago ) Last commit message : stringify improvement, size and type name removal Branch name : remotes/origin/add-license-1 Created on : 2017 \u201310\u201314 ( 5 months ago ) Last updated on : 2017 \u201310\u201314 ( 5 months ago ) Last commit message : Create LICENSE Branch name : remotes/origin/benchmark Created on : 2017 \u201310\u201306 ( 5 months ago ) Last updated on : 2017 \u201310\u201316 ( 5 months ago ) Last commit message : cxx-pretty print integration -i option allows you interactive deletion. -f option uses git delete -D(force delete). \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git-clean-local-branches -fi Branch name : ci-build-script Created on : 2017 \u201309\u201325 ( 6 months ago ) Last updated on : 2017 \u201309\u201326 ( 5 months ago ) Last commit message : gcc tnd clang config for travis Delete the branch, followed by [ y/n ] ? y Deleted branch ci-build-script ( was 2cb728c ) . Branch name : dev Created on : 2017 \u201310\u201314 ( 5 months ago ) Last updated on : 2017 \u201311\u201325 ( 4 months ago ) Last commit message : stringify improvement, size and type name removal Delete the branch, followed by [ y/n ] ? y Deleted branch dev ( was f8698b4 ) . Thanks for reading.","title":"Delete old branches in Git"},{"location":"git/delete-old-branches-in-git/#delete-old-branches-in-git","text":"Sometimes there are many branches, accumulated over the years in a git repository. And you need to delete it to save some space or make management of your repository easy. To get the list of all local branches \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git branch ci-build-script dev * master remotes/origin/add-license-1 remotes/origin/benchmark After that, you can iterate over all local branches and get some technical details like branch creation date(age of the branch), last commit date, last commit message etc. I will try to delete ci-build-script. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git merge-base ci-build-script master e3b47d97284b911baa266853b208f5ea25115e67 git merge-base tries to find out a good common ancestor. This can be assumed to return the earliest commit id where branch deviates from master branch. You can use the commit id of the common ancestor to get creation date and the age of the branch. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%ad\u201d \u2014 date = short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 2017 \u201309\u201325 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%cr\u201d \u2014 date = short -n 1 e3b47d97284b911baa266853b208f5ea25115e67 6 months ago Similarly, you can use the branch name to get the latest commit date, age of last commit and the subject line of last commit message. \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%ad\u201d \u2014 date = short -n 1 ci-build-script 2017 \u201309\u201326 \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log \u2014 pretty = format:\u201d%cr\u201d \u2014 date = short -n 1 ci-build-script 5 months ago \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git log --pretty = format: \"%s\" -n 1 ci-build-script gcc tnd clang config for travis From that you can make an intelligent guess, should you delete the branch or not. The branch ci-build-script was created 5 months ago and last committed 5 months ago. The commit message was \u201cgcc and clang config for travis\u201d. You can delete it git branch -d ci-build-script -d option won\u2019t allow you delete unless it is merged. In some cases branch were never merged. So, you can use -D option You can wrap all the above and make a script. #!/bin/bash # # Copyright(c) 2018 Asit Dhal. # Distributed under the MIT License (http://opensource.org/licenses/MIT) # LIGHT_BLUE = '\\033[1;34m' RED = '\\033[0;31m' NC = '\\033[0m' # No Color INTERACTIVE = \"\" FORCE_DELETE = \"\" MASTER = \"master\" while [[ $# -gt 0 ]] do key = \" $1 \" case $key in -f ) FORCE_DELETE = \"y\" shift ;; -i ) INTERACTIVE = \"i\" shift ;; -fi | -if ) INTERACTIVE = \"i\" FORCE_DELETE = \"y\" shift ;; -h ) echo \" $( basename $0 ) -i Intecative deletion of local branches\" echo \" $( basename $0 ) -f Force delete the branch(es)\" echo \" $( basename $0 ) List local branches with creation and last update date\" exit ;; * ) shift esac done current_branch = $( git branch | grep \"*\" ) current_branch = ${ current_branch /* / } if [ \" ${ current_branch } \" ! = \" ${ MASTER } \" ] ; then printf \"Please change the current branch to ${ LIGHT_BLUE }${ MASTER }${ NC } \\n\" exit fi if ! git diff-files --quiet ; then printf \"you have unstaged changes. $( basename $0 ) needs a clean working index\\n\" git diff-files --name-status printf \"Please commit or stash them.\\n\" exit fi if ! git diff-index --cached --quiet HEAD ; then printf \"your index contains uncommitted changes. $( basename $0 ) needs a clean working index\\n\" git diff-index --cached --name-status HEAD printf \"Please commit or stash them.\\n\" exit fi for brnch in $( git branch | sed / \\* /d ) ; do created_commit_id = $( git merge-base ${ brnch } ${ MASTER } ) created_date = $( git log --pretty = format: \"%ad\" --date = short -n 1 ${ created_commit_id } ) created_ago = $( git log --pretty = format: \"%cr\" --date = short -n 1 ${ created_commit_id } ) last_updated_date = $( git log --pretty = format: \"%ad\" --date = short -n 1 ${ brnch } ) updated_before = $( git log --pretty = format: \"%cr\" --date = short -n 1 ${ brnch } ) commit_message_subject = $( git log --pretty = format: '%s' -n 1 ${ brnch } ) printf \"Branch name : ${ brnch } \\n\" printf \"Created on : ${ created_date }${ RED } ( ${ created_ago } ) ${ NC } \\n\" printf \"Last updated on : ${ last_updated_date }${ RED } ( ${ updated_before }${ NC } )\\n\" printf \"Last commit message : ${ commit_message_subject } \\n\" if [ \" ${ INTERACTIVE } \" == \"i\" ] ; then printf \" ${ LIGHT_BLUE } Delete the branch, followed by [y/n]? ${ NC } \" read ip if [ \" $ip \" == \"y\" ] ; then if [ \" ${ FORCE_DELETE } \" == \"y\" ] ; then git branch -D ${ brnch } else git branch -d ${ brnch } if [ $? -ne 0 ] ; then printf \" ${ LIGHT_BLUE } Run with -fi command to delete ${ brnch }${ NC } \\n\" fi fi fi fi done The script has 2 options: -i and -f-. If the run the script without any options, it will give you list of all local branches and the above information. \u2570\u2500$ git-clean-local-branches Branch name : ci-build-script Created on : 2017 \u201309\u201325 ( 6 months ago ) Last updated on : 2017 \u201309\u201326 ( 5 months ago ) Last commit message : gcc tnd clang config for travis Branch name : dev Created on : 2017 \u201310\u201314 ( 5 months ago ) Last updated on : 2017 \u201311\u201325 ( 4 months ago ) Last commit message : stringify improvement, size and type name removal Branch name : remotes/origin/add-license-1 Created on : 2017 \u201310\u201314 ( 5 months ago ) Last updated on : 2017 \u201310\u201314 ( 5 months ago ) Last commit message : Create LICENSE Branch name : remotes/origin/benchmark Created on : 2017 \u201310\u201306 ( 5 months ago ) Last updated on : 2017 \u201310\u201316 ( 5 months ago ) Last commit message : cxx-pretty print integration -i option allows you interactive deletion. -f option uses git delete -D(force delete). \u256d\u2500asit@gandua ~/stringify \u2039master*\u203a \u2570\u2500$ git-clean-local-branches -fi Branch name : ci-build-script Created on : 2017 \u201309\u201325 ( 6 months ago ) Last updated on : 2017 \u201309\u201326 ( 5 months ago ) Last commit message : gcc tnd clang config for travis Delete the branch, followed by [ y/n ] ? y Deleted branch ci-build-script ( was 2cb728c ) . Branch name : dev Created on : 2017 \u201310\u201314 ( 5 months ago ) Last updated on : 2017 \u201311\u201325 ( 4 months ago ) Last commit message : stringify improvement, size and type name removal Delete the branch, followed by [ y/n ] ? y Deleted branch dev ( was f8698b4 ) . Thanks for reading.","title":"Delete old branches in Git"},{"location":"golang/golang-slice-and-append/","text":"Golang slice and append \u00b6 In Golang, a slice is a reference to a contiguous segment of an array. Slice is basically a pointer, with additional properties about the array. A slice is a structure of 3 fields. a pointer to the underlying array length of the slice capacity of the slice You can see this in slice.go, here https://github.com/golang/go/blob/master/src/runtime/slice.go // slice1.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:3] var slice2 []int = arr1[2:] fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) arr1[2] = 35 fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) } Output array: [10 20 30 40 50] len: 5 slice1: [20 30] len: 2 cap: 4 slice2: [30 40 50] len: 3 cap: 3 array: [10 20 35 40 50] len: 5 slice1: [20 35] len: 2 cap: 4 slice2: [35 40 50] len: 3 cap: 3 Both the slices point to the same memory, any changes to the actual data will impact all the slices pointing to the array. So, if you have an array and many slices pointing to the same array, there can be many places where the array can be changed. So, this is a disaster going to happen. You should avoid exposing the array and always keep it anonymous. Golang provides make() to achieve this objective. make() allows us to create a slice when the underlying array is not defined. slice1 := make([]type, len) //case 1 slice2 := make([]type, len, cap) // case 2 In the first case, the slice is pointing to an array of length \u2018len\u2019. Here, the following statement is true cap(slice1) = len(slice1) = len In the second case, slice2 doesn\u2019t occupy the entire underlying array. The array has a length \u2018cap\u2019 and slice has length \u2018len\u2019. There is space for reslicing. Reslicing \u00b6 Changing the length of the slice is called reslicing. It is done by increasing the end index of the slice, until it occupies the entire array. Increase the slice length by 1 s = s[0:len(s)+1] Slice length can be reached upto the capacity. If the length crosses the capacity, it will panic at run time. The capacity is a limitation in reslicing. So, golang provides an built-in function append() to fix this issue. The built-in append() does the following append() appends zero or more values to a slice and returns the resulting slice. allocates a new, sufficiently large slice always succeeds, unless the computer runs out of memory append() may either modify its argument in-place or return a copy of its argument with an additional entry, depending on the size and capacity of its input. append() function creates a new slice, if the length the slice is greater than the length of the array pointed by the slice. // append.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:4] fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //modify the underlying array slice1 = append(slice1, 56) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //creates a new array and returns slice pointing to it slice1 = append(slice1, 69) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) } Output array: [10 20 30 40 50] slice1: [20 30 40] array: [10 20 30 40 56] slice1: [20 30 40 56] array: [10 20 30 40 56] slice1: [20 30 40 56 69] In the first append(), the argument is modified and in the 2nd append(), a new slice is created.","title":"Golang slice and append"},{"location":"golang/golang-slice-and-append/#golang-slice-and-append","text":"In Golang, a slice is a reference to a contiguous segment of an array. Slice is basically a pointer, with additional properties about the array. A slice is a structure of 3 fields. a pointer to the underlying array length of the slice capacity of the slice You can see this in slice.go, here https://github.com/golang/go/blob/master/src/runtime/slice.go // slice1.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:3] var slice2 []int = arr1[2:] fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) arr1[2] = 35 fmt.Printf(\"array: %v len: %d\\n\", arr1, len(arr1)) fmt.Printf(\"slice1: %v len: %d cap: %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2: %v len: %d cap: %d\\n\", slice2, len(slice2), cap(slice2)) } Output array: [10 20 30 40 50] len: 5 slice1: [20 30] len: 2 cap: 4 slice2: [30 40 50] len: 3 cap: 3 array: [10 20 35 40 50] len: 5 slice1: [20 35] len: 2 cap: 4 slice2: [35 40 50] len: 3 cap: 3 Both the slices point to the same memory, any changes to the actual data will impact all the slices pointing to the array. So, if you have an array and many slices pointing to the same array, there can be many places where the array can be changed. So, this is a disaster going to happen. You should avoid exposing the array and always keep it anonymous. Golang provides make() to achieve this objective. make() allows us to create a slice when the underlying array is not defined. slice1 := make([]type, len) //case 1 slice2 := make([]type, len, cap) // case 2 In the first case, the slice is pointing to an array of length \u2018len\u2019. Here, the following statement is true cap(slice1) = len(slice1) = len In the second case, slice2 doesn\u2019t occupy the entire underlying array. The array has a length \u2018cap\u2019 and slice has length \u2018len\u2019. There is space for reslicing.","title":"Golang slice and append"},{"location":"golang/golang-slice-and-append/#reslicing","text":"Changing the length of the slice is called reslicing. It is done by increasing the end index of the slice, until it occupies the entire array. Increase the slice length by 1 s = s[0:len(s)+1] Slice length can be reached upto the capacity. If the length crosses the capacity, it will panic at run time. The capacity is a limitation in reslicing. So, golang provides an built-in function append() to fix this issue. The built-in append() does the following append() appends zero or more values to a slice and returns the resulting slice. allocates a new, sufficiently large slice always succeeds, unless the computer runs out of memory append() may either modify its argument in-place or return a copy of its argument with an additional entry, depending on the size and capacity of its input. append() function creates a new slice, if the length the slice is greater than the length of the array pointed by the slice. // append.go package main import ( \"fmt\" ) func main() { var arr1 = [5]int { 10, 20, 30, 40, 50} var slice1 []int = arr1[1:4] fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //modify the underlying array slice1 = append(slice1, 56) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) //creates a new array and returns slice pointing to it slice1 = append(slice1, 69) fmt.Printf(\"array: %v\\n\", arr1) fmt.Printf(\"slice1: %v\\n\", slice1) } Output array: [10 20 30 40 50] slice1: [20 30 40] array: [10 20 30 40 56] slice1: [20 30 40 56] array: [10 20 30 40 56] slice1: [20 30 40 56 69] In the first append(), the argument is modified and in the 2nd append(), a new slice is created.","title":"Reslicing"},{"location":"golang/golang-templates-1-introduction/","text":"Golang Templates-1: Introduction \u00b6 A template engine is a software application which generates dynamic HTML. This can be assumed as the view of the MVC paradigm. But, in reality, the template is exactly not view, a little bit of controller logic is added to make not too rigid. In Golang, the handler(controller) calls the template engine, passing it the template(s) to be used, usually as a list of template files and the dynamic data. The template engine then generates the HTML and writes it to the ResponseWriter, which adds it to the HTTP response sends back to the client. A template is a string or file containing one or more portions enclosed in double braces, {{\u2026}} , called actions. These actions are processed by the template engine to produce dynamic HTML. Steps to produce HTML from template file \u00b6 Parse the template string/file to create a parsed template struct. Execute the parsed template, passing a ResponseWriter and some data to it. // main.go package main import ( \"net/http\" \"html/template\" ) func handler(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"view.html\") //setp 1 t.Execute(w, \"Hello World!\") //step 2 } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } <!-- view.html--> < html > < head > < title > First Program </ title > </ head > < body > {{ . }} </ body > </ html > Template Names \u00b6 All templates are associated with a name. Template name are defined using template.New(). In case of ParseFiles() and ParseGlob(), the first file in the argument list and the first file picked up are the names respectively. https://golang.org/pkg/html/template/#New Templates can be looked up by using the name(template.Lookup()). https://golang.org/pkg/html/template/#Template.Lookup . Template name can be queried(template.Name()) https://golang.org/pkg/html/template/#Template.Name . Parsing Templates \u00b6 template.Parse() method takes a string and returns a parsed structured template. // main2.go package main import ( \"html/template\" \"net/http\" ) var tmpl = `<html> <head> <title>Hello World!</title> </head> <body> {{ . }} </body> </html> ` func handler(w http.ResponseWriter, r *http.Request) { t := template.New(\"main\") //name of the template is main t, _ = t.Parse(tmpl) // parsing of template string t.Execute(w, \"Hello World!\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } template.ParseFiles() is a variadic function call. It takes variable number arguments. template.ParseGlob() uses pattern matching. Both of the above functions return a set of parsed templates. The returned template name will be the first file in PraseFiles() and the first file matched in the regular expression in ParseGlob(). https://golang.org/pkg/text/template/#ParseFiles // main3.go package main import ( \"net/http\" \"html/template\" ) func handler1(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.Execute(w, \"Asit\") } func handler2(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.ExecuteTemplate(w, \"t2.html\", \"Golang\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/t1\", handler1) http.HandleFunc(\"/t2\", handler2) server.ListenAndServe() } <!-- t1.html--> < html > < head > < title > T1 template </ title > </ head > < body > Hi, My name is {{ . }}. </ body > </ html > <!-- t2.html--> < html > < head > < title > T2 template </ title > </ head > < body > Hi, I am learning {{ . }}. </ body > </ html > Executing Templates \u00b6 The template.Execute() method applies a parsed template to the specified data object and writes the output to an output writer.The template.ExecuteTemplate() method works if the template contains multiple parsed template object. This is shown in the previous example. template.ExecuteTemplate() calls template.Execute() internally. It basically looks for the named template and executes that one. In Golang library, you can see the implementation . Error Handling \u00b6 All three parse methods returns error in case of failure. The standard library provides template.Must(), which wraps around a function that returns a pointer to a template and an error, and panics if the error is not a nil. t := template.Must(template.ParseFiles(\"tmpl.html\")) While Executing, both the methods may fail and return error. But, by that time, some data might have been written to the buffer and sent back to browser. The programmer should handle this situation.","title":"Golang Templates-1 Introduction"},{"location":"golang/golang-templates-1-introduction/#golang-templates-1-introduction","text":"A template engine is a software application which generates dynamic HTML. This can be assumed as the view of the MVC paradigm. But, in reality, the template is exactly not view, a little bit of controller logic is added to make not too rigid. In Golang, the handler(controller) calls the template engine, passing it the template(s) to be used, usually as a list of template files and the dynamic data. The template engine then generates the HTML and writes it to the ResponseWriter, which adds it to the HTTP response sends back to the client. A template is a string or file containing one or more portions enclosed in double braces, {{\u2026}} , called actions. These actions are processed by the template engine to produce dynamic HTML.","title":"Golang Templates-1: Introduction"},{"location":"golang/golang-templates-1-introduction/#steps-to-produce-html-from-template-file","text":"Parse the template string/file to create a parsed template struct. Execute the parsed template, passing a ResponseWriter and some data to it. // main.go package main import ( \"net/http\" \"html/template\" ) func handler(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"view.html\") //setp 1 t.Execute(w, \"Hello World!\") //step 2 } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } <!-- view.html--> < html > < head > < title > First Program </ title > </ head > < body > {{ . }} </ body > </ html >","title":"Steps to produce HTML from template file"},{"location":"golang/golang-templates-1-introduction/#template-names","text":"All templates are associated with a name. Template name are defined using template.New(). In case of ParseFiles() and ParseGlob(), the first file in the argument list and the first file picked up are the names respectively. https://golang.org/pkg/html/template/#New Templates can be looked up by using the name(template.Lookup()). https://golang.org/pkg/html/template/#Template.Lookup . Template name can be queried(template.Name()) https://golang.org/pkg/html/template/#Template.Name .","title":"Template Names"},{"location":"golang/golang-templates-1-introduction/#parsing-templates","text":"template.Parse() method takes a string and returns a parsed structured template. // main2.go package main import ( \"html/template\" \"net/http\" ) var tmpl = `<html> <head> <title>Hello World!</title> </head> <body> {{ . }} </body> </html> ` func handler(w http.ResponseWriter, r *http.Request) { t := template.New(\"main\") //name of the template is main t, _ = t.Parse(tmpl) // parsing of template string t.Execute(w, \"Hello World!\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/view\", handler) server.ListenAndServe() } template.ParseFiles() is a variadic function call. It takes variable number arguments. template.ParseGlob() uses pattern matching. Both of the above functions return a set of parsed templates. The returned template name will be the first file in PraseFiles() and the first file matched in the regular expression in ParseGlob(). https://golang.org/pkg/text/template/#ParseFiles // main3.go package main import ( \"net/http\" \"html/template\" ) func handler1(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.Execute(w, \"Asit\") } func handler2(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(\"t1.html\", \"t2.html\") t.ExecuteTemplate(w, \"t2.html\", \"Golang\") } func main() { server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/t1\", handler1) http.HandleFunc(\"/t2\", handler2) server.ListenAndServe() } <!-- t1.html--> < html > < head > < title > T1 template </ title > </ head > < body > Hi, My name is {{ . }}. </ body > </ html > <!-- t2.html--> < html > < head > < title > T2 template </ title > </ head > < body > Hi, I am learning {{ . }}. </ body > </ html >","title":"Parsing Templates"},{"location":"golang/golang-templates-1-introduction/#executing-templates","text":"The template.Execute() method applies a parsed template to the specified data object and writes the output to an output writer.The template.ExecuteTemplate() method works if the template contains multiple parsed template object. This is shown in the previous example. template.ExecuteTemplate() calls template.Execute() internally. It basically looks for the named template and executes that one. In Golang library, you can see the implementation .","title":"Executing Templates"},{"location":"golang/golang-templates-1-introduction/#error-handling","text":"All three parse methods returns error in case of failure. The standard library provides template.Must(), which wraps around a function that returns a pointer to a template and an error, and panics if the error is not a nil. t := template.Must(template.ParseFiles(\"tmpl.html\")) While Executing, both the methods may fail and return error. But, by that time, some data might have been written to the buffer and sent back to browser. The programmer should handle this situation.","title":"Error Handling"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/","text":"Golang Template-2: Template composition \u00b6 Golang template library provides certain actions to make an efficient and flexible use of multiple template files. define action {{define \"templ_name\"}}second template{{end}} Here, a template with name \u201ctempl_name\u201d is defined. // defineActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var defineDemo = ` {{ define \"a\" }} Template A {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"defineActionDemo\") t, err = t.Parse(defineDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } fmt.Println() err = t.ExecuteTemplate(os.Stdout, \"b\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } c:\\medium\\src>go build defineActionDemo.go c:\\medium\\src>defineActionDemo Template A Template B If there multiple definitions of same template, except one, all other should be empty. template action \u00b6 {{template \"templ_name\" }} {{template \"templ_name\" pipeline}} Here, the template with name \u201ctempl_name\u201d will be executed and output will be rendered at the same place. Output Template A includes Template B Template B Template A ends // templateActionDemo.go package main import ( \"html/template\" \"os\" \"fmt\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ template \"b\" .}} Template A ends {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } block action \u00b6 Block action is defining a template and executing in place. {{block \"name\" pipeline}} huuw {{end}} // blockActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ block \"b\" .}} Template B {{ end }} Template A ends {{ end }} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } Output Template A includes Template B Template B Template A ends All these three actions are very powerful. Template composition(nested template or template embedding or template inheritance) can be achieved. Empty template can be used as placeholder templates. How to organize template files ? \u00b6 We keep our template files in two directories. One is the layout and other is the application specific views. The layout will contain base template and other common templates. base.tmpl will contain the skeleton of HTML page for the entire website. <!-- base.tmpl --> {{ define \"base\" }} < html > < head > < title > {{block \"title\" .}} {{end}} </ title > {{block \"style\" .}} {{end}} </ head > < body > < body > {{template \"content\" .}} </ body > < footer > {{block \"footer\" .}} {{end}} </ footer > {{block \"js\" .}} {{end}} </ body > </ html > {{ end }} <!-- js.tmpl --> {{ define \"js\" }} < script type = \"javascript\" > console . log ( \"a small js\" ); </ script > {{ end }} <!-- style.tmpl --> {{define \"style\"}} < style > body { background-color : lightblue ; } h1 { color : navy ; margin-left : 20 px ; } </ style > {{end}} Now, all other templates which is a view to user. Each of these will be rendered individually. <!-- aboutme.tmpl --> {{define \"title\"}}About Me{{end}} {{define \"content\"}} < h2 > This is About me page. </ h2 > < ul > < li > My name is {{ .Name }}. </ li > < li > My home city is {{ .City }}. </ li > < li > My nationaliy is {{ .Nationality }}. </ li > </ ul > < p >< a href = \"/\" > Home </ a ></ p > {{end}} <!-- index.tmpl --> {{define \"title\"}}Home{{end}} {{define \"content\"}} < ul > < li >< a href = \"/skillset\" > Skillset </ a ></ li > < li >< a href = \"/aboutme\" > About Me </ a ></ li > </ ul > {{end}} <!-- skillset.tmpl --> {{define \"title\"}}Skillset{{end}} {{define \"content\"}} < h3 > My Skillset </ h3 > < table class = \"table\" > < thead > < tr > < th > Language </ th > < th > Level </ th > </ tr > </ thead > < tbody > {{ range . }} < tr > < td > {{ .Language }} </ td > < td > {{ .Level }} </ td > </ tr > {{ end }} </ tbody > </ table > < p > < a href = \"/\" > Home </ a ></ p > {{end}} In Go, we need to do the following. //golang package main import ( \"fmt\" \"github.com/oxtoacart/bpool\" \"html/template\" \"log\" \"net/http\" \"path/filepath\" ) var templates map[string]*template.Template var bufpool *bpool.BufferPool type UserData struct { Name string City string Nationality string } type SkillSet struct { Language string Level string } type TemplateConfig struct { TemplateLayoutPath string TemplateIncludePath string } type SkillSets []*SkillSet var mainTmpl = `{{define \"main\" }} {{ template \"base\" . }} {{ end }}` var templateConfig TemplateConfig func loadConfiguration() { templateConfig.TemplateLayoutPath = \"templates/layouts/\" templateConfig.TemplateIncludePath = \"templates/\" } func loadTemplates() { if templates == nil { templates = make(map[string]*template.Template) } layoutFiles, err := filepath.Glob(templateConfig.TemplateLayoutPath + \"*.tmpl\") if err != nil { log.Fatal(err) } includeFiles, err := filepath.Glob(templateConfig.TemplateIncludePath + \"*.tmpl\") if err != nil { log.Fatal(err) } mainTemplate := template.New(\"main\") mainTemplate, err = mainTemplate.Parse(mainTmpl) if err != nil { log.Fatal(err) } for _, file := range includeFiles { fileName := filepath.Base(file) files := append(layoutFiles, file) templates[fileName], err = mainTemplate.Clone() if err != nil { log.Fatal(err) } templates[fileName] = template.Must(templates[fileName].ParseFiles(files...)) } log.Println(\"templates loading successful\") bufpool = bpool.NewBufferPool(64) log.Println(\"buffer allocation successful\") } func renderTemplate(w http.ResponseWriter, name string, data interface{}) { tmpl, ok := templates[name] if !ok { http.Error(w, fmt.Sprintf(\"The template %s does not exist.\", name), http.StatusInternalServerError) } buf := bufpool.Get() defer bufpool.Put(buf) err := tmpl.Execute(buf, data) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\") buf.WriteTo(w) } func index(w http.ResponseWriter, r *http.Request) { renderTemplate(w, \"index.tmpl\", nil) } func aboutMe(w http.ResponseWriter, r *http.Request) { userData := &UserData{Name: \"Asit Dhal\", City: \"Bhubaneswar\", Nationality: \"Indian\"} renderTemplate(w, \"aboutme.tmpl\", userData) } func skillSet(w http.ResponseWriter, r *http.Request) { skillSets := SkillSets{&SkillSet{Language: \"Golang\", Level: \"Beginner\"}, &SkillSet{Language: \"C++\", Level: \"Advanced\"}, &SkillSet{Language: \"Python\", Level: \"Advanced\"}} renderTemplate(w, \"skillset.tmpl\", skillSets) } func main() { loadConfiguration() loadTemplates() server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/\", index) http.HandleFunc(\"/aboutme\", aboutMe) http.HandleFunc(\"/skillset\", skillSet) server.ListenAndServe() } Before the application starts to listen for HTTP request, all template files are loaded. Every time there is a request, the specific template is executed. Working example: https://github.com/asit-dhal/golang-template-layout . Thanks for reading !!","title":"Golang Template-2 Template composition"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#golang-template-2-template-composition","text":"Golang template library provides certain actions to make an efficient and flexible use of multiple template files. define action {{define \"templ_name\"}}second template{{end}} Here, a template with name \u201ctempl_name\u201d is defined. // defineActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var defineDemo = ` {{ define \"a\" }} Template A {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"defineActionDemo\") t, err = t.Parse(defineDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } fmt.Println() err = t.ExecuteTemplate(os.Stdout, \"b\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } c:\\medium\\src>go build defineActionDemo.go c:\\medium\\src>defineActionDemo Template A Template B If there multiple definitions of same template, except one, all other should be empty.","title":"Golang Template-2: Template composition"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#template-action","text":"{{template \"templ_name\" }} {{template \"templ_name\" pipeline}} Here, the template with name \u201ctempl_name\u201d will be executed and output will be rendered at the same place. Output Template A includes Template B Template B Template A ends // templateActionDemo.go package main import ( \"html/template\" \"os\" \"fmt\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ template \"b\" .}} Template A ends {{ end }} {{define \"b\"}} Template B {{end}} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } }","title":"template action"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#block-action","text":"Block action is defining a template and executing in place. {{block \"name\" pipeline}} huuw {{end}} // blockActionDemo.go package main import ( \"fmt\" \"html/template\" \"os\" ) var templateDemo = ` {{ define \"a\" }} Template A includes Template B {{ block \"b\" .}} Template B {{ end }} Template A ends {{ end }} ` func main() { var err error t := template.New(\"templateActionDemo\") t, err = t.Parse(templateDemo) if err != nil { fmt.Println(\"parsing failed: %s\", err) } err = t.ExecuteTemplate(os.Stdout, \"a\", nil) if err != nil { fmt.Println(\"execution failed: %s\", err) } } Output Template A includes Template B Template B Template A ends All these three actions are very powerful. Template composition(nested template or template embedding or template inheritance) can be achieved. Empty template can be used as placeholder templates.","title":"block action"},{"location":"golang/golang-templates-2-template-composition-and-how-to-organize-template-files/#how-to-organize-template-files","text":"We keep our template files in two directories. One is the layout and other is the application specific views. The layout will contain base template and other common templates. base.tmpl will contain the skeleton of HTML page for the entire website. <!-- base.tmpl --> {{ define \"base\" }} < html > < head > < title > {{block \"title\" .}} {{end}} </ title > {{block \"style\" .}} {{end}} </ head > < body > < body > {{template \"content\" .}} </ body > < footer > {{block \"footer\" .}} {{end}} </ footer > {{block \"js\" .}} {{end}} </ body > </ html > {{ end }} <!-- js.tmpl --> {{ define \"js\" }} < script type = \"javascript\" > console . log ( \"a small js\" ); </ script > {{ end }} <!-- style.tmpl --> {{define \"style\"}} < style > body { background-color : lightblue ; } h1 { color : navy ; margin-left : 20 px ; } </ style > {{end}} Now, all other templates which is a view to user. Each of these will be rendered individually. <!-- aboutme.tmpl --> {{define \"title\"}}About Me{{end}} {{define \"content\"}} < h2 > This is About me page. </ h2 > < ul > < li > My name is {{ .Name }}. </ li > < li > My home city is {{ .City }}. </ li > < li > My nationaliy is {{ .Nationality }}. </ li > </ ul > < p >< a href = \"/\" > Home </ a ></ p > {{end}} <!-- index.tmpl --> {{define \"title\"}}Home{{end}} {{define \"content\"}} < ul > < li >< a href = \"/skillset\" > Skillset </ a ></ li > < li >< a href = \"/aboutme\" > About Me </ a ></ li > </ ul > {{end}} <!-- skillset.tmpl --> {{define \"title\"}}Skillset{{end}} {{define \"content\"}} < h3 > My Skillset </ h3 > < table class = \"table\" > < thead > < tr > < th > Language </ th > < th > Level </ th > </ tr > </ thead > < tbody > {{ range . }} < tr > < td > {{ .Language }} </ td > < td > {{ .Level }} </ td > </ tr > {{ end }} </ tbody > </ table > < p > < a href = \"/\" > Home </ a ></ p > {{end}} In Go, we need to do the following. //golang package main import ( \"fmt\" \"github.com/oxtoacart/bpool\" \"html/template\" \"log\" \"net/http\" \"path/filepath\" ) var templates map[string]*template.Template var bufpool *bpool.BufferPool type UserData struct { Name string City string Nationality string } type SkillSet struct { Language string Level string } type TemplateConfig struct { TemplateLayoutPath string TemplateIncludePath string } type SkillSets []*SkillSet var mainTmpl = `{{define \"main\" }} {{ template \"base\" . }} {{ end }}` var templateConfig TemplateConfig func loadConfiguration() { templateConfig.TemplateLayoutPath = \"templates/layouts/\" templateConfig.TemplateIncludePath = \"templates/\" } func loadTemplates() { if templates == nil { templates = make(map[string]*template.Template) } layoutFiles, err := filepath.Glob(templateConfig.TemplateLayoutPath + \"*.tmpl\") if err != nil { log.Fatal(err) } includeFiles, err := filepath.Glob(templateConfig.TemplateIncludePath + \"*.tmpl\") if err != nil { log.Fatal(err) } mainTemplate := template.New(\"main\") mainTemplate, err = mainTemplate.Parse(mainTmpl) if err != nil { log.Fatal(err) } for _, file := range includeFiles { fileName := filepath.Base(file) files := append(layoutFiles, file) templates[fileName], err = mainTemplate.Clone() if err != nil { log.Fatal(err) } templates[fileName] = template.Must(templates[fileName].ParseFiles(files...)) } log.Println(\"templates loading successful\") bufpool = bpool.NewBufferPool(64) log.Println(\"buffer allocation successful\") } func renderTemplate(w http.ResponseWriter, name string, data interface{}) { tmpl, ok := templates[name] if !ok { http.Error(w, fmt.Sprintf(\"The template %s does not exist.\", name), http.StatusInternalServerError) } buf := bufpool.Get() defer bufpool.Put(buf) err := tmpl.Execute(buf, data) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\") buf.WriteTo(w) } func index(w http.ResponseWriter, r *http.Request) { renderTemplate(w, \"index.tmpl\", nil) } func aboutMe(w http.ResponseWriter, r *http.Request) { userData := &UserData{Name: \"Asit Dhal\", City: \"Bhubaneswar\", Nationality: \"Indian\"} renderTemplate(w, \"aboutme.tmpl\", userData) } func skillSet(w http.ResponseWriter, r *http.Request) { skillSets := SkillSets{&SkillSet{Language: \"Golang\", Level: \"Beginner\"}, &SkillSet{Language: \"C++\", Level: \"Advanced\"}, &SkillSet{Language: \"Python\", Level: \"Advanced\"}} renderTemplate(w, \"skillset.tmpl\", skillSets) } func main() { loadConfiguration() loadTemplates() server := http.Server{ Addr: \"127.0.0.1:8080\", } http.HandleFunc(\"/\", index) http.HandleFunc(\"/aboutme\", aboutMe) http.HandleFunc(\"/skillset\", skillSet) server.ListenAndServe() } Before the application starts to listen for HTTP request, all template files are loaded. Every time there is a request, the specific template is executed. Working example: https://github.com/asit-dhal/golang-template-layout . Thanks for reading !!","title":"How to organize template files ?"},{"location":"juce/broadcasters-and-listeners-in-juce/","text":"Broadcasters and listeners in JUCE \u00b6 Juce uses broadcasters and listeners pattern to propagate state changes. This is like classical observer pattern. Broadcasters are subjects and listeners are observers. Juce Framework provides predefined library to automate this process. Let\u2019s say we have a Window with a slider and a label. When the user changes the slider position, the label will show the value. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; private : Slider m_valueSlider ; Label m_sliderLabel ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_valueSlider ); m_valueSlider . setRange ( 10 , 100 ); m_valueSlider . setTextValueSuffix ( \" Cnt\" ); m_valueSlider . setTextBoxStyle ( Slider :: TextEntryBoxPosition :: NoTextBox , false , 0 , 0 ); addAndMakeVisible ( m_sliderLabel ); m_sliderLabel . setText ( \"Value\" , dontSendNotification ); setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto sliderLeft = 120 ; m_valueSlider . setBounds ( sliderLeft , 20 , getWidth () - sliderLeft - 10 , 20 ); m_sliderLabel . setBounds ( sliderLeft , 50 , getWidth () - sliderLeft - 10 , 20 ); } At this moment both the slider and the label don\u2019t interact with each other. We are going to show the value of slider in the label. Listeners \u00b6 Most Juce components have an inner class called Listener. This class is an abstract class with at least one pure virtual function. An observer has to inherit from this abstract class and implement the pure virtual function(s). This pure virtual function is the callback. one member function called void addListener(Listener* listener). Using this function, an observer can register it self. another member function called void removeListener(Listener* listener). This one removes the previously registered listener. Whenever a listener is registered, the address is stored in a ListenerList container. Whenever the state changes, the broadcaster iterates over all the registered listeners and calls the appropriate callback. Slider::Listener provides Slider::Listener::sliderValueChanged( Slider *slide) . We can override that function in the MainComponent. Then register the main component as a listener. In the implementation of sliderValueChanged, we can set the value of the slider in the label. //MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component , public Slider :: Listener // step 1: inherit the listener abstract class { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; // step 2: implementation of pure virtual function void sliderValueChanged ( Slider * slider ) override ; private : Slider m_valueSlider ; Label m_sliderLabel ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; //MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_valueSlider ); m_valueSlider . setRange ( 10 , 100 ); m_valueSlider . setTextValueSuffix ( \" Cnt\" ); m_valueSlider . setTextBoxStyle ( Slider :: TextEntryBoxPosition :: NoTextBox , false , 0 , 0 ); addAndMakeVisible ( m_sliderLabel ); m_sliderLabel . setText ( \"Value\" , dontSendNotification ); setSize ( 600 , 400 ); // step 3: register the listener m_valueSlider . addListener ( this ); } MainComponent ::~ MainComponent () { // step 5: unregister the listener m_valueSlider . removeListener ( this ); } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto sliderLeft = 120 ; m_valueSlider . setBounds ( sliderLeft , 20 , getWidth () - sliderLeft - 10 , 20 ); m_sliderLabel . setBounds ( sliderLeft , 50 , getWidth () - sliderLeft - 10 , 20 ); } void MainComponent :: sliderValueChanged ( Slider * slider ) { // step 4: when the value changes, do whatever you want to do. if ( & m_valueSlider == slider ) { auto value = slider -> getValue (); m_sliderLabel . setText ( String ( std :: to_string ( static_cast < int > ( value ))), dontSendNotification ); } } The broadcaster and listener can have a many to many relationship. One callback can be invoked by many broadcaster. So, you need to know which instanced invoked it. So we do the address comparison in line 44(In this case, it\u2019s not necessary, because we have only one broadcaster.). User provided Listener \u00b6 You can also provide your own Listener interface. Let\u2019s say you have a login form. It has two input boxes, one submit button and one clear button. Clear button is activated when at least one input box has some text and Submit button is activated if both are filled with some data. We separate the username and password input control to a separate component, called InputForm. In the main component, we have the InputForm and bothe the buttons. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public : InputForm (); ~ InputForm (); void paint ( Graphics & ) override ; void resized () override ; void submit (); void clear (); private : Label m_usernameLabel ; Label m_passwordLabel ; Label m_usernameInput ; Label m_passwordInput ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( InputForm ) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm :: InputForm () { addAndMakeVisible ( m_usernameLabel ); m_usernameLabel . setText ( \"Username:\" , dontSendNotification ); m_usernameLabel . attachToComponent ( & m_usernameInput , true ); m_usernameLabel . setColour ( Label :: textColourId , Colours :: orange ); m_usernameLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_passwordLabel ); m_passwordLabel . setText ( \"Password:\" , dontSendNotification ); m_passwordLabel . attachToComponent ( & m_passwordInput , true ); m_passwordLabel . setColour ( Label :: textColourId , Colours :: orange ); m_passwordLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_usernameInput ); m_usernameInput . setEditable ( true ); m_usernameInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_usernameInput . setJustificationType ( Justification :: left ); addAndMakeVisible ( m_passwordInput ); m_passwordInput . setEditable ( true ); m_passwordInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_passwordInput . setJustificationType ( Justification :: left ); } InputForm ::~ InputForm () { } void InputForm :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); // clear the background g . setColour ( Colours :: grey ); g . drawRect ( getLocalBounds (), 1 ); } void InputForm :: resized () { auto marginX = 10 ; auto marginY = 10 ; auto localBounds = getLocalBounds (); auto usernameRect = localBounds . removeFromTop ( 50 ); m_usernameLabel . setBounds ( usernameRect . removeFromLeft ( usernameRect . getWidth () / 5 ). reduced ( marginX , marginY )); m_usernameInput . setBounds ( usernameRect . reduced ( marginX , marginY )); auto passwordRect = localBounds . removeFromTop ( 50 ); m_passwordLabel . setBounds ( passwordRect . removeFromLeft ( passwordRect . getWidth () / 5 ). reduced ( marginX )); m_passwordInput . setBounds ( passwordRect . reduced ( marginX , marginY )); } // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; private : InputForm m_inputForm ; TextButton m_clearButton ; TextButton m_submitButton ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_inputForm ); addAndMakeVisible ( m_clearButton ); addAndMakeVisible ( m_submitButton ); m_clearButton . setButtonText ( \"Clear\" ); m_submitButton . setButtonText ( \"Submit\" ); setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto localBounds = getLocalBounds (); auto buttonArea = localBounds . removeFromBottom ( 50 ); m_clearButton . setBounds ( buttonArea . removeFromLeft ( buttonArea . getWidth () / 2 ). reduced ( 10 )); m_submitButton . setBounds ( buttonArea . reduced ( 10 )); m_inputForm . setBounds ( localBounds . reduced ( 10 , 10 )); } We can add a listener interface to the InputForm. It will have to callbacks clearActivated() submitActivated() InputForm must maintain a list of interested listeners and should provide api call for registration and de-registration. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public : // other code class Listener { public : virtual ~ Listener () = default ; virtual void clearActivated ( InputForm * , bool isActive ) = 0 ; virtual void submitActivated ( InputForm * , bool isActive ) = 0 ; }; void addListener ( Listener * listenerToAdd ); void removeListener ( Listener * listenerToRemove ); // ... private : void clearActivate ( bool isActive ); void submitActivate ( bool isActive ); // ... bool m_clearActive ; bool m_submitActive ; ListenerList < Listener > m_listeners ; // .... }; // InputForm.cpp InputForm :: InputForm () { // ... m_clearActive = false ; m_submitActive = false ; } void InputForm :: addListener ( Listener * listenerToAdd ) { m_listeners . add ( listenerToAdd ); } void InputForm :: removeListener ( Listener * listenerToRemove ) { jassert ( m_listeners . contains ( listenerToRemove )); m_listeners . remove ( listenerToRemove ); } void InputForm :: clearActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . clearActivated ( this , isActive ); }); } void InputForm :: submitActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . submitActivated ( this , isActive ); }); } Juce ListenerList class should be used to store the list of listeners. It has many advantages than the std lists, like add or remove listeners from the list during one of the callbacks\u200a\u2014\u200ai.e. while it\u2019s in the middle of iterating the listeners, then it\u2019s guaranteed that no listeners will be mistakenly called after they\u2019ve been removed, but it may mean that some of the listeners could be called more than once, or not at all, depending on the list\u2019s order. It has a bailout checker(Component::BailOutChecker class) which checks if the component has already been deleted. This provides safety guarantee that no callback will be called on a deleted component. ListenerList checks if the listener is already in the list or not. So, double addition won\u2019t have any effect. Now, after implementing input and clear logic, the InputForm control looks like this. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component , public Label :: Listener { public : InputForm (); ~ InputForm (); class Listener { public : virtual ~ Listener () = default ; virtual void clearActivated ( InputForm * , bool isActive ) = 0 ; virtual void submitActivated ( InputForm * , bool isActive ) = 0 ; }; void addListener ( Listener * listenerToAdd ); void removeListener ( Listener * listenerToRemove ); void paint ( Graphics & ) override ; void resized () override ; void labelTextChanged ( Label * labelThatHasChanged ) override ; void submit (); void clear (); private : void clearActivate ( bool isActive ); void submitActivate ( bool isActive ); Label m_usernameLabel ; Label m_passwordLabel ; Label m_usernameInput ; Label m_passwordInput ; bool m_clearActive ; bool m_submitActive ; ListenerList < Listener > m_listeners ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( InputForm ) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm :: InputForm () { addAndMakeVisible ( m_usernameLabel ); m_usernameLabel . setText ( \"Username:\" , dontSendNotification ); m_usernameLabel . attachToComponent ( & m_usernameInput , true ); m_usernameLabel . setColour ( Label :: textColourId , Colours :: orange ); m_usernameLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_passwordLabel ); m_passwordLabel . setText ( \"Password:\" , dontSendNotification ); m_passwordLabel . attachToComponent ( & m_passwordInput , true ); m_passwordLabel . setColour ( Label :: textColourId , Colours :: orange ); m_passwordLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_usernameInput ); m_usernameInput . setEditable ( true ); m_usernameInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_usernameInput . setJustificationType ( Justification :: left ); addAndMakeVisible ( m_passwordInput ); m_passwordInput . setEditable ( true ); m_passwordInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_passwordInput . setJustificationType ( Justification :: left ); m_clearActive = false ; m_submitActive = false ; m_usernameInput . addListener ( this ); m_passwordInput . addListener ( this ); } InputForm ::~ InputForm () { m_usernameInput . removeListener ( this ); m_passwordInput . removeListener ( this ); } void InputForm :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); // clear the background g . setColour ( Colours :: grey ); g . drawRect ( getLocalBounds (), 1 ); } void InputForm :: resized () { auto marginX = 10 ; auto marginY = 10 ; auto localBounds = getLocalBounds (); auto usernameRect = localBounds . removeFromTop ( 50 ); m_usernameLabel . setBounds ( usernameRect . removeFromLeft ( usernameRect . getWidth () / 5 ). reduced ( marginX , marginY )); m_usernameInput . setBounds ( usernameRect . reduced ( marginX , marginY )); auto passwordRect = localBounds . removeFromTop ( 50 ); m_passwordLabel . setBounds ( passwordRect . removeFromLeft ( passwordRect . getWidth () / 5 ). reduced ( marginX )); m_passwordInput . setBounds ( passwordRect . reduced ( marginX , marginY )); } void InputForm :: addListener ( Listener * listenerToAdd ) { m_listeners . add ( listenerToAdd ); } void InputForm :: removeListener ( Listener * listenerToRemove ) { jassert ( m_listeners . contains ( listenerToRemove )); m_listeners . remove ( listenerToRemove ); } void InputForm :: clearActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . clearActivated ( this , isActive ); }); } void InputForm :: submitActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . submitActivated ( this , isActive ); }); } void InputForm :: labelTextChanged ( Label * labelThatHasChanged ) { bool atLeastOneTextFilled = false ; if ( labelThatHasChanged == & m_usernameInput ) { atLeastOneTextFilled = ! m_usernameInput . getText ( false ). isEmpty (); } else if ( labelThatHasChanged == & m_passwordInput ) { atLeastOneTextFilled = ! m_passwordInput . getText ( false ). isEmpty (); } if ( ! m_clearActive && atLeastOneTextFilled ) { m_clearActive = true ; clearActivate ( true ); } else if ( m_clearActive && ! atLeastOneTextFilled ) { m_clearActive = false ; clearActivate ( false ); } bool allTextFilled = ! m_usernameInput . getText ( true ). isEmpty () && ! m_passwordInput . getText ( true ). isEmpty (); if ( ! m_submitActive && allTextFilled ) { m_submitActive = true ; submitActivate ( true ); } else if ( m_submitActive && ! allTextFilled ) { m_submitActive = false ; submitActivate ( false ); } } void InputForm :: submit () { // do nothing } void InputForm :: clear () { m_usernameInput . setText ( \"\" , NotificationType :: sendNotification ); m_passwordInput . setText ( \"\" , NotificationType :: sendNotification ); } When you clear the label programmatically, you need to set the NotificationType. In this case, once the input texts are cleared, we need the callbacks to be called to set the submit and active status. So, we use NotificationType as sendNotification. In the main component, we implement the InputForm::Listener interface and accordingly set the enabled/disabled status of the buttons. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component , public InputForm :: Listener { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; void clearActivated ( InputForm * , bool isActive ) override ; void submitActivated ( InputForm * , bool isActive ) override ; private : InputForm m_inputForm ; TextButton m_clearButton ; TextButton m_submitButton ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; { % endhighlight % } { % highlight cpp % } // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_inputForm ); addAndMakeVisible ( m_clearButton ); addAndMakeVisible ( m_submitButton ); m_clearButton . setButtonText ( \"Clear\" ); m_submitButton . setButtonText ( \"Submit\" ); m_clearButton . setEnabled ( false ); m_submitButton . setEnabled ( false ); m_inputForm . addListener ( this ); m_clearButton . onClick = [ this ] { m_inputForm . clear (); }; m_submitButton . onClick = [ this ] { m_inputForm . submit (); }; setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { m_inputForm . removeListener ( this ); } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto localBounds = getLocalBounds (); auto buttonArea = localBounds . removeFromBottom ( 50 ); m_clearButton . setBounds ( buttonArea . removeFromLeft ( buttonArea . getWidth () / 2 ). reduced ( 10 )); m_submitButton . setBounds ( buttonArea . reduced ( 10 )); m_inputForm . setBounds ( localBounds . reduced ( 10 , 10 )); } void MainComponent :: clearActivated ( InputForm * , bool isActive ) { m_clearButton . setEnabled ( isActive ); } void MainComponent :: submitActivated ( InputForm * , bool isActive ) { m_submitButton . setEnabled ( isActive ); } The application finally looks like this Comparison with Qt Signal/Slots Callbacks are like Slots in Qt. Qt MOC does all the major work of adding code for callback handling. There is no MOC here, so developer has to write everything. In Qt, signal emitters are completely decoupled from signal receivers. So, if you want to add a new signal, it needs minimum amount of code change. In Juce, you will need at least one pure virtual function, code for listener registration and removal. Both Qt and Juce provide asynchronous call by using Qt Event loop and Juce AsyncUpdater respectively. But Juce needs some protection from race condition. I wrote this blog to clarify my doubts. Feel free to correct if I am wrong or write a comment if you want to suggest something. The source code is shared here https://github.com/asit-dhal/Broadcaster-Listener-Demo","title":"Broadcasters and listeners in JUCE"},{"location":"juce/broadcasters-and-listeners-in-juce/#broadcasters-and-listeners-in-juce","text":"Juce uses broadcasters and listeners pattern to propagate state changes. This is like classical observer pattern. Broadcasters are subjects and listeners are observers. Juce Framework provides predefined library to automate this process. Let\u2019s say we have a Window with a slider and a label. When the user changes the slider position, the label will show the value. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; private : Slider m_valueSlider ; Label m_sliderLabel ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_valueSlider ); m_valueSlider . setRange ( 10 , 100 ); m_valueSlider . setTextValueSuffix ( \" Cnt\" ); m_valueSlider . setTextBoxStyle ( Slider :: TextEntryBoxPosition :: NoTextBox , false , 0 , 0 ); addAndMakeVisible ( m_sliderLabel ); m_sliderLabel . setText ( \"Value\" , dontSendNotification ); setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto sliderLeft = 120 ; m_valueSlider . setBounds ( sliderLeft , 20 , getWidth () - sliderLeft - 10 , 20 ); m_sliderLabel . setBounds ( sliderLeft , 50 , getWidth () - sliderLeft - 10 , 20 ); } At this moment both the slider and the label don\u2019t interact with each other. We are going to show the value of slider in the label.","title":"Broadcasters and listeners in JUCE"},{"location":"juce/broadcasters-and-listeners-in-juce/#listeners","text":"Most Juce components have an inner class called Listener. This class is an abstract class with at least one pure virtual function. An observer has to inherit from this abstract class and implement the pure virtual function(s). This pure virtual function is the callback. one member function called void addListener(Listener* listener). Using this function, an observer can register it self. another member function called void removeListener(Listener* listener). This one removes the previously registered listener. Whenever a listener is registered, the address is stored in a ListenerList container. Whenever the state changes, the broadcaster iterates over all the registered listeners and calls the appropriate callback. Slider::Listener provides Slider::Listener::sliderValueChanged( Slider *slide) . We can override that function in the MainComponent. Then register the main component as a listener. In the implementation of sliderValueChanged, we can set the value of the slider in the label. //MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component , public Slider :: Listener // step 1: inherit the listener abstract class { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; // step 2: implementation of pure virtual function void sliderValueChanged ( Slider * slider ) override ; private : Slider m_valueSlider ; Label m_sliderLabel ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; //MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_valueSlider ); m_valueSlider . setRange ( 10 , 100 ); m_valueSlider . setTextValueSuffix ( \" Cnt\" ); m_valueSlider . setTextBoxStyle ( Slider :: TextEntryBoxPosition :: NoTextBox , false , 0 , 0 ); addAndMakeVisible ( m_sliderLabel ); m_sliderLabel . setText ( \"Value\" , dontSendNotification ); setSize ( 600 , 400 ); // step 3: register the listener m_valueSlider . addListener ( this ); } MainComponent ::~ MainComponent () { // step 5: unregister the listener m_valueSlider . removeListener ( this ); } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto sliderLeft = 120 ; m_valueSlider . setBounds ( sliderLeft , 20 , getWidth () - sliderLeft - 10 , 20 ); m_sliderLabel . setBounds ( sliderLeft , 50 , getWidth () - sliderLeft - 10 , 20 ); } void MainComponent :: sliderValueChanged ( Slider * slider ) { // step 4: when the value changes, do whatever you want to do. if ( & m_valueSlider == slider ) { auto value = slider -> getValue (); m_sliderLabel . setText ( String ( std :: to_string ( static_cast < int > ( value ))), dontSendNotification ); } } The broadcaster and listener can have a many to many relationship. One callback can be invoked by many broadcaster. So, you need to know which instanced invoked it. So we do the address comparison in line 44(In this case, it\u2019s not necessary, because we have only one broadcaster.).","title":"Listeners"},{"location":"juce/broadcasters-and-listeners-in-juce/#user-provided-listener","text":"You can also provide your own Listener interface. Let\u2019s say you have a login form. It has two input boxes, one submit button and one clear button. Clear button is activated when at least one input box has some text and Submit button is activated if both are filled with some data. We separate the username and password input control to a separate component, called InputForm. In the main component, we have the InputForm and bothe the buttons. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public : InputForm (); ~ InputForm (); void paint ( Graphics & ) override ; void resized () override ; void submit (); void clear (); private : Label m_usernameLabel ; Label m_passwordLabel ; Label m_usernameInput ; Label m_passwordInput ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( InputForm ) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm :: InputForm () { addAndMakeVisible ( m_usernameLabel ); m_usernameLabel . setText ( \"Username:\" , dontSendNotification ); m_usernameLabel . attachToComponent ( & m_usernameInput , true ); m_usernameLabel . setColour ( Label :: textColourId , Colours :: orange ); m_usernameLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_passwordLabel ); m_passwordLabel . setText ( \"Password:\" , dontSendNotification ); m_passwordLabel . attachToComponent ( & m_passwordInput , true ); m_passwordLabel . setColour ( Label :: textColourId , Colours :: orange ); m_passwordLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_usernameInput ); m_usernameInput . setEditable ( true ); m_usernameInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_usernameInput . setJustificationType ( Justification :: left ); addAndMakeVisible ( m_passwordInput ); m_passwordInput . setEditable ( true ); m_passwordInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_passwordInput . setJustificationType ( Justification :: left ); } InputForm ::~ InputForm () { } void InputForm :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); // clear the background g . setColour ( Colours :: grey ); g . drawRect ( getLocalBounds (), 1 ); } void InputForm :: resized () { auto marginX = 10 ; auto marginY = 10 ; auto localBounds = getLocalBounds (); auto usernameRect = localBounds . removeFromTop ( 50 ); m_usernameLabel . setBounds ( usernameRect . removeFromLeft ( usernameRect . getWidth () / 5 ). reduced ( marginX , marginY )); m_usernameInput . setBounds ( usernameRect . reduced ( marginX , marginY )); auto passwordRect = localBounds . removeFromTop ( 50 ); m_passwordLabel . setBounds ( passwordRect . removeFromLeft ( passwordRect . getWidth () / 5 ). reduced ( marginX )); m_passwordInput . setBounds ( passwordRect . reduced ( marginX , marginY )); } // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; private : InputForm m_inputForm ; TextButton m_clearButton ; TextButton m_submitButton ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_inputForm ); addAndMakeVisible ( m_clearButton ); addAndMakeVisible ( m_submitButton ); m_clearButton . setButtonText ( \"Clear\" ); m_submitButton . setButtonText ( \"Submit\" ); setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto localBounds = getLocalBounds (); auto buttonArea = localBounds . removeFromBottom ( 50 ); m_clearButton . setBounds ( buttonArea . removeFromLeft ( buttonArea . getWidth () / 2 ). reduced ( 10 )); m_submitButton . setBounds ( buttonArea . reduced ( 10 )); m_inputForm . setBounds ( localBounds . reduced ( 10 , 10 )); } We can add a listener interface to the InputForm. It will have to callbacks clearActivated() submitActivated() InputForm must maintain a list of interested listeners and should provide api call for registration and de-registration. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component { public : // other code class Listener { public : virtual ~ Listener () = default ; virtual void clearActivated ( InputForm * , bool isActive ) = 0 ; virtual void submitActivated ( InputForm * , bool isActive ) = 0 ; }; void addListener ( Listener * listenerToAdd ); void removeListener ( Listener * listenerToRemove ); // ... private : void clearActivate ( bool isActive ); void submitActivate ( bool isActive ); // ... bool m_clearActive ; bool m_submitActive ; ListenerList < Listener > m_listeners ; // .... }; // InputForm.cpp InputForm :: InputForm () { // ... m_clearActive = false ; m_submitActive = false ; } void InputForm :: addListener ( Listener * listenerToAdd ) { m_listeners . add ( listenerToAdd ); } void InputForm :: removeListener ( Listener * listenerToRemove ) { jassert ( m_listeners . contains ( listenerToRemove )); m_listeners . remove ( listenerToRemove ); } void InputForm :: clearActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . clearActivated ( this , isActive ); }); } void InputForm :: submitActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . submitActivated ( this , isActive ); }); } Juce ListenerList class should be used to store the list of listeners. It has many advantages than the std lists, like add or remove listeners from the list during one of the callbacks\u200a\u2014\u200ai.e. while it\u2019s in the middle of iterating the listeners, then it\u2019s guaranteed that no listeners will be mistakenly called after they\u2019ve been removed, but it may mean that some of the listeners could be called more than once, or not at all, depending on the list\u2019s order. It has a bailout checker(Component::BailOutChecker class) which checks if the component has already been deleted. This provides safety guarantee that no callback will be called on a deleted component. ListenerList checks if the listener is already in the list or not. So, double addition won\u2019t have any effect. Now, after implementing input and clear logic, the InputForm control looks like this. // InputForm.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class InputForm : public Component , public Label :: Listener { public : InputForm (); ~ InputForm (); class Listener { public : virtual ~ Listener () = default ; virtual void clearActivated ( InputForm * , bool isActive ) = 0 ; virtual void submitActivated ( InputForm * , bool isActive ) = 0 ; }; void addListener ( Listener * listenerToAdd ); void removeListener ( Listener * listenerToRemove ); void paint ( Graphics & ) override ; void resized () override ; void labelTextChanged ( Label * labelThatHasChanged ) override ; void submit (); void clear (); private : void clearActivate ( bool isActive ); void submitActivate ( bool isActive ); Label m_usernameLabel ; Label m_passwordLabel ; Label m_usernameInput ; Label m_passwordInput ; bool m_clearActive ; bool m_submitActive ; ListenerList < Listener > m_listeners ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( InputForm ) }; // InputForm.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" InputForm :: InputForm () { addAndMakeVisible ( m_usernameLabel ); m_usernameLabel . setText ( \"Username:\" , dontSendNotification ); m_usernameLabel . attachToComponent ( & m_usernameInput , true ); m_usernameLabel . setColour ( Label :: textColourId , Colours :: orange ); m_usernameLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_passwordLabel ); m_passwordLabel . setText ( \"Password:\" , dontSendNotification ); m_passwordLabel . attachToComponent ( & m_passwordInput , true ); m_passwordLabel . setColour ( Label :: textColourId , Colours :: orange ); m_passwordLabel . setJustificationType ( Justification :: right ); addAndMakeVisible ( m_usernameInput ); m_usernameInput . setEditable ( true ); m_usernameInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_usernameInput . setJustificationType ( Justification :: left ); addAndMakeVisible ( m_passwordInput ); m_passwordInput . setEditable ( true ); m_passwordInput . setColour ( Label :: backgroundColourId , Colours :: darkblue ); m_passwordInput . setJustificationType ( Justification :: left ); m_clearActive = false ; m_submitActive = false ; m_usernameInput . addListener ( this ); m_passwordInput . addListener ( this ); } InputForm ::~ InputForm () { m_usernameInput . removeListener ( this ); m_passwordInput . removeListener ( this ); } void InputForm :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); // clear the background g . setColour ( Colours :: grey ); g . drawRect ( getLocalBounds (), 1 ); } void InputForm :: resized () { auto marginX = 10 ; auto marginY = 10 ; auto localBounds = getLocalBounds (); auto usernameRect = localBounds . removeFromTop ( 50 ); m_usernameLabel . setBounds ( usernameRect . removeFromLeft ( usernameRect . getWidth () / 5 ). reduced ( marginX , marginY )); m_usernameInput . setBounds ( usernameRect . reduced ( marginX , marginY )); auto passwordRect = localBounds . removeFromTop ( 50 ); m_passwordLabel . setBounds ( passwordRect . removeFromLeft ( passwordRect . getWidth () / 5 ). reduced ( marginX )); m_passwordInput . setBounds ( passwordRect . reduced ( marginX , marginY )); } void InputForm :: addListener ( Listener * listenerToAdd ) { m_listeners . add ( listenerToAdd ); } void InputForm :: removeListener ( Listener * listenerToRemove ) { jassert ( m_listeners . contains ( listenerToRemove )); m_listeners . remove ( listenerToRemove ); } void InputForm :: clearActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . clearActivated ( this , isActive ); }); } void InputForm :: submitActivate ( bool isActive ) { m_listeners . call ([ this , isActive ]( Listener & l ) { l . submitActivated ( this , isActive ); }); } void InputForm :: labelTextChanged ( Label * labelThatHasChanged ) { bool atLeastOneTextFilled = false ; if ( labelThatHasChanged == & m_usernameInput ) { atLeastOneTextFilled = ! m_usernameInput . getText ( false ). isEmpty (); } else if ( labelThatHasChanged == & m_passwordInput ) { atLeastOneTextFilled = ! m_passwordInput . getText ( false ). isEmpty (); } if ( ! m_clearActive && atLeastOneTextFilled ) { m_clearActive = true ; clearActivate ( true ); } else if ( m_clearActive && ! atLeastOneTextFilled ) { m_clearActive = false ; clearActivate ( false ); } bool allTextFilled = ! m_usernameInput . getText ( true ). isEmpty () && ! m_passwordInput . getText ( true ). isEmpty (); if ( ! m_submitActive && allTextFilled ) { m_submitActive = true ; submitActivate ( true ); } else if ( m_submitActive && ! allTextFilled ) { m_submitActive = false ; submitActivate ( false ); } } void InputForm :: submit () { // do nothing } void InputForm :: clear () { m_usernameInput . setText ( \"\" , NotificationType :: sendNotification ); m_passwordInput . setText ( \"\" , NotificationType :: sendNotification ); } When you clear the label programmatically, you need to set the NotificationType. In this case, once the input texts are cleared, we need the callbacks to be called to set the submit and active status. So, we use NotificationType as sendNotification. In the main component, we implement the InputForm::Listener interface and accordingly set the enabled/disabled status of the buttons. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" #include \"InputForm.h\" class MainComponent : public Component , public InputForm :: Listener { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; void clearActivated ( InputForm * , bool isActive ) override ; void submitActivated ( InputForm * , bool isActive ) override ; private : InputForm m_inputForm ; TextButton m_clearButton ; TextButton m_submitButton ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; { % endhighlight % } { % highlight cpp % } // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () { addAndMakeVisible ( m_inputForm ); addAndMakeVisible ( m_clearButton ); addAndMakeVisible ( m_submitButton ); m_clearButton . setButtonText ( \"Clear\" ); m_submitButton . setButtonText ( \"Submit\" ); m_clearButton . setEnabled ( false ); m_submitButton . setEnabled ( false ); m_inputForm . addListener ( this ); m_clearButton . onClick = [ this ] { m_inputForm . clear (); }; m_submitButton . onClick = [ this ] { m_inputForm . submit (); }; setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { m_inputForm . removeListener ( this ); } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); g . setFont ( Font ( 16.0f )); g . setColour ( Colours :: white ); } void MainComponent :: resized () { auto localBounds = getLocalBounds (); auto buttonArea = localBounds . removeFromBottom ( 50 ); m_clearButton . setBounds ( buttonArea . removeFromLeft ( buttonArea . getWidth () / 2 ). reduced ( 10 )); m_submitButton . setBounds ( buttonArea . reduced ( 10 )); m_inputForm . setBounds ( localBounds . reduced ( 10 , 10 )); } void MainComponent :: clearActivated ( InputForm * , bool isActive ) { m_clearButton . setEnabled ( isActive ); } void MainComponent :: submitActivated ( InputForm * , bool isActive ) { m_submitButton . setEnabled ( isActive ); } The application finally looks like this Comparison with Qt Signal/Slots Callbacks are like Slots in Qt. Qt MOC does all the major work of adding code for callback handling. There is no MOC here, so developer has to write everything. In Qt, signal emitters are completely decoupled from signal receivers. So, if you want to add a new signal, it needs minimum amount of code change. In Juce, you will need at least one pure virtual function, code for listener registration and removal. Both Qt and Juce provide asynchronous call by using Qt Event loop and Juce AsyncUpdater respectively. But Juce needs some protection from race condition. I wrote this blog to clarify my doubts. Feel free to correct if I am wrong or write a comment if you want to suggest something. The source code is shared here https://github.com/asit-dhal/Broadcaster-Listener-Demo","title":"User provided Listener"},{"location":"juce/side-panel-in-juce/","text":"Side Panel in JUCE \u00b6 This tutorial explains the side panel in JUCE GUI framework. Side Panel can be used for navigation if the application doesn\u2019t have a tool bar or menu bar. Usually, it stays on the left or right side of the application and triggered by the user. Juce has built-in support for side panel. Let\u2019s first make a skeleton app. The app will have a button to trigger side panel and a label to show the status. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; private : TextButton m_invokeSidePanel ; Label m_sidePanelStatus ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () : m_invokeSidePanel ( \"Sidepanel\" , \"Show Sidepanel\" ) { addAndMakeVisible ( m_invokeSidePanel ); addAndMakeVisible ( m_sidePanelStatus ); m_sidePanelStatus . setText ( \"status\" , dontSendNotification ); setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); } void MainComponent :: resized () { auto localBounds = getLocalBounds (); if ( localBounds . getHeight () / 2 - 50 > 5 ) localBounds . removeFromTop ( localBounds . getHeight () / 2 - 50 ); if ( localBounds . getWidth () / 2 - 50 > 5 ) localBounds . removeFromLeft ( localBounds . getWidth () / 2 - 50 ); auto buttonBound = localBounds . removeFromTop ( 30 ). removeFromRight ( 100 ); auto statusLabelBound = localBounds . removeFromTop ( 30 ). removeFromRight ( 100 ). reduced ( 5 ); m_invokeSidePanel . setBounds ( buttonBound ); m_sidePanelStatus . setBounds ( statusLabelBound ); } When user clicks the button, the side panel should appear. There is already a closed button on the side panel, the user can click on this to close the side panel. The side panel will have a list of entries. When the user selects any of those entries, the status label should show the text. Juce provides a built in component called Side Panel, https://docs.juce.com/master/classSidePanel.html Sidepanel Components \u00b6 SidePanel has two parts. header which can contain a label, a few buttons and a close button a list box which shows a list of entries Let\u2019s add a SidePanel component to the main component. The SidePanel should be shown when the user clicks on the sidePanel button in the main component. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component , // step 2: override Button::Listener to get broadcast events from the button public Button :: Listener { public : // ... // step 3: implement the button clicked callback void buttonClicked ( Button * ) override ; private : // ... // step 1: add sidepanel SidePanel m_sidePanel ; }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () : m_invokeSidePanel ( \"Sidepanel\" , \"Show Sidepanel\" ), m_sidePanel ( \"Side Panel Demo\" , 250 , true , nullptr , false ) { // .... addAndMakeVisible ( m_sidePanel ); // ... m_invokeSidePanel . addListener ( this ); } MainComponent ::~ MainComponent () { m_invokeSidePanel . removeListener ( this ); } void MainComponent :: buttonClicked ( Button * btn ) { if ( btn == & m_invokeSidePanel ) { // step 4: show the side panel when the button is clicked m_sidePanel . showOrHide ( true ); } } Now, if you run this, you will a side Panel without any contents on this(there will be only title and a close button). Header Component \u00b6 Let\u2019s add the header component The header has two shape buttons(one for home and another for settings), a title and a close button. // SidePanelHeader.h #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelHeader : public Component { public : SidePanelHeader ( const String & titleText ); ~ SidePanelHeader (); void paint ( Graphics & ) override ; void resized () override ; private : Label m_titleLabel ; ShapeButton m_homeButton { \"Home\" , Colours :: transparentBlack , Colours :: transparentBlack , Colours :: transparentBlack }, m_settingsButton { \"Settings\" , Colours :: transparentBlack , Colours :: transparentBlack , Colours :: transparentBlack }; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( SidePanelHeader ) }; ShapeButton has only one constructor, which takes three color ids, normal color(the colour to fill the shape with when the mouse isn\u2019t over), overColor(the colour to use when the mouse is over the shape) and downColour(the colour to use when the button is in the pressed-down state). In the beginning we will make everything transparent black and repaint with proper color in the paint() method. // SidePanelHeader.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelHeader.h\" SidePanelHeader :: SidePanelHeader ( const String & titleText ) { setOpaque ( true ); static const unsigned char homeIconPathData [] = { 110 , 109 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 98 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 74 , 12 , 186 , 64 , 164 , 112 , 5 , 65 , 24 , 217 , 22 , 64 , 70 , 182 , 51 , 65 , 98 , 35 , 219 , 9 , 64 , 240 , 167 , 54 , 65 , 0 , 0 , 0 , 64 , 170 , 241 , 58 , 65 , 0 , 0 , 0 , 64 , 0 , 0 , 64 , 65 , 98 , 0 , 0 , 0 , 64 , 22 , 217 , 72 , 65 , 166 , 155 , 28 , 64 , 0 , 0 , 80 , 65 , 0 , 0 , 64 , 64 , 0 , 0 , 80 , 65 , 108 , 0 , 0 , 160 , 64 , 0 , 0 , 80 , 65 , 108 , 0 , 0 , 160 , 64 , 0 , 0 , 160 , 65 , 98 , 0 , 0 , 160 , 64 , 139 , 108 , 164 , 65 , 211 , 77 , 174 , 64 , 0 , 0 , 168 , 65 , 0 , 0 , 192 , 64 , 0 , 0 , 168 , 65 , 108 , 0 , 0 , 16 , 65 , 0 , 0 , 168 , 65 , 98 , 22 , 217 , 24 , 65 , 0 , 0 , 168 , 65 , 0 , 0 , 32 , 65 , 127 , 106 , 164 , 65 , 0 , 0 , 32 , 65 , 0 , 0 , 160 , 65 , 108 , 0 , 0 , 32 , 65 , 0 , 0 , 128 , 65 , 108 , 0 , 0 , 96 , 65 , 0 , 0 , 128 , 65 , 108 , 0 , 0 , 96 , 65 , 0 , 0 , 160 , 65 , 98 , 0 , 0 , 96 , 65 , 127 , 106 , 164 , 65 , 233 , 38 , 103 , 65 , 0 , 0 , 168 , 65 , 0 , 0 , 112 , 65 , 0 , 0 , 168 , 65 , 108 , 0 , 0 , 144 , 65 , 0 , 0 , 168 , 65 , 98 , 139 , 108 , 148 , 65 , 0 , 0 , 168 , 65 , 0 , 0 , 152 , 65 , 139 , 108 , 164 , 65 , 0 , 0 , 152 , 65 , 0 , 0 , 160 , 65 , 108 , 0 , 0 , 152 , 65 , 0 , 0 , 80 , 65 , 108 , 0 , 0 , 168 , 65 , 0 , 0 , 80 , 65 , 98 , 139 , 108 , 172 , 65 , 0 , 0 , 80 , 65 , 0 , 0 , 176 , 65 , 23 , 217 , 72 , 65 , 0 , 0 , 176 , 65 , 0 , 0 , 64 , 65 , 98 , 0 , 0 , 176 , 65 , 170 , 241 , 58 , 65 , 156 , 196 , 174 , 65 , 240 , 167 , 54 , 65 , 158 , 239 , 172 , 65 , 70 , 182 , 51 , 65 , 98 , 213 , 120 , 145 , 65 , 164 , 112 , 5 , 65 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 99 , 101 , 0 , 0 }; static const unsigned char settingsIconPathData [] = { 110 , 109 , 202 , 111 , 210 , 64 , 243 , 226 , 61 , 64 , 108 , 0 , 0 , 224 , 64 , 0 , 0 , 0 , 0 , 108 , 0 , 0 , 48 , 65 , 0 , 0 , 0 , 0 , 108 , 27 , 200 , 54 , 65 , 243 , 226 , 61 , 64 , 98 , 91 , 248 , 63 , 65 , 174 , 170 , 76 , 64 , 95 , 130 , 72 , 65 , 231 , 138 , 96 , 64 , 46 , 46 , 80 , 65 , 180 , 163 , 120 , 64 , 108 , 42 , 181 , 124 , 65 , 20 , 38 , 49 , 64 , 108 , 149 , 90 , 142 , 65 , 246 , 108 , 199 , 64 , 108 , 68 , 249 , 118 , 65 , 2 , 85 , 1 , 65 , 98 , 112 , 166 , 119 , 65 , 201 , 31 , 6 , 65 , 0 , 0 , 120 , 65 , 111 , 5 , 11 , 65 , 0 , 0 , 120 , 65 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 120 , 65 , 145 , 250 , 20 , 65 , 108 , 166 , 119 , 65 , 55 , 224 , 25 , 65 , 72 , 249 , 118 , 65 , 254 , 170 , 30 , 65 , 108 , 151 , 90 , 142 , 65 , 133 , 73 , 60 , 65 , 108 , 46 , 181 , 124 , 65 , 123 , 182 , 115 , 65 , 108 , 50 , 46 , 80 , 65 , 18 , 215 , 97 , 65 , 98 , 99 , 130 , 72 , 65 , 70 , 221 , 103 , 65 , 96 , 248 , 63 , 65 , 83 , 213 , 108 , 65 , 32 , 200 , 54 , 65 , 66 , 135 , 112 , 65 , 108 , 0 , 0 , 48 , 65 , 0 , 0 , 144 , 65 , 108 , 0 , 0 , 224 , 64 , 0 , 0 , 144 , 65 , 108 , 202 , 111 , 210 , 64 , 67 , 135 , 112 , 65 , 98 , 74 , 15 , 192 , 64 , 84 , 213 , 108 , 65 , 65 , 251 , 174 , 64 , 70 , 221 , 103 , 65 , 164 , 163 , 159 , 64 , 19 , 215 , 97 , 65 , 108 , 92 , 43 , 13 , 64 , 123 , 182 , 115 , 65 , 108 , 187 , 181 , 82 , 62 , 133 , 73 , 60 , 65 , 108 , 244 , 26 , 36 , 64 , 254 , 170 , 30 , 65 , 98 , 64 , 102 , 33 , 64 , 55 , 224 , 25 , 5 , 0 , 0 , 32 , 64 , 145 , 250 , 20 , 65 , 0 , 0 , 32 , 64 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 32 , 64 , 111 , 5 , 11 , 65 , 64 , 102 , 33 , 64 , 201 , 31 , 6 , 65 , 244 , 26 , 36 , 64 , 2 , 85 , 1 , 65 , 108 , 187 , 181 , 82 , 62 , 246 , 108 , 199 , 64 , 108 , 92 , 43 , 13 , 64 , 20 , 38 , 49 , 64 , 108 , 164 , 163 , 159 , 64 , 180 , 163 , 120 , 64 , 98 , 65 , 251 , 174 , 64 , 231 , 138 , 96 , 64 , 74 , 15 , 192 , 64 , 175 , 170 , 76 , 64 , 202 , 111 , 210 , 64 , 243 , 226 , 61 , 64 , 99 , 109 , 0 , 0 , 16 , 65 , 0 , 0 , 64 , 65 , 98 , 121 , 130 , 42 , 65 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 65 , 121 , 130 , 42 , 65 , 0 , 0 , 64 , 65 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 64 , 65 , 13 , 251 , 234 , 64 , 121 , 130 , 42 , 65 , 0 , 0 , 192 , 64 , 0 , 0 , 16 , 65 , 0 , 0 , 192 , 64 , 98 , 13 , 251 , 234 , 64 , 0 , 0 , 192 , 64 , 0 , 0 , 192 , 64 , 13 , 251 , 234 , 64 , 0 , 0 , 192 , 64 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 192 , 64 , 121 , 130 , 42 , 65 , 13 , 251 , 234 , 64 , 0 , 0 , 64 , 65 , 0 , 0 , 16 , 65 , 0 , 0 , 64 , 65 , 99 , 101 , 0 , 0 }; Path p ; p . loadPathFromData ( homeIconPathData , sizeof ( homeIconPathData )); m_homeButton . setShape ( p , true , true , false ); p . clear (); p . loadPathFromData ( settingsIconPathData , sizeof ( settingsIconPathData )); m_settingsButton . setShape ( p , true , true , false ); m_titleLabel . setText ( titleText , NotificationType :: dontSendNotification ); addAndMakeVisible ( m_titleLabel ); addAndMakeVisible ( m_homeButton ); addAndMakeVisible ( m_settingsButton ); } SidePanelHeader ::~ SidePanelHeader () { } void SidePanelHeader :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( SidePanel :: backgroundColour )); // clear the background auto normal = getLookAndFeel (). findColour ( SidePanel :: dismissButtonNormalColour ); auto over = getLookAndFeel (). findColour ( SidePanel :: dismissButtonOverColour ); auto down = getLookAndFeel (). findColour ( SidePanel :: dismissButtonDownColour ); m_homeButton . setColours ( normal , over , down ); m_settingsButton . setColours ( normal , over , down ); } void SidePanelHeader :: resized () { auto bounds = getLocalBounds (); bounds . removeFromLeft ( 10 ); m_homeButton . setBounds ( bounds . removeFromLeft ( m_homeButton . getWidth () + 20 ). reduced ( 7 )); m_settingsButton . setBounds ( bounds . removeFromLeft ( m_settingsButton . getWidth () + 20 ). reduced ( 7 )); bounds . removeFromLeft ( 10 ); bounds . removeFromRight ( 10 ); m_titleLabel . setBounds ( bounds ); } I copied the path data for home button and settings button from DemoRunner. This comes with Juce Framework. Everything else is straight forward. In the MainComponent, we set this header as the title bar component of side panel. // MainComponent.cpp #include \"MainComponent.h\" #include \"SidePanelHeader.h\" MainComponent :: MainComponent () : m_invokeSidePanel ( \"Sidepanel\" , \"Show Sidepanel\" ), m_sidePanel ( \"\" , 250 , true , nullptr , false ) // we don't need the title here anymore { //... auto sidePanelHeader = new SidePanelHeader ( \"Side Panel\" ); m_sidePanel . setTitleBarComponent ( sidePanelHeader , true ); } Notice that the object is dynamically created. After we set, the parent component takes the ownership. void setTitleBarComponent ( Component * titleBarComponentToUse , bool keepDismissButton , bool deleteComponentWhenNoLongerNeeded = true ); The last parameter decides whether the parent component needs to take care of the ownership or not. Now, let\u2019s add the side panel list. This is just a list box which contains a list and responds to row selection. // SidePanelList.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelList : public Component , public ListBoxModel { public : SidePanelList (); ~ SidePanelList (); void paint ( Graphics & ) override ; void resized () override ; void paintListBoxItem ( int rowNumber , Graphics & g , int width , int height , bool rowIsSelected ) override ; int getNumRows () override ; void addEntry ( const String & entry ); void selectedRowsChanged ( int row ) override ; private : ListBox m_entries ; StringArray m_sidePanelEntries ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( SidePanelList ) }; // SidePanelList #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelList.h\" SidePanelList :: SidePanelList () { setOpaque ( true ); addAndMakeVisible ( m_entries ); m_entries . setModel ( this ); m_entries . setRowHeight ( 40 ); } SidePanelList ::~ SidePanelList () { } void SidePanelList :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( SidePanel :: backgroundColour )); // clear the background } void SidePanelList :: resized () { m_entries . setBounds ( getLocalBounds ()); } void SidePanelList :: paintListBoxItem ( int rowNumber , Graphics & g , int width , int height , bool rowIsSelected ) { if ( rowNumber < 0 || rowNumber >= getNumRows ()) return ; Rectangle < int > bounds ( 0 , 0 , width , height ); auto textColour = findColour ( Label :: textColourId ); g . setColour ( textColour . withAlpha ( 0.4f )); if ( rowNumber == 0 ) g . fillRect ( bounds . removeFromTop ( 2 ). reduced ( 10 , 0 )); g . fillRect ( bounds . removeFromBottom ( 2 ). reduced ( 10 , 0 )); if ( rowIsSelected ) { g . setColour ( findColour ( TextEditor :: highlightColourId ). withAlpha ( 0.4f )); g . fillRect ( bounds ); textColour = findColour ( TextEditor :: highlightedTextColourId ); } g . setColour ( textColour ); g . drawFittedText ( m_sidePanelEntries [ rowNumber ], bounds , Justification :: centred , 1 ); } void SidePanelList :: addEntry ( const String & entry ) { m_entries . deselectAllRows (); m_sidePanelEntries . add ( entry ); m_entries . updateContent (); } int SidePanelList :: getNumRows () { return m_sidePanelEntries . size (); } void SidePanelList :: selectedRowsChanged ( int row ) { if ( row < 0 ) return ; } We can integrate this list component with the side panel. // MainComponent.cpp MainComponent :: MainComponent () { //..... auto sidePanelList = new SidePanelList ; sidePanelList -> addEntry ( \"Entry 1\" ); sidePanelList -> addEntry ( \"Entry 2\" ); sidePanelList -> addEntry ( \"Entry 3\" ); m_sidePanel . setContent ( sidePanelList ); } The setContent is like setTitleBarComponent , it takes the ownership. After attaching all click listeners, we can update the status. The source code is shared in the github. https://github.com/asit-dhal/Juce-SidePanel-Example","title":"Side Panel in JUCE"},{"location":"juce/side-panel-in-juce/#side-panel-in-juce","text":"This tutorial explains the side panel in JUCE GUI framework. Side Panel can be used for navigation if the application doesn\u2019t have a tool bar or menu bar. Usually, it stays on the left or right side of the application and triggered by the user. Juce has built-in support for side panel. Let\u2019s first make a skeleton app. The app will have a button to trigger side panel and a label to show the status. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component { public : MainComponent (); ~ MainComponent (); void paint ( Graphics & ) override ; void resized () override ; private : TextButton m_invokeSidePanel ; Label m_sidePanelStatus ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( MainComponent ) }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () : m_invokeSidePanel ( \"Sidepanel\" , \"Show Sidepanel\" ) { addAndMakeVisible ( m_invokeSidePanel ); addAndMakeVisible ( m_sidePanelStatus ); m_sidePanelStatus . setText ( \"status\" , dontSendNotification ); setSize ( 600 , 400 ); } MainComponent ::~ MainComponent () { } void MainComponent :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( ResizableWindow :: backgroundColourId )); } void MainComponent :: resized () { auto localBounds = getLocalBounds (); if ( localBounds . getHeight () / 2 - 50 > 5 ) localBounds . removeFromTop ( localBounds . getHeight () / 2 - 50 ); if ( localBounds . getWidth () / 2 - 50 > 5 ) localBounds . removeFromLeft ( localBounds . getWidth () / 2 - 50 ); auto buttonBound = localBounds . removeFromTop ( 30 ). removeFromRight ( 100 ); auto statusLabelBound = localBounds . removeFromTop ( 30 ). removeFromRight ( 100 ). reduced ( 5 ); m_invokeSidePanel . setBounds ( buttonBound ); m_sidePanelStatus . setBounds ( statusLabelBound ); } When user clicks the button, the side panel should appear. There is already a closed button on the side panel, the user can click on this to close the side panel. The side panel will have a list of entries. When the user selects any of those entries, the status label should show the text. Juce provides a built in component called Side Panel, https://docs.juce.com/master/classSidePanel.html","title":"Side Panel in JUCE"},{"location":"juce/side-panel-in-juce/#sidepanel-components","text":"SidePanel has two parts. header which can contain a label, a few buttons and a close button a list box which shows a list of entries Let\u2019s add a SidePanel component to the main component. The SidePanel should be shown when the user clicks on the sidePanel button in the main component. // MainComponent.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class MainComponent : public Component , // step 2: override Button::Listener to get broadcast events from the button public Button :: Listener { public : // ... // step 3: implement the button clicked callback void buttonClicked ( Button * ) override ; private : // ... // step 1: add sidepanel SidePanel m_sidePanel ; }; // MainComponent.cpp #include \"MainComponent.h\" MainComponent :: MainComponent () : m_invokeSidePanel ( \"Sidepanel\" , \"Show Sidepanel\" ), m_sidePanel ( \"Side Panel Demo\" , 250 , true , nullptr , false ) { // .... addAndMakeVisible ( m_sidePanel ); // ... m_invokeSidePanel . addListener ( this ); } MainComponent ::~ MainComponent () { m_invokeSidePanel . removeListener ( this ); } void MainComponent :: buttonClicked ( Button * btn ) { if ( btn == & m_invokeSidePanel ) { // step 4: show the side panel when the button is clicked m_sidePanel . showOrHide ( true ); } } Now, if you run this, you will a side Panel without any contents on this(there will be only title and a close button).","title":"Sidepanel Components"},{"location":"juce/side-panel-in-juce/#header-component","text":"Let\u2019s add the header component The header has two shape buttons(one for home and another for settings), a title and a close button. // SidePanelHeader.h #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelHeader : public Component { public : SidePanelHeader ( const String & titleText ); ~ SidePanelHeader (); void paint ( Graphics & ) override ; void resized () override ; private : Label m_titleLabel ; ShapeButton m_homeButton { \"Home\" , Colours :: transparentBlack , Colours :: transparentBlack , Colours :: transparentBlack }, m_settingsButton { \"Settings\" , Colours :: transparentBlack , Colours :: transparentBlack , Colours :: transparentBlack }; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( SidePanelHeader ) }; ShapeButton has only one constructor, which takes three color ids, normal color(the colour to fill the shape with when the mouse isn\u2019t over), overColor(the colour to use when the mouse is over the shape) and downColour(the colour to use when the button is in the pressed-down state). In the beginning we will make everything transparent black and repaint with proper color in the paint() method. // SidePanelHeader.cpp #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelHeader.h\" SidePanelHeader :: SidePanelHeader ( const String & titleText ) { setOpaque ( true ); static const unsigned char homeIconPathData [] = { 110 , 109 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 98 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 74 , 12 , 186 , 64 , 164 , 112 , 5 , 65 , 24 , 217 , 22 , 64 , 70 , 182 , 51 , 65 , 98 , 35 , 219 , 9 , 64 , 240 , 167 , 54 , 65 , 0 , 0 , 0 , 64 , 170 , 241 , 58 , 65 , 0 , 0 , 0 , 64 , 0 , 0 , 64 , 65 , 98 , 0 , 0 , 0 , 64 , 22 , 217 , 72 , 65 , 166 , 155 , 28 , 64 , 0 , 0 , 80 , 65 , 0 , 0 , 64 , 64 , 0 , 0 , 80 , 65 , 108 , 0 , 0 , 160 , 64 , 0 , 0 , 80 , 65 , 108 , 0 , 0 , 160 , 64 , 0 , 0 , 160 , 65 , 98 , 0 , 0 , 160 , 64 , 139 , 108 , 164 , 65 , 211 , 77 , 174 , 64 , 0 , 0 , 168 , 65 , 0 , 0 , 192 , 64 , 0 , 0 , 168 , 65 , 108 , 0 , 0 , 16 , 65 , 0 , 0 , 168 , 65 , 98 , 22 , 217 , 24 , 65 , 0 , 0 , 168 , 65 , 0 , 0 , 32 , 65 , 127 , 106 , 164 , 65 , 0 , 0 , 32 , 65 , 0 , 0 , 160 , 65 , 108 , 0 , 0 , 32 , 65 , 0 , 0 , 128 , 65 , 108 , 0 , 0 , 96 , 65 , 0 , 0 , 128 , 65 , 108 , 0 , 0 , 96 , 65 , 0 , 0 , 160 , 65 , 98 , 0 , 0 , 96 , 65 , 127 , 106 , 164 , 65 , 233 , 38 , 103 , 65 , 0 , 0 , 168 , 65 , 0 , 0 , 112 , 65 , 0 , 0 , 168 , 65 , 108 , 0 , 0 , 144 , 65 , 0 , 0 , 168 , 65 , 98 , 139 , 108 , 148 , 65 , 0 , 0 , 168 , 65 , 0 , 0 , 152 , 65 , 139 , 108 , 164 , 65 , 0 , 0 , 152 , 65 , 0 , 0 , 160 , 65 , 108 , 0 , 0 , 152 , 65 , 0 , 0 , 80 , 65 , 108 , 0 , 0 , 168 , 65 , 0 , 0 , 80 , 65 , 98 , 139 , 108 , 172 , 65 , 0 , 0 , 80 , 65 , 0 , 0 , 176 , 65 , 23 , 217 , 72 , 65 , 0 , 0 , 176 , 65 , 0 , 0 , 64 , 65 , 98 , 0 , 0 , 176 , 65 , 170 , 241 , 58 , 65 , 156 , 196 , 174 , 65 , 240 , 167 , 54 , 65 , 158 , 239 , 172 , 65 , 70 , 182 , 51 , 65 , 98 , 213 , 120 , 145 , 65 , 164 , 112 , 5 , 65 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 64 , 99 , 101 , 0 , 0 }; static const unsigned char settingsIconPathData [] = { 110 , 109 , 202 , 111 , 210 , 64 , 243 , 226 , 61 , 64 , 108 , 0 , 0 , 224 , 64 , 0 , 0 , 0 , 0 , 108 , 0 , 0 , 48 , 65 , 0 , 0 , 0 , 0 , 108 , 27 , 200 , 54 , 65 , 243 , 226 , 61 , 64 , 98 , 91 , 248 , 63 , 65 , 174 , 170 , 76 , 64 , 95 , 130 , 72 , 65 , 231 , 138 , 96 , 64 , 46 , 46 , 80 , 65 , 180 , 163 , 120 , 64 , 108 , 42 , 181 , 124 , 65 , 20 , 38 , 49 , 64 , 108 , 149 , 90 , 142 , 65 , 246 , 108 , 199 , 64 , 108 , 68 , 249 , 118 , 65 , 2 , 85 , 1 , 65 , 98 , 112 , 166 , 119 , 65 , 201 , 31 , 6 , 65 , 0 , 0 , 120 , 65 , 111 , 5 , 11 , 65 , 0 , 0 , 120 , 65 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 120 , 65 , 145 , 250 , 20 , 65 , 108 , 166 , 119 , 65 , 55 , 224 , 25 , 65 , 72 , 249 , 118 , 65 , 254 , 170 , 30 , 65 , 108 , 151 , 90 , 142 , 65 , 133 , 73 , 60 , 65 , 108 , 46 , 181 , 124 , 65 , 123 , 182 , 115 , 65 , 108 , 50 , 46 , 80 , 65 , 18 , 215 , 97 , 65 , 98 , 99 , 130 , 72 , 65 , 70 , 221 , 103 , 65 , 96 , 248 , 63 , 65 , 83 , 213 , 108 , 65 , 32 , 200 , 54 , 65 , 66 , 135 , 112 , 65 , 108 , 0 , 0 , 48 , 65 , 0 , 0 , 144 , 65 , 108 , 0 , 0 , 224 , 64 , 0 , 0 , 144 , 65 , 108 , 202 , 111 , 210 , 64 , 67 , 135 , 112 , 65 , 98 , 74 , 15 , 192 , 64 , 84 , 213 , 108 , 65 , 65 , 251 , 174 , 64 , 70 , 221 , 103 , 65 , 164 , 163 , 159 , 64 , 19 , 215 , 97 , 65 , 108 , 92 , 43 , 13 , 64 , 123 , 182 , 115 , 65 , 108 , 187 , 181 , 82 , 62 , 133 , 73 , 60 , 65 , 108 , 244 , 26 , 36 , 64 , 254 , 170 , 30 , 65 , 98 , 64 , 102 , 33 , 64 , 55 , 224 , 25 , 5 , 0 , 0 , 32 , 64 , 145 , 250 , 20 , 65 , 0 , 0 , 32 , 64 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 32 , 64 , 111 , 5 , 11 , 65 , 64 , 102 , 33 , 64 , 201 , 31 , 6 , 65 , 244 , 26 , 36 , 64 , 2 , 85 , 1 , 65 , 108 , 187 , 181 , 82 , 62 , 246 , 108 , 199 , 64 , 108 , 92 , 43 , 13 , 64 , 20 , 38 , 49 , 64 , 108 , 164 , 163 , 159 , 64 , 180 , 163 , 120 , 64 , 98 , 65 , 251 , 174 , 64 , 231 , 138 , 96 , 64 , 74 , 15 , 192 , 64 , 175 , 170 , 76 , 64 , 202 , 111 , 210 , 64 , 243 , 226 , 61 , 64 , 99 , 109 , 0 , 0 , 16 , 65 , 0 , 0 , 64 , 65 , 98 , 121 , 130 , 42 , 65 , 0 , 0 , 64 , 65 , 0 , 0 , 64 , 65 , 121 , 130 , 42 , 65 , 0 , 0 , 64 , 65 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 64 , 65 , 13 , 251 , 234 , 64 , 121 , 130 , 42 , 65 , 0 , 0 , 192 , 64 , 0 , 0 , 16 , 65 , 0 , 0 , 192 , 64 , 98 , 13 , 251 , 234 , 64 , 0 , 0 , 192 , 64 , 0 , 0 , 192 , 64 , 13 , 251 , 234 , 64 , 0 , 0 , 192 , 64 , 0 , 0 , 16 , 65 , 98 , 0 , 0 , 192 , 64 , 121 , 130 , 42 , 65 , 13 , 251 , 234 , 64 , 0 , 0 , 64 , 65 , 0 , 0 , 16 , 65 , 0 , 0 , 64 , 65 , 99 , 101 , 0 , 0 }; Path p ; p . loadPathFromData ( homeIconPathData , sizeof ( homeIconPathData )); m_homeButton . setShape ( p , true , true , false ); p . clear (); p . loadPathFromData ( settingsIconPathData , sizeof ( settingsIconPathData )); m_settingsButton . setShape ( p , true , true , false ); m_titleLabel . setText ( titleText , NotificationType :: dontSendNotification ); addAndMakeVisible ( m_titleLabel ); addAndMakeVisible ( m_homeButton ); addAndMakeVisible ( m_settingsButton ); } SidePanelHeader ::~ SidePanelHeader () { } void SidePanelHeader :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( SidePanel :: backgroundColour )); // clear the background auto normal = getLookAndFeel (). findColour ( SidePanel :: dismissButtonNormalColour ); auto over = getLookAndFeel (). findColour ( SidePanel :: dismissButtonOverColour ); auto down = getLookAndFeel (). findColour ( SidePanel :: dismissButtonDownColour ); m_homeButton . setColours ( normal , over , down ); m_settingsButton . setColours ( normal , over , down ); } void SidePanelHeader :: resized () { auto bounds = getLocalBounds (); bounds . removeFromLeft ( 10 ); m_homeButton . setBounds ( bounds . removeFromLeft ( m_homeButton . getWidth () + 20 ). reduced ( 7 )); m_settingsButton . setBounds ( bounds . removeFromLeft ( m_settingsButton . getWidth () + 20 ). reduced ( 7 )); bounds . removeFromLeft ( 10 ); bounds . removeFromRight ( 10 ); m_titleLabel . setBounds ( bounds ); } I copied the path data for home button and settings button from DemoRunner. This comes with Juce Framework. Everything else is straight forward. In the MainComponent, we set this header as the title bar component of side panel. // MainComponent.cpp #include \"MainComponent.h\" #include \"SidePanelHeader.h\" MainComponent :: MainComponent () : m_invokeSidePanel ( \"Sidepanel\" , \"Show Sidepanel\" ), m_sidePanel ( \"\" , 250 , true , nullptr , false ) // we don't need the title here anymore { //... auto sidePanelHeader = new SidePanelHeader ( \"Side Panel\" ); m_sidePanel . setTitleBarComponent ( sidePanelHeader , true ); } Notice that the object is dynamically created. After we set, the parent component takes the ownership. void setTitleBarComponent ( Component * titleBarComponentToUse , bool keepDismissButton , bool deleteComponentWhenNoLongerNeeded = true ); The last parameter decides whether the parent component needs to take care of the ownership or not. Now, let\u2019s add the side panel list. This is just a list box which contains a list and responds to row selection. // SidePanelList.h #pragma once #include \"../JuceLibraryCode/JuceHeader.h\" class SidePanelList : public Component , public ListBoxModel { public : SidePanelList (); ~ SidePanelList (); void paint ( Graphics & ) override ; void resized () override ; void paintListBoxItem ( int rowNumber , Graphics & g , int width , int height , bool rowIsSelected ) override ; int getNumRows () override ; void addEntry ( const String & entry ); void selectedRowsChanged ( int row ) override ; private : ListBox m_entries ; StringArray m_sidePanelEntries ; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR ( SidePanelList ) }; // SidePanelList #include \"../JuceLibraryCode/JuceHeader.h\" #include \"SidePanelList.h\" SidePanelList :: SidePanelList () { setOpaque ( true ); addAndMakeVisible ( m_entries ); m_entries . setModel ( this ); m_entries . setRowHeight ( 40 ); } SidePanelList ::~ SidePanelList () { } void SidePanelList :: paint ( Graphics & g ) { g . fillAll ( getLookAndFeel (). findColour ( SidePanel :: backgroundColour )); // clear the background } void SidePanelList :: resized () { m_entries . setBounds ( getLocalBounds ()); } void SidePanelList :: paintListBoxItem ( int rowNumber , Graphics & g , int width , int height , bool rowIsSelected ) { if ( rowNumber < 0 || rowNumber >= getNumRows ()) return ; Rectangle < int > bounds ( 0 , 0 , width , height ); auto textColour = findColour ( Label :: textColourId ); g . setColour ( textColour . withAlpha ( 0.4f )); if ( rowNumber == 0 ) g . fillRect ( bounds . removeFromTop ( 2 ). reduced ( 10 , 0 )); g . fillRect ( bounds . removeFromBottom ( 2 ). reduced ( 10 , 0 )); if ( rowIsSelected ) { g . setColour ( findColour ( TextEditor :: highlightColourId ). withAlpha ( 0.4f )); g . fillRect ( bounds ); textColour = findColour ( TextEditor :: highlightedTextColourId ); } g . setColour ( textColour ); g . drawFittedText ( m_sidePanelEntries [ rowNumber ], bounds , Justification :: centred , 1 ); } void SidePanelList :: addEntry ( const String & entry ) { m_entries . deselectAllRows (); m_sidePanelEntries . add ( entry ); m_entries . updateContent (); } int SidePanelList :: getNumRows () { return m_sidePanelEntries . size (); } void SidePanelList :: selectedRowsChanged ( int row ) { if ( row < 0 ) return ; } We can integrate this list component with the side panel. // MainComponent.cpp MainComponent :: MainComponent () { //..... auto sidePanelList = new SidePanelList ; sidePanelList -> addEntry ( \"Entry 1\" ); sidePanelList -> addEntry ( \"Entry 2\" ); sidePanelList -> addEntry ( \"Entry 3\" ); m_sidePanel . setContent ( sidePanelList ); } The setContent is like setTitleBarComponent , it takes the ownership. After attaching all click listeners, we can update the status. The source code is shared in the github. https://github.com/asit-dhal/Juce-SidePanel-Example","title":"Header Component"},{"location":"qt-qml/positioning-with-anchors/","text":"Positioning with Anchors \u00b6 QML provides anchors to position different items relative to each others. For each item, there are 7 imaginary lines called anchor lines. An item can be placed in these anchor lines relative to another item(a parent or any sibling). The 7th anchor is baseline , for text items, it's an imaginary line on which a text rests. For letters like g, the descender goes below the baseline. Some non-latin characters can have all characters can have some part below baseline like(\u0b28\u0b4d\u0b27\u0b41 in Odia). It's only useful for text based elements. You can use any of those 7 anchor line properties to place your item. Example 1 \u00b6 We have a green rectangle at (10, 10). We want to align a blue rectangle just below it. We will align the top and left anchor line of the blue rectangle with the bottom and left anchor line of the green rectangle respectively. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Line Example-1\" ) Rectangle { id: greenRect x: 10 y: 10 width: 150 height: 120 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: blueRect width: 200 height: 120 color: \"blue\" anchors.left: greenRect . left anchors.top: greenRect . bottom border.color: Qt . lighter ( color ) } } Example 2 \u00b6 Now, we want the blue rectangle to be aligned on the right of the green rectangle, exactly at the middle of the right edge. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Line Example-2\" ) Rectangle { id: greenRect x: 10 y: 10 width: 150 height: 120 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: blueRect width: 200 height: 120 color: \"blue\" anchors.left: greenRect . right anchors.top: greenRect . verticalCenter border.color: Qt . lighter ( color ) } } Example 3 \u00b6 We want to align a rectangle just below the baseline of text, on the right of text. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Baseline Anchor Line Example\" ) Text { id: a_text x: 10 y: 10 color: \"green\" text: \"Bhubaneswar\" } Rectangle { id: blueRect width: 100 height: 60 color: \"pink\" anchors.top: a_text . baseline anchors.left: a_text . right } } fill and centerIn \u00b6 There are two more properties fill and centerIn which take another Item and aligns accordingly. fill completely accupies. Usually, all anchor lines, except verticalCenter and horizontalCenter , are aligned fully. So, height and width should be same. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Fill Example\" ) Rectangle { id: rootRect x: 10 y: 10 height: textItem . paintedHeight width: textItem . paintedWidth color: \"blue\" } Text { x: 10 y: 10 id: textItem text: \"Bhubaneswar\" color: \"lightgreen\" anchors.fill: rootRect } } In case of centerIn, verticalCenter and horizontalCenter anchor lines are aligned fully. import QtQuick 2.12 import QtQuick . Window 2.12 Window { visible: true width: 640 height: 480 title: qsTr ( \"Hello World\" ) Rectangle { id: mainRect x: 10 y: 10 height: 100 width: 100 color: \"cyan\" } Rectangle { id: innerRect x: 10 y: 10 height: 60 width: 50 color: \"green\" anchors.centerIn: mainRect } } By specifying multiple horizontal or vertical anchors you can control the size of an item. In the following case, the left and right rectangle have fixed width. The middle rectangle will always accupy the rest of spaces. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Example - 4\" ) Rectangle { id: leftRect color: \"blue\" width: 30 height: 100 anchors.left: parent . left anchors.top: parent . top } Rectangle { id: rightRect color: \"blue\" width: 30 height: 100 anchors.right: parent . right anchors.top: parent . top } Rectangle { id: middleRect color: \"green\" height: 100 anchors.left: leftRect . right anchors.right: rightRect . left } } Margins and Offsets \u00b6 Margins specify the amount of empty space to leave to the outside of an item's anchor. There are 4 types of margins(one for each edge). anchors.margin will set the all the 4 margins. It's necessary to set the anchor to set the margin. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Margin Example\" ) Rectangle { id: mainRect x: 10 y: 10 width: 150 height: 120 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: anotherRect width: 200 height: 120 color: \"blue\" anchors.left: mainRect . left anchors.top: mainRect . bottom anchors.leftMargin: 10 border.color: Qt . lighter ( color ) } } Margins can also be negative. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Negative Margin Example\" ) Rectangle { id: mainRect x: 10 y: 10 width: 150 height: 150 color: \"green\" radius: width / 2 border.color: Qt . lighter ( color ) } Rectangle { id: anotherRect width: 200 height: 120 color: \"blue\" anchors.left: mainRect . right anchors.top: mainRect . bottom anchors.leftMargin: - 25 anchors.topMargin: - 20 border.color: Qt . lighter ( color ) } } offsets allow positioning to be manipulated using the center anchor lines, offset specify empty space around the central anchor lines. -ve offset value will pull towards the corresponding axis(verticalCenterOffset towards x-axis) and +ve offset pulls away from the corresponding axis. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Offset Example\" ) Rectangle { id: mainRect x: 10 y: 10 height: 100 width: 100 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: anotherRect height: 60 width: 50 color: \"blue\" border.color: Qt . lighter ( color ) anchors.verticalCenter: mainRect . bottom anchors.left: mainRect . right anchors.verticalCenterOffset: - 10 } } Thanks for reading.","title":"Positioning with Anchors"},{"location":"qt-qml/positioning-with-anchors/#positioning-with-anchors","text":"QML provides anchors to position different items relative to each others. For each item, there are 7 imaginary lines called anchor lines. An item can be placed in these anchor lines relative to another item(a parent or any sibling). The 7th anchor is baseline , for text items, it's an imaginary line on which a text rests. For letters like g, the descender goes below the baseline. Some non-latin characters can have all characters can have some part below baseline like(\u0b28\u0b4d\u0b27\u0b41 in Odia). It's only useful for text based elements. You can use any of those 7 anchor line properties to place your item.","title":"Positioning with Anchors"},{"location":"qt-qml/positioning-with-anchors/#example-1","text":"We have a green rectangle at (10, 10). We want to align a blue rectangle just below it. We will align the top and left anchor line of the blue rectangle with the bottom and left anchor line of the green rectangle respectively. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Line Example-1\" ) Rectangle { id: greenRect x: 10 y: 10 width: 150 height: 120 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: blueRect width: 200 height: 120 color: \"blue\" anchors.left: greenRect . left anchors.top: greenRect . bottom border.color: Qt . lighter ( color ) } }","title":"Example 1"},{"location":"qt-qml/positioning-with-anchors/#example-2","text":"Now, we want the blue rectangle to be aligned on the right of the green rectangle, exactly at the middle of the right edge. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Line Example-2\" ) Rectangle { id: greenRect x: 10 y: 10 width: 150 height: 120 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: blueRect width: 200 height: 120 color: \"blue\" anchors.left: greenRect . right anchors.top: greenRect . verticalCenter border.color: Qt . lighter ( color ) } }","title":"Example 2"},{"location":"qt-qml/positioning-with-anchors/#example-3","text":"We want to align a rectangle just below the baseline of text, on the right of text. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Baseline Anchor Line Example\" ) Text { id: a_text x: 10 y: 10 color: \"green\" text: \"Bhubaneswar\" } Rectangle { id: blueRect width: 100 height: 60 color: \"pink\" anchors.top: a_text . baseline anchors.left: a_text . right } }","title":"Example 3"},{"location":"qt-qml/positioning-with-anchors/#fill-and-centerin","text":"There are two more properties fill and centerIn which take another Item and aligns accordingly. fill completely accupies. Usually, all anchor lines, except verticalCenter and horizontalCenter , are aligned fully. So, height and width should be same. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Fill Example\" ) Rectangle { id: rootRect x: 10 y: 10 height: textItem . paintedHeight width: textItem . paintedWidth color: \"blue\" } Text { x: 10 y: 10 id: textItem text: \"Bhubaneswar\" color: \"lightgreen\" anchors.fill: rootRect } } In case of centerIn, verticalCenter and horizontalCenter anchor lines are aligned fully. import QtQuick 2.12 import QtQuick . Window 2.12 Window { visible: true width: 640 height: 480 title: qsTr ( \"Hello World\" ) Rectangle { id: mainRect x: 10 y: 10 height: 100 width: 100 color: \"cyan\" } Rectangle { id: innerRect x: 10 y: 10 height: 60 width: 50 color: \"green\" anchors.centerIn: mainRect } } By specifying multiple horizontal or vertical anchors you can control the size of an item. In the following case, the left and right rectangle have fixed width. The middle rectangle will always accupy the rest of spaces. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Anchor Example - 4\" ) Rectangle { id: leftRect color: \"blue\" width: 30 height: 100 anchors.left: parent . left anchors.top: parent . top } Rectangle { id: rightRect color: \"blue\" width: 30 height: 100 anchors.right: parent . right anchors.top: parent . top } Rectangle { id: middleRect color: \"green\" height: 100 anchors.left: leftRect . right anchors.right: rightRect . left } }","title":"fill and centerIn"},{"location":"qt-qml/positioning-with-anchors/#margins-and-offsets","text":"Margins specify the amount of empty space to leave to the outside of an item's anchor. There are 4 types of margins(one for each edge). anchors.margin will set the all the 4 margins. It's necessary to set the anchor to set the margin. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Margin Example\" ) Rectangle { id: mainRect x: 10 y: 10 width: 150 height: 120 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: anotherRect width: 200 height: 120 color: \"blue\" anchors.left: mainRect . left anchors.top: mainRect . bottom anchors.leftMargin: 10 border.color: Qt . lighter ( color ) } } Margins can also be negative. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Negative Margin Example\" ) Rectangle { id: mainRect x: 10 y: 10 width: 150 height: 150 color: \"green\" radius: width / 2 border.color: Qt . lighter ( color ) } Rectangle { id: anotherRect width: 200 height: 120 color: \"blue\" anchors.left: mainRect . right anchors.top: mainRect . bottom anchors.leftMargin: - 25 anchors.topMargin: - 20 border.color: Qt . lighter ( color ) } } offsets allow positioning to be manipulated using the center anchor lines, offset specify empty space around the central anchor lines. -ve offset value will pull towards the corresponding axis(verticalCenterOffset towards x-axis) and +ve offset pulls away from the corresponding axis. import QtQuick 2.12 import QtQuick . Window 2.12 Window { id: root visible: true width: 800 height: 480 color: \"#3c3c3c\" title: qsTr ( \"Offset Example\" ) Rectangle { id: mainRect x: 10 y: 10 height: 100 width: 100 color: \"green\" border.color: Qt . lighter ( color ) } Rectangle { id: anotherRect height: 60 width: 50 color: \"blue\" border.color: Qt . lighter ( color ) anchors.verticalCenter: mainRect . bottom anchors.left: mainRect . right anchors.verticalCenterOffset: - 10 } } Thanks for reading.","title":"Margins and Offsets"}]}