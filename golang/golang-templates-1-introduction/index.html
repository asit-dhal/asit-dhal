<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Golang Templates-1 Introduction - Asit Dhal</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Golang Templates-1: Introduction", url: "#_top", children: [
              {title: "Steps to produce HTML from template file", url: "#steps-to-produce-html-from-template-file" },
              {title: "Template Names", url: "#template-names" },
              {title: "Parsing Templates", url: "#parsing-templates" },
              {title: "Executing Templates", url: "#executing-templates" },
              {title: "Error Handling", url: "#error-handling" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-58305706-1', 'asit-dhal.github.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../golang-templates-2-template-composition-and-how-to-organize-template-files/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../golang-templates-2-template-composition-and-how-to-organize-template-files/" class="btn btn-xs btn-link">
        Golang Template-2 Template composition
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../cpp/range-property-check-agorithims/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../cpp/range-property-check-agorithims/" class="btn btn-xs btn-link">
        Range Property Check Functions
      </a>
    </div>
    
  </div>

    

    <h1 id="golang-templates-1-introduction">Golang Templates-1: Introduction</h1>
<p>A template engine is a software application which generates dynamic HTML. This can be assumed as the view of the MVC paradigm. But, in reality, the template is exactly not view, a little bit of controller logic is added to make not too rigid.</p>
<p>In Golang, the handler(controller) calls the template engine, passing it the template(s) to be used, usually as a list of template files and the dynamic data. The template engine then generates the HTML and writes it to the ResponseWriter, which adds it to the HTTP response sends back to the client.</p>
<p><img alt="golang-http-server-architecture" src="../images/golang-http-server-architecture.png" /></p>
<p>A template is a string or file containing one or more portions enclosed in double braces, <code>{{â€¦}}</code>, called actions. These actions are processed by the template engine to produce dynamic HTML.</p>
<h2 id="steps-to-produce-html-from-template-file">Steps to produce HTML from template file</h2>
<ol>
<li>Parse the template string/file to create a parsed template struct.</li>
<li>Execute the parsed template, passing a ResponseWriter and some data to it.</li>
</ol>
<p><img alt="templates-to-html" src="../images/templates-to-html.png" /></p>
<pre><code class="golang">// main.go

package main

import (
    &quot;net/http&quot;
    &quot;html/template&quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    t, _ := template.ParseFiles(&quot;view.html&quot;) //setp 1
    t.Execute(w, &quot;Hello World!&quot;) //step 2
}

func main() {
    server := http.Server{
        Addr: &quot;127.0.0.1:8080&quot;,
    }
    http.HandleFunc(&quot;/view&quot;, handler)
    server.ListenAndServe()
}
</code></pre>

<pre><code class="html">&lt;!-- view.html--&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;First Program&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {{ . }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="template-names">Template Names</h2>
<p>All templates are associated with a name.</p>
<ol>
<li>Template name are defined using template.New(). In case of ParseFiles() and ParseGlob(), the first file in the argument list and the first file picked up are the names respectively. <a href="https://golang.org/pkg/html/template/#New">https://golang.org/pkg/html/template/#New</a></li>
<li>Templates can be looked up by using the name(template.Lookup()). <a href="https://golang.org/pkg/html/template/#Template.Lookup">https://golang.org/pkg/html/template/#Template.Lookup</a>.</li>
<li>Template name can be queried(template.Name()) <a href="https://golang.org/pkg/html/template/#Template.Name">https://golang.org/pkg/html/template/#Template.Name</a>.</li>
</ol>
<h2 id="parsing-templates">Parsing Templates</h2>
<p><code>template.Parse()</code> method takes a string and returns a parsed structured template.</p>
<pre><code class="golang">// main2.go

package main

import (
  &quot;html/template&quot;
  &quot;net/http&quot;
)

var tmpl = `&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {{ . }}
&lt;/body&gt;
&lt;/html&gt;
`
func handler(w http.ResponseWriter, r *http.Request) {
  t := template.New(&quot;main&quot;) //name of the template is main
  t, _ = t.Parse(tmpl) // parsing of template string
  t.Execute(w, &quot;Hello World!&quot;)
}

func main() {
  server := http.Server{
    Addr: &quot;127.0.0.1:8080&quot;,
  }
  http.HandleFunc(&quot;/view&quot;, handler)
  server.ListenAndServe()
}
</code></pre>

<p><code>template.ParseFiles()</code> is a variadic function call. It takes variable number arguments. <code>template.ParseGlob()</code> uses pattern matching.</p>
<p>Both of the above functions return a set of parsed templates. The returned template name will be the first file in PraseFiles() and the first file matched in the regular expression in ParseGlob(). https://golang.org/pkg/text/template/#ParseFiles</p>
<pre><code class="golang">// main3.go

package main
import (
  &quot;net/http&quot;
  &quot;html/template&quot;
)

func handler1(w http.ResponseWriter, r *http.Request) {
  t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;) 
  t.Execute(w, &quot;Asit&quot;)
}

func handler2(w http.ResponseWriter, r *http.Request) {
  t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;) 
  t.ExecuteTemplate(w, &quot;t2.html&quot;, &quot;Golang&quot;)
}

func main() {
  server := http.Server{
    Addr: &quot;127.0.0.1:8080&quot;,
  }

  http.HandleFunc(&quot;/t1&quot;, handler1)
  http.HandleFunc(&quot;/t2&quot;, handler2)
  server.ListenAndServe()
}
</code></pre>

<pre><code class="html">&lt;!-- t1.html--&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;T1 template&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  Hi, My name is {{ . }}.
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="html">&lt;!-- t2.html--&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;T2 template&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  Hi, I am learning {{ . }}.
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="executing-templates">Executing Templates</h2>
<p>The template.Execute() method applies a parsed template to the specified data object and writes the output to an output writer.The template.ExecuteTemplate() method works if the template contains multiple parsed template object. This is shown in the previous example.</p>
<p><code>template.ExecuteTemplate()</code> calls <code>template.Execute()</code> internally. It basically looks for the named template and executes that one.</p>
<p>In Golang library, you can see the <a href="https://golang.org/src/html/template/template.go?s=3544:3629#L103">implementation</a>.</p>
<h2 id="error-handling">Error Handling</h2>
<p>All three parse methods returns error in case of failure. The standard library provides template.Must(), which wraps around a function that returns a pointer to a template and an error, and panics if the error is not a nil.</p>
<pre><code class="golang">t  := template.Must(template.ParseFiles(&quot;tmpl.html&quot;))
</code></pre>

<p>While Executing, both the methods may fail and return error. But, by that time, some data might have been written to the buffer and sent back to browser. The programmer should handle this situation.  </p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../golang-templates-2-template-composition-and-how-to-organize-template-files/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../golang-templates-2-template-composition-and-how-to-organize-template-files/" class="btn btn-xs btn-link">
        Golang Template-2 Template composition
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../cpp/range-property-check-agorithims/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../cpp/range-property-check-agorithims/" class="btn btn-xs btn-link">
        Range Property Check Functions
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content"><p>Copyright &copy; 2017-2019 Asit Dhal</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>